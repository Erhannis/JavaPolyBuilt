{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///release/doppio.js","webpack:///webpack/bootstrap fafc27e5d3632b232e43","webpack:///../../../src/index.ts","webpack:///../../../src/doppiojvm.ts","webpack:///../../../src/testing.ts","webpack:///./shims/process.js","webpack:///external {\"root\":\"BrowserFS\",\"commonjs2\":\"browserfs\",\"commonjs\":\"browserfs\",\"amd\":\"browserfs\"}","webpack:///../../../src/jvm.ts","webpack:///./shims/BFSBuffer.js","webpack:///../../../src/util.ts","webpack:///../../../src/gLong.ts","webpack:///../../../src/enums.ts","webpack:///../../../src/SafeMap.ts","webpack:///../../../src/methods.ts","webpack:///../../../src/attributes.ts","webpack:///../../../src/assert.ts","webpack:///../../../src/threading.ts","webpack:///../../../src/opcodes.ts","webpack:///../../../src/logging.ts","webpack:///../../../src/StringOutputStream.ts","webpack:///../../../src/global.ts","webpack:///../../../src/jit.ts","webpack:///../../../src/ClassLoader.ts","webpack:///../../../src/ClassData.ts","webpack:///../../../src/ByteStream.ts","webpack:///../../../src/ConstantPool.ts","webpack:///../../../src/ClassLock.ts","webpack:///../../../src/Monitor.ts","webpack:///../../../src/classpath.ts","webpack:///./shims/fs.js","webpack:///./shims/path.js","webpack:///./shims/buffer.js","webpack:///../../../src/heap.ts","webpack:///../../../src/parker.ts","webpack:///../../../src/threadpool.ts","webpack:///./vendor/java_home/jdk.json","webpack:///../../../src/global_require.ts","webpack:///./~/pako/lib/zlib/deflate.js","webpack:///./~/pako/lib/utils/common.js","webpack:///./~/pako/lib/zlib/trees.js","webpack:///./~/pako/lib/zlib/adler32.js","webpack:///./~/pako/lib/zlib/crc32.js","webpack:///./~/pako/lib/zlib/messages.js","webpack:///./~/pako/lib/zlib/inflate.js","webpack:///./~/pako/lib/zlib/inffast.js","webpack:///./~/pako/lib/zlib/inftrees.js","webpack:///./~/pako/lib/zlib/zstream.js","webpack:///./package.json","webpack:///../../../src/difflib.ts","webpack:///../../../src/VM.ts","webpack:///../../../src/java_cli.ts","webpack:///../../../src/option_parser.ts","webpack:///../../../src/ClassFile.ts","webpack:///../../../src/fd_state.ts","webpack:///../../../src/Debug.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_4__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","doppiojvm","Testing","Heap","VM","Debug","process","makeTestingError","a","b","d","Error","originalError","fatal","findTestClasses","path","resolve","join","fs","readdir","filter","extname","map","basename","getTests","testClasses","length","doppioHomePath","DoppioTest","diff","split","e","difflib","text_diff","runTests","f","g","stdout","write","util","asyncForEach","cls","run","h","i","message","stack","JVM","OutputCapturer","_stdoutWrite","_stderrWrite","stderr","_data","_isCapturing","prototype","debugWrite","apply","start","stop","getOutput","outputCapturer","opts","indexOf","descriptor2typestr","int_classname","outFile","constructJVM","merge","getDefaultOptions","classpath","enableAssertions","enableSystemAssertions","halt","runClass","readFile","encoding","BrowserFS","BFSRequire","Buffer","pkg","SafeMap","ClassLoader","buffer","threading_1","enums_1","Parker","threadpool_1","JDKInfo","global_require_1","deflate","inflate","zstream","crc32","adler32","are_in_browser","coreClasses","systemProperties","internedStrings","bsCl","threadPool","natives","heap","nativeClasspath","startupTime","Date","terminationCb","firstThread","responsiveness","enabledAssertions","disabledAssertions","printJITCompilation","systemClassLoader","nextRef","vtraceMethods","dumpCompiledCodeDir","parker","status","JVMStatus","BOOTING","exitCode","jitDisabled","dumpJITStats","globalRequire","TypeError","intMode","bootstrapClasspath","Array","isArray","javaHomePath","disableAssertions","_initSystemProperties","tmpDir","properties","push","initializeNatives","BootstrapClassLoader","threadPoolIsEmpty","resolveClass","getConstructor","$thread","JVMThread","ref","initCarr","getResolvedClass","initializeClass","getInitializedClass","$loader","asyncSeries","setImmediate","TERMINATED","BOOTED","isReleaseBuild","getResponsiveness","getCompiledJDKURL","url","getJDKInfo","getSystemClassLoader","getNextRef","getParker","RUNNING","TERMINATING","array","initString","throwNewException","getExternalName","ext_classname","isJITDisabled","shouldVtrace","vtraceMethod","runJar","close","hasVMBooted","getThreads","forEach","setStatus","ThreadStatus","getSystemProperty","getSystemPropertyNames","Object","keys","getHeap","internString","has","get","set","evalNativeModule","Function","registerNatives","hasOwnProperty","registerNative","clsName","methSig","getNative","getNatives","substring","java.class.path","java.home","java.ext.dirs","java.io.tmpdir","sun.boot.class.path","file.encoding","java.vendor","java.version","java.vendor.url","java.class.version","java.specification.version","line.separator","file.separator","sep","path.separator","user.dir","user.home","user.name","os.name","os.arch","os.version","java.vm.name","java.vm.version","version","java.vm.vendor","java.awt.headless","java.awt.graphicsenv","jline.terminal","sun.arch.data.model","sun.jnu.encoding","getBootstrapClassLoader","getStartupTime","areSystemAssertionsEnabled","getEnabledAssertions","getDisabledAssertions","setPrintJITCompilation","shouldPrintJITCompilation","dumpCompiledCode","shouldDumpCompiledCode","dumpObjectDefinition","writeFile","dumpBridgeMethod","appendFile","dumpCompiledMethod","dumpState","getRef","getPrintableStackTrace","arguments","platform","jvmName2JSName","slice","replace","reescapeJVMName","asyncFind","checkAccess","isPublic","isProtected","getPackageName","isSubclass","isPrivate","float2int","enums","Constants","INT_MAX","INT_MIN","byteArray2Buffer","supportsArrayBuffers","ArrayBuffer","isView","byteOffset","writeInt8","isUint8Array","Uint8Array","isInt8Array","Int8Array","i82u8","u82i8","buff2i8","BFSUtils","buffer2Arrayish","wrapFloat","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","chars2jsStr","String","fromCharCode","bytestr2Array","charCodeAt","array2bytestr","initialValue","gLong","ZERO","typestr2descriptor","verify_int_classname","match","internal2external","getTypes","charAt","get_component_type","is_array_type","is_primitive_type","is_reference_type","carr2descriptor","shift","unshift","external2internal","unboxArguments","unbox","createMethodType","resolveClasses","getClassObject","pop","getMethodDescriptorWordSize","getDescriptorString","$cls","getInternalName","getLoader","getBsCl","arraycopyNoCheck","arraycopyCheck","getClass","getComponentClass","j","isCastable","newArrayFromClass","newArray","multiNewArray","newObjectFromClass","newObject","getStaticFields","newArrayFromDataWithClass","newArrayFromData","boxClassName","className","boxPrimitiveValue","box","boxArguments","k","l","forwardResult","throwException","asyncReturn","typedArraysSupported","Math","imul","expm1","abs","exp","sinh","floor","max","PUBLIC","PRIVATE","PROTECTED","STATIC","FINAL","SYNCHRONIZED","SUPER","VOLATILE","TRANSIENT","VARARGS","NATIVE","INTERFACE","ABSTRACT","STRICT","FlagMasks","Flags","isStatic","isFinal","isSynchronized","isSuper","isVolatile","isTransient","isNative","isInterface","isAbstract","isStrict","setNative","isVarArgs","getRawByte","B","C","D","F","I","J","S","V","Z","low_","high_","fromInt","IntCache_","fromNumber","isNaN","isFinite","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","fromString","pow","min","parseInt","multiply","add","toInt","toNumber","getLowBitsUnsigned","toString","isZero","isNegative","equals","div","subtract","getHighBits","getLowBits","getNumBitsAbs","isOdd","notEquals","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","not","ONE","n","TWO_PWR_24_","NEG_ONE","shiftRight","shiftLeft","ceil","log","LN2","modulo","and","or","xor","shiftRightUnsigned","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","assignOpcodeLayout","olt","NOT_LOADED","LOADED","RESOLVED","INITIALIZED","ClassState","NEW","RUNNABLE","BLOCKED","UNINTERRUPTABLY_BLOCKED","WAITING","TIMED_WAITING","ASYNC_WAITING","PARKED","ALIVE","BLOCKED_ON_MONITOR_ENTER","WAITING_INDEFINITELY","WAITING_WITH_TIMEOUT","JVMTIThreadState","TRUE","FALSE","INDETERMINATE","TriState","INTERNAL","BYTECODE","StackFrameType","FLOAT_POS_INFINITY","FLOAT_NEG_INFINITY","FLOAT_POS_INFINITY_AS_INT","FLOAT_NEG_INFINITY_AS_INT","FLOAT_NaN_AS_INT","CLASS","FIELDREF","METHODREF","INTERFACE_METHODREF","STRING","INTEGER","FLOAT","LONG","DOUBLE","NAME_AND_TYPE","UTF8","METHOD_HANDLE","METHOD_TYPE","INVOKE_DYNAMIC","ConstantPoolItemType","SAME_FRAME","SAME_LOCALS_1_STACK_ITEM_FRAME","SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED","CHOP_FRAME","SAME_FRAME_EXTENDED","APPEND_FRAME","FULL_FRAME","StackMapTableEntryType","GETFIELD","GETSTATIC","PUTFIELD","PUTSTATIC","INVOKEVIRTUAL","INVOKESTATIC","INVOKESPECIAL","NEWINVOKESPECIAL","INVOKEINTERFACE","MethodHandleReferenceKind","AALOAD","AASTORE","ACONST_NULL","ALOAD","ALOAD_0","ALOAD_1","ALOAD_2","ALOAD_3","ANEWARRAY","ARETURN","ARRAYLENGTH","ASTORE","ASTORE_0","ASTORE_1","ASTORE_2","ASTORE_3","ATHROW","BALOAD","BASTORE","BIPUSH","BREAKPOINT","CALOAD","CASTORE","CHECKCAST","D2F","D2I","D2L","DADD","DALOAD","DASTORE","DCMPG","DCMPL","DCONST_0","DCONST_1","DDIV","DLOAD","DLOAD_0","DLOAD_1","DLOAD_2","DLOAD_3","DMUL","DNEG","DREM","DRETURN","DSTORE","DSTORE_0","DSTORE_1","DSTORE_2","DSTORE_3","DSUB","DUP","DUP_X1","DUP_X2","DUP2","DUP2_X1","DUP2_X2","F2D","F2I","F2L","FADD","FALOAD","FASTORE","FCMPG","FCMPL","FCONST_0","FCONST_1","FCONST_2","FDIV","FLOAD","FLOAD_0","FLOAD_1","FLOAD_2","FLOAD_3","FMUL","FNEG","FREM","FRETURN","FSTORE","FSTORE_0","FSTORE_1","FSTORE_2","FSTORE_3","FSUB","GOTO","GOTO_W","I2B","I2C","I2D","I2F","I2L","I2S","IADD","IALOAD","IAND","IASTORE","ICONST_M1","ICONST_0","ICONST_1","ICONST_2","ICONST_3","ICONST_4","ICONST_5","IDIV","IF_ACMPEQ","IF_ACMPNE","IF_ICMPEQ","IF_ICMPGE","IF_ICMPGT","IF_ICMPLE","IF_ICMPLT","IF_ICMPNE","IFEQ","IFGE","IFGT","IFLE","IFLT","IFNE","IFNONNULL","IFNULL","IINC","ILOAD","ILOAD_0","ILOAD_1","ILOAD_2","ILOAD_3","IMUL","INEG","INSTANCEOF","INVOKEDYNAMIC","IOR","IREM","IRETURN","ISHL","ISHR","ISTORE","ISTORE_0","ISTORE_1","ISTORE_2","ISTORE_3","ISUB","IUSHR","IXOR","JSR","JSR_W","L2D","L2F","L2I","LADD","LALOAD","LAND","LASTORE","LCMP","LCONST_0","LCONST_1","LDC","LDC_W","LDC2_W","LDIV","LLOAD","LLOAD_0","LLOAD_1","LLOAD_2","LLOAD_3","LMUL","LNEG","LOOKUPSWITCH","LOR","LREM","LRETURN","LSHL","LSHR","LSTORE","LSTORE_0","LSTORE_1","LSTORE_2","LSTORE_3","LSUB","LUSHR","LXOR","MONITORENTER","MONITOREXIT","MULTIANEWARRAY","NEWARRAY","NOP","POP","POP2","RET","RETURN","SALOAD","SASTORE","SIPUSH","SWAP","TABLESWITCH","WIDE","GETSTATIC_FAST32","GETSTATIC_FAST64","NEW_FAST","ANEWARRAY_FAST","CHECKCAST_FAST","INSTANCEOF_FAST","MULTIANEWARRAY_FAST","PUTSTATIC_FAST32","PUTSTATIC_FAST64","GETFIELD_FAST32","GETFIELD_FAST64","PUTFIELD_FAST32","PUTFIELD_FAST64","INVOKENONVIRTUAL_FAST","INVOKESTATIC_FAST","INVOKEVIRTUAL_FAST","INVOKEINTERFACE_FAST","INVOKEHANDLE","INVOKEBASIC","LINKTOSPECIAL","LINKTOVIRTUAL","INVOKEDYNAMIC_FAST","OpCode","OPCODE_ONLY","CONSTANT_POOL_UINT8","CONSTANT_POOL","CONSTANT_POOL_AND_UINT8_VALUE","UINT8_VALUE","UINT8_AND_INT8_VALUE","INT8_VALUE","INT16_VALUE","INT32_VALUE","ARRAY_TYPE","OpcodeLayoutType","OpcodeLayouts","cache","create","fixKey","getTrappedMethod","trapped_methods","makeOnError","dumpStats","sort","statTraceCloser","console","__extends","constructor","attributes","StringOutputStream","jit_1","java/lang/ref/Reference","<clinit>()V","java/lang/System","loadLibrary(Ljava/lang/String;)V","java/lang/Terminator","setup()V","java/nio/charset/Charset$3","run()Ljava/lang/Object;","sun/nio/fs/DefaultFileSystemProvider","create()Ljava/nio/file/spi/FileSystemProvider;","getJVM","AbstractMethodField","slot","accessFlags","getUint16","name","value","rawDescriptor","attrs","makeAttributes","getAttribute","getName","getAttributes","getAnnotationType","rawBytes","readInt8","parseDescriptor","Field","fullName","reflector","sig","getDefaultFieldValue","outputJavaScriptField","opcodeSize","TraceInfo","pc","jitInfo","pops","pushes","prefixEmit","Trace","startPC","code","method","infos","endPc","emitEndPC","addOp","onErrorPushes","emit","Method","numBBEntries","compiledFunctions","failedCompile","signature","fullSignature","returnType","parameterTypes","parameterWords","getFullSignature","incrBBEntries","isDefault","isHidden","isCallerSensitive","getParamWordSize","getCodeAttribute","getOp","jitCompileFrom","readUInt8","makeInvokeStaticJitInfo","readUInt16BE","constantPool","paramWordSize","jsConstructor","hasBranch","reduce","reverse","makeInvokeVirtualJitInfo","makeInvokeNonVirtualJitInfo","getCode","opJitInfo","getNativeFunction","_resolveReferencedClasses","concat","exceptionHandlers","catchType","exceptions","o","q","r","s","convertArgs","isSignaturePolymorphic","methodLock","getMonitor","locals","getVMTargetBridgeMethod","flush","outputJavaScriptFunction","Code","LineNumberTable","SourceFile","StackMapTable","LocalVariableTable","LocalVariableTypeTable","ConstantValue","Exceptions","InnerClasses","Synthetic","Deprecated","Signature","RuntimeVisibleAnnotations","AnnotationDefault","EnclosingMethod","BootstrapMethods","RuntimeVisibleParameterAnnotations","getUint32","size","parse","skip","ExceptionHandler","endPC","handlerPC","maxStack","maxLocals","getMaxStack","getBuffer","entries","getLineNumber","lineNumber","filename","parseEntry","getUint8","type","offsetDelta","parseVerificationTypeInfo","numLocals","numStackItems","test","parseEntries","descriptor","parseTableEntry","index","classes","parseClass","innerInfoIndex","outerInfoIndex","innerNameIndex","innerAccessFlags","isCompiled","read","seek","pos","encClass","encMethod","bootstrapMethods","assert","printConstantPoolItem","getType","classInfo","nameAndTypeInfo","logging","debug_var","annotateOpcode","OpcodeLayoutPrinters","opcodes","maxMethodResumes","debug","vtrace","trace","methodResumesLeft","numSamples","PreAllocatedStack","curr","store","pushAll","pushWithNull","push6","swap","dup","dup2","dup_x1","dup_x2","dup2_x1","pop2","bottom","top","fromTop","sliceFromBottom","sliceFromTop","dropFromTop","sliceAndDropFromTop","getRaw","clear","jitUtil","isNull","resolveCPItem","BytecodeStackFrame","returnToThreadLoop","lockedMethodLock","opStack","LookupTable","enter","scheduleResume","scheduleException","exit","getStackTraceFrame","NativeStackFrame","args","nativeMethod","getStatus","currentMethod","InternalStackFrame","isException","cb","framePop","val","interrupted","monitor","jvm","tpool","jvmThreadObj","getJVMObject","isDaemon","getPriority","setJVMObject","isInterrupted","setInterrupted","_import","getThreadPool","getStackTrace","getTime","quantumOver","sanityCheck","rawSetStatus","log_level","VTRACE","statusChange","isBlocked","getOwner","notifyAll","signalPriorityChange","priorityChange","getMonitorBlock","handleUncaughtException","validTransitions","toLowerCase","readInt16BE","readInt32BE","ArrayTypes","initializeClassFromClass","initialize","isResolved","4","5","6","7","8","9","10","11","Opcodes","_aload_32","_aload_64","_astore_32","_astore_64","aconst_null","_const_0_32","_const_1_32","_const_2_32","iconst_m1","iconst_3","iconst_4","iconst_5","lconst_0","lconst_1","dconst_0","dconst_1","_load_32","_load_0_32","_load_1_32","_load_2_32","_load_3_32","_load_64","_load_0_64","_load_1_64","_load_2_64","_load_3_64","_store_32","_store_0_32","_store_1_32","_store_2_32","_store_3_32","_store_64","_store_0_64","_store_1_64","_store_2_64","_store_3_64","sipush","bipush","dup2_x2","iadd","ladd","fadd","dadd","isub","fsub","dsub","lsub","lmul","fmul","dmul","idiv","ldiv","fdiv","ddiv","irem","lrem","frem","drem","ineg","lneg","fneg","dneg","ishl","lshl","ishr","lshr","iushr","lushr","iand","land","ior","lor","ixor","lxor","iinc","i2l","i2f","i2d","l2i","l2f","l2d","f2i","f2l","f2d","d2i","d2l","d2f","i2b","i2c","i2s","lcmp","fcmpl","fcmpg","dcmpl","dcmpg","ifeq","ifne","iflt","ifge","ifgt","ifle","if_icmpeq","if_icmpne","if_icmplt","if_icmpge","if_icmpgt","if_icmple","if_acmpeq","if_acmpne","jsr","ret","tableswitch","lookupswitch","_return_32","_return_64","getstatic","field","isInitialized","writeUInt8","fieldOwnerConstructor","getstatic_fast32","fullFieldName","getstatic_fast64","putstatic","putstatic_fast32","putstatic_fast64","getfield","getfield_fast32","getfield_fast64","putfield","putfield_fast32","putfield_fast64","invokevirtual","invokeinterface","invokedynamic","constructCallSiteObject","invokespecial","invokestatic","invokenonvirtual_fast","invokestatic_fast","invokevirtual_fast","invokedynamic_fast","getCallSiteObject","vmtarget","invokehandle","memberName","appendix","invokebasic","linktospecial","linktovirtual","breakpoint","new_fast","clsConstructor","newarray","anewarray","arrayClass","arrayClassConstructor","anewarray_fast","arraylength","athrow","checkcast","checkcast_fast","instanceof_fast","monitorenter","monitorexit","multianewarray","multianewarray_fast","ifnull","ifnonnull","goto_w","jsr_w","nop","ldc","getConstant","ldc_w","ldc2_w","wide","iaload","faload","aaload","baload","caload","saload","daload","laload","iastore","fastore","aastore","bastore","castore","sastore","lastore","dastore","iconst_0","iconst_1","iconst_2","fconst_0","fconst_1","fconst_2","iload","iload_0","iload_1","iload_2","iload_3","fload","fload_0","fload_1","fload_2","fload_3","aload","aload_0","aload_1","aload_2","aload_3","lload","lload_0","lload_1","lload_2","lload_3","dload","dload_0","dload_1","dload_2","dload_3","istore","istore_0","istore_1","istore_2","istore_3","fstore","fstore_0","fstore_1","fstore_2","fstore_3","astore","astore_0","astore_1","astore_2","astore_3","lstore","lstore_0","lstore_1","lstore_2","lstore_3","dstore","dstore_0","dstore_1","dstore_2","dstore_3","ireturn","freturn","areturn","lreturn","dreturn","invokeinterface_fast","debug_vars","error","TRACE","DEBUG","ERROR","global","toExport","window","self","escapeStringRegEx","t","u","v","w","x","y","z","A","E","G","ClassData_1","ClassLock","classpath_1","ClassLocks","locks","tryLock","unlock","bootstrap","loadedClasses","loadClassLocks","getLoadedClassNames","addClass","defineClass","ReferenceClassData","defineArrayClass","ArrayClassData","getLoadedClass","getPrimitiveClass","tryToResolve","tryToInitialize","loadClass","_loadClass","throwClassNotFoundException","loadedPackages","ClasspathFactory","_registerLoadedClass","lastIndexOf","getPackages","getPath","PrimitiveClassData","hasClass","getLoadedClassFiles","getLoaderObject","getClassPath","getClassPathItems","CustomClassLoader","loaderObj","extendClass","ByteStream","ConstantPool","methods","injectedFields","Ljava/lang/invoke/MemberName;","vmindex","Ljava/lang/Object;","$monitor","Ljava/net/PlainSocketImpl;","$is_shutdown","$ws","Ljava/lang/Class;","signers","Ljava/lang/ClassLoader;","Ljava/lang/Thread;","injectedMethods","Ljava/lang/String;","Ljava/lang/Byte;","Ljava/lang/Character;","Ljava/lang/Double;","Ljava/lang/Float;","Ljava/lang/Integer;","Ljava/lang/Long;","Ljava/lang/Short;","Ljava/lang/Boolean;","Ljava/lang/Void;","Ljava/lang/invoke/MethodType;","injectedStaticMethods","ClassData","state","jco","superClass","loader","getSuperClass","getInterfaces","getInjectedFields","getInjectedMethods","getInjectedStaticMethods","getProtectionDomain","getMethod","getMethods","getFields","setState","getState","isSubinterface","outputInjectedMethods","createWrapperObject","_constructor","componentClassName","methodLookup","fieldLookup","setResolved","componentClass","getJSArrayConstructor","getJSDefaultArrayElement","_getSliceMethod","_constructConstructor","outputInjectedFields","interfaceClasses","superClassRef","initLock","_fieldLookup","_objectFields","_staticFields","_methodLookup","_vmTable","_uninheritedDefaultMethods","_protectionDomain","minorVersion","majorVersion","interfaceRefs","fields","hasBytes","getSuperClassReference","getInterfaceClassReferences","getVMTable","getVMIndexForMethod","getMethodFromVMIndex","getVMIndexForField","getStaticFieldFromVMIndex","getObjectFieldFromVMIndex","getFieldFromSlot","getMethodFromSlot","getSpecificMethod","getUninheritedDefaultMethods","_resolveMethods","_resolveFields","signaturePolymorphicAwareMethodLookup","getBootstrapMethod","_getInitialStaticFieldValue","stringValue","tryResolve","_initialize","getMirandaAndDefaultMethods","_index","incIndex","rewind","getFloat","readFloatBE","getDouble","readDoubleBE","getUint","getInt","getInt8","getInt16","getInt32","readUInt32BE","getInt64","peek","CP_CLASSES","ConstUTF8","bytes2str","fromBytes","infoByteSize","ConstInt32","ConstFloat","ConstLong","ConstDouble","ClassReference","NameAndTypeInfo","ConstString","MethodType","methodType","MethodReference","hasAccess","resolveMemberName","InterfaceMethodReference","FieldReference","InvokeDynamic","callSiteObjects","bootstrapMethodAttrIndex","methodHandle","MethodHandle","reference","referenceType","constructMethodHandleType","getDefiningClassObj","CONSTANT_POOL_TIER","offset","each","queue","thread","Monitor","owner","count","blocked","waiting","contendForLock","appointNewOwner","random","unblock","wait","isTimed","timer","setTimeout","unwait","clearTimeout","notify","isWaiting","isTimedWaiting","win2nix","parseMetaIndex","nodePath","relative","stat","ClasspathNotFound","isDirectory","ClasspathFolder","IndexedClasspathJar","UnindexedClasspathJar","bfsPath","BFSFS","ZipFS","FileSystem","AbstractClasspathJar","_fs","FS","_jarRead","_path","loadJar","computeIndex","tryLoadClassSync","readFileSync","_wrapOp","_wrapSyncOp","statResource","tryReaddirSync","readdirSync","tryStatSync","statSync","getFS","getRootFS","_classList","_hasClass","initializeWithClasslist","_metaIndex","_metaName","_notFoundError","_sizeMap","_buffer","_remaining","_offset","_freeLists","_numSizeClasses","malloc","size_to_class","refill","free","_chunkSize","store_word","writeInt32LE","get_byte","get_word","readInt32LE","get_buffer","get_signed_byte","set_byte","set_signed_byte","memcpy","copy","cl_to_size","ilog2","_parkCounts","_parkCallbacks","park","_mutateParkCount","isParked","unpark","completelyUnpark","isRunnable","WeightedRoundRobinScheduler","_count","_queue","_threadScheduled","scheduleThread","runThread","unscheduleThread","splice","getRunningThread","ThreadPool","threads","scheduler","emptyCallback","anyNonDaemonicThreads","threadTerminated","__esModule","getGlobalRequire","reqVar","eval","err","strm","errorCode","msg","rank","zero","buf","len","flush_pending","pending","avail_out","utils","arraySet","output","pending_buf","pending_out","next_out","total_out","flush_block_only","last","trees","_tr_flush_block","block_start","strstart","put_byte","putShortMSB","read_buf","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","MIN_LOOKAHEAD","_win","wmask","w_mask","prev","strend","MAX_MATCH","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","more","str","_w_size","window_size","hash_size","head","insert","MIN_MATCH","ins_h","hash_shift","hash_mask","deflate_stored","max_block_size","pending_buf_size","Z_NO_FLUSH","BS_NEED_MORE","max_start","Z_FINISH","BS_FINISH_STARTED","BS_FINISH_DONE","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","BS_BLOCK_DONE","deflate_slow","max_insert","prev_match","strategy","Z_FILTERED","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","lm_init","configuration_table","level","DeflateState","gzhead","gzindex","Z_DEFLATED","last_flush","w_bits","hash_bits","dyn_ltree","Buf16","HEAP_SIZE","dyn_dtree","D_CODES","bl_tree","BL_CODES","l_desc","d_desc","bl_desc","bl_count","MAX_BITS","L_CODES","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","Z_UNKNOWN","INIT_STATE","BUSY_STATE","_tr_init","Z_OK","Z_STREAM_ERROR","deflateReset","deflateSetHeader","deflateInit2","windowBits","memLevel","Z_DEFAULT_COMPRESSION","MAX_MEM_LEVEL","Z_FIXED","Buf8","deflateInit","MAX_WBITS","DEF_MEM_LEVEL","Z_DEFAULT_STRATEGY","old_flush","beg","Z_BLOCK","FINISH_STATE","Z_BUF_ERROR","text","hcrc","extra","comment","time","Z_HUFFMAN_ONLY","os","EXTRA_STATE","OS_CODE","header","level_flags","PRESET_DICT","NAME_STATE","COMMENT_STATE","HCRC_STATE","bstate","Z_RLE","Z_PARTIAL_FLUSH","_tr_align","_tr_stored_block","Z_FULL_FLUSH","Z_STREAM_END","deflateEnd","Z_DATA_ERROR","deflateSetDictionary","dictionary","avail","next","tmpDict","dictLength","LENGTH_CODES","LITERALS","deflateInfo","TYPED_OK","Uint16Array","Int32Array","assign","obj","sources","source","shrinkBuf","subarray","fnTyped","dest","src","src_offs","dest_offs","flattenChunks","chunks","chunk","result","fnUntyped","setTyped","on","Buf32","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","_dist_code","put_short","send_bits","Buf_size","send_code","tree","bi_reverse","res","bi_flush","gen_bitlen","desc","bits","xbits","stree","base","overflow","gen_codes","next_code","tr_static_init","base_length","extra_lbits","_length_code","base_dist","extra_dbits","static_ltree","static_dtree","static_l_desc","static_d_desc","static_bl_desc","extra_blbits","MAX_BL_BITS","init_block","END_BLOCK","bi_windup","copy_block","smaller","_n2","_m2","pqdownheap","compress_block","ltree","dtree","lc","lx","build_tree","node","scan_tree","curlen","prevlen","nextlen","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","build_bl_tree","max_blindex","bl_order","send_all_trees","lcodes","dcodes","blcodes","detect_data_type","black_mask","Z_BINARY","Z_TEXT","static_init_done","stored_len","STORED_BLOCK","STATIC_TREES","opt_lenb","static_lenb","DYN_TREES","DIST_CODE_LEN","s1","s2","makeTable","table","crc","crcTable","end","2","1","0","-1","-2","-3","-4","-5","-6","zswap32","InflateState","mode","havedict","flags","dmax","check","total","wbits","wsize","whave","wnext","hold","lencode","distcode","lenbits","distbits","ncode","nlen","ndist","have","lens","work","lendyn","distdyn","sane","back","was","inflateResetKeep","HEAD","ENOUGH_LENS","ENOUGH_DISTS","inflateReset","inflateReset2","inflateInit2","inflateInit","DEF_WBITS","fixedtables","virgin","sym","lenfix","distfix","inflate_table","LENS","DISTS","updatewindow","put","left","_in","_out","from","from_source","here_bits","here_op","here_val","last_bits","last_op","last_val","here","hbuf","order","TYPE","TYPEDO","inf_leave","FLAGS","done","BAD","DICTID","TIME","OS","xflags","EXLEN","extra_len","EXTRA","NAME","COMMENT","HCRC","DICT","Z_NEED_DICT","Z_TREES","CHECK","STORED","LEN_","TABLE","COPY_","COPY","LENLENS","CODES","CODELENS","LEN","inflate_fast","LIT","LENEXT","DIST","DISTEXT","MATCH","LENGTH","DONE","MEM","Z_MEM_ERROR","SYNC","inflateEnd","inflateGetHeader","inflateSetDictionary","dictid","inflateInfo","s_window","lcode","dcode","lmask","dmask","op","dolen","dodist","MAXBITS","lbase","lext","dbase","dext","lens_index","codes","table_index","incr","fill","low","mask","drop","used","huff","base_index","offs","extra_index","ZStream","engine","license","main","typings","dependencies","async","browserfs","glob","gunzip-maybe","optimist","pako","rimraf","source-map-support","tar-fs","devDependencies","bfs-buffer","bfs-path","bfs-process","body-parser","cpr","detect-browser","escodegen","esprima","estraverse","express","grunt","grunt-cli","grunt-contrib-compress","grunt-contrib-connect","grunt-contrib-copy","grunt-contrib-uglify","grunt-karma","grunt-lineending","grunt-merge-source-maps","grunt-newer","grunt-ts","grunt-webpack","imports-loader","jasmine-core","json-loader","karma","karma-chrome-launcher","karma-firefox-launcher","karma-ie-launcher","karma-jasmine","karma-opera-launcher","karma-safari-launcher","locate-java-home","semver","source-map-loader","typescript","uglify-js","underscore","webpack","webpack-dev-server","scripts","prepublish","install","appveyor-test","repository","bin","doppio","doppioh","doppio-dev","doppio-fast-dev","SequenceMatcher","__ntuplecomp","__dictget","b2j","find_longest_match","get_matching_blocks","matching_blocks","get_opcodes","CLI","ClassFile","Threading","Long","Util","Enums","Interfaces","fd_state_1","FDState","java","parser","X","mapOption","flag","printHelp","launcherName","help","printNonStandardHelp","stringOption","toUpperCase","cwd","launchJvm","unparsedArgs","option_parser_1","OptionParser","default","alias","optDesc","jar","stopParsing","enableassertions","disableassertions","enablesystemassertions","disablesystemassertions","int","dump-JIT-stats","enabled","vtrace-methods","list-class-cache","dump-compiled-code","native-classpath","bootclasspath/a","bootclasspath/p","bootclasspath","X:+PrintCompilation","getOptName","printCol","_showHelp","PrefixParseResult","_result","_unparsedArgs","_parseMap","_prefixes","_mapArgs","_rawDesc","prefix","trim","__export","Attributes","open","_positions","getPos","incrementPos","setPos","Assert","Logging","Difflib"],"mappings":"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","file":"release/doppio.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"browserfs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"browserfs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Doppio\"] = factory(require(\"browserfs\"));\n\telse\n\t\troot[\"Doppio\"] = factory(root[\"BrowserFS\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"browserfs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"browserfs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Doppio\"] = factory(require(\"browserfs\"));\n\telse\n\t\troot[\"Doppio\"] = factory(root[\"BrowserFS\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_4__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var doppiojvm=__webpack_require__(1);module.exports=doppiojvm;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var Testing=__webpack_require__(2);exports.Testing=Testing;var Heap=__webpack_require__(30);exports.Heap=Heap;var VM=__webpack_require__(47);exports.VM=VM;var Debug=__webpack_require__(53);exports.Debug=Debug;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\"use strict\";function makeTestingError(a,b,c){var d=new Error(a);return d.originalError=b,d.fatal=c,d}function findTestClasses(a,b){var c=path.resolve(a,path.join(\"classes\",\"test\"));fs.readdir(c,function(a,c){b(a?[]:c.filter(function(a){return\".java\"===path.extname(a)}).map(function(a){return path.join(\"classes\",\"test\",path.basename(a,\".java\"))}))})}function getTests(a,b){var c=a.testClasses;null==c||0===c.length?findTestClasses(a.doppioHomePath,function(c){a.testClasses=c,getTests(a,b)}):b(c.map(function(b){return new DoppioTest(a,b)}))}function diff(a,b){var c=a.split(/\\n/),d=b.split(/\\n/),e=difflib.text_diff(c,d,2);return e.length>0?\"Doppio | Java\\n\"+e.join(\"\\n\"):null}function runTests(a,b,c,d,e,f){function g(a){b||process.stdout.write(a)}getTests(a,function(a){util.asyncForEach(a,function(a,b){g(\"[\"+a.cls+\"]: Running... \"),a.run(e,function(e,f,h,i){e&&!d&&i&&(e.message+=\"\\n\"+i),e?(g(\"fail.\\n\\t\"+e.message+\"\\n\"),e.originalError&&e.originalError.stack&&g(e.stack+\"\\n\"),!c||e.fatal?(e.message=\"Failed \"+a.cls+\": \"+e.message,b(e)):b()):(g(\"pass.\\n\"),b())})},f)})}var JVM=__webpack_require__(5),util=__webpack_require__(7),difflib=__webpack_require__(46),path=__webpack_require__(28),fs=__webpack_require__(27),OutputCapturer=function(){function a(){this._stdoutWrite=process.stdout.write,this._stderrWrite=process.stderr.write,this._data=\"\",this._isCapturing=!1}return a.prototype.debugWrite=function(a){this._stdoutWrite.apply(process.stdout,[a,\"utf8\"])},a.prototype.start=function(a){var b=this;if(this._isCapturing)throw new Error(\"Already capturing.\");this._isCapturing=!0,a&&(this._data=\"\"),process.stderr.write=process.stdout.write=function(a,c,d){return\"string\"!=typeof a&&(a=a.toString()),b._data+=a,!0}},a.prototype.stop=function(){this._isCapturing&&(this._isCapturing=!1,process.stderr.write=this._stderrWrite,process.stdout.write=this._stdoutWrite)},a.prototype.getOutput=function(a){var b=this._data;return a&&(this._data=\"\"),b},a}(),DoppioTest=function(){function a(a,b){this.outputCapturer=new OutputCapturer,this.opts=a,b.indexOf(\".\")!==-1&&(b=util.descriptor2typestr(util.int_classname(b))),this.cls=b,this.outFile=path.resolve(a.doppioHomePath,b)+\".runout\"}return a.prototype.constructJVM=function(a){new JVM(util.merge(JVM.getDefaultOptions(this.opts.doppioHomePath),this.opts,{classpath:[this.opts.doppioHomePath],enableAssertions:!0,enableSystemAssertions:!0}),a)},a.prototype.run=function(a,b){var c=this,d=this.outputCapturer,e=null,f=!1,g=!1,h=!1;a(function(a){if(e)try{e.halt(1)}catch(e){a.message+=\"\\n\\nAdditionally, test runner received the following error while trying to halt the JVM: \"+e+(e.stack?\"\\n\\n\"+e.stack:\"\")+\"\\n\\nOriginal error's stack trace:\"}d.stop(),b(makeTestingError(\"Uncaught error. Aborting further tests.\\n\\t\"+a+(a.stack?\"\\n\\n\"+a.stack:\"\"),a,!0))}),this.constructJVM(function(a,i){if(e=i,!f){if(g)return b(makeTestingError(\"constructJVM returned twice. Aborting further tests.\",null,!0));g=!0,a?b(makeTestingError(\"Could not construct JVM:\\n\"+a,a)):(d.start(!0),i.runClass(c.cls,[],function(a){if(!f){if(d.stop(),h)return b(makeTestingError(\"JVM triggered completion callback twice. Aborting further tests.\",null,!0));h=!0;var e=d.getOutput(!0);fs.readFile(c.outFile,{encoding:\"utf8\"},function(a,c){if(a)b(makeTestingError(\"Could not read runout file:\\n\"+a,a));else{var d=diff(e,c),f=null;null!==d&&(f=\"Output does not match native JVM.\"),b(f?makeTestingError(f):null,e,c,d)}})}}))}})},a}();exports.DoppioTest=DoppioTest,exports.getTests=getTests,exports.diff=diff,exports.runTests=runTests;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BrowserFS = __webpack_require__(4);module.exports=BrowserFS.BFSRequire('process');\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {\"use strict\";var util=__webpack_require__(7),SafeMap=__webpack_require__(10),methods=__webpack_require__(11),ClassLoader=__webpack_require__(20),fs=__webpack_require__(27),path=__webpack_require__(28),buffer=__webpack_require__(29),threading_1=__webpack_require__(14),enums_1=__webpack_require__(9),Heap=__webpack_require__(30),assert=__webpack_require__(13),Parker=__webpack_require__(31),threadpool_1=__webpack_require__(32),JDKInfo=__webpack_require__(33),global=__webpack_require__(18),global_require_1=__webpack_require__(34),BrowserFS=__webpack_require__(4),deflate=__webpack_require__(35),inflate=__webpack_require__(41),zstream=__webpack_require__(44),crc32=__webpack_require__(39),adler32=__webpack_require__(38),pkg;pkg=util.are_in_browser()?__webpack_require__(45):__webpack_require__(45);var coreClasses=[\"Ljava/lang/String;\",\"Ljava/lang/Class;\",\"Ljava/lang/ClassLoader;\",\"Ljava/lang/reflect/Constructor;\",\"Ljava/lang/reflect/Field;\",\"Ljava/lang/reflect/Method;\",\"Ljava/lang/Error;\",\"Ljava/lang/StackTraceElement;\",\"Ljava/lang/System;\",\"Ljava/lang/Thread;\",\"Ljava/lang/ThreadGroup;\",\"Ljava/lang/Throwable;\",\"Ljava/nio/ByteOrder;\",\"Lsun/misc/VM;\",\"Lsun/reflect/ConstantPool;\",\"Ljava/lang/Byte;\",\"Ljava/lang/Character;\",\"Ljava/lang/Double;\",\"Ljava/lang/Float;\",\"Ljava/lang/Integer;\",\"Ljava/lang/Long;\",\"Ljava/lang/Short;\",\"Ljava/lang/Void;\",\"Ljava/io/FileDescriptor;\",\"Ljava/lang/Boolean;\",\"[Lsun/management/MemoryManagerImpl;\",\"[Lsun/management/MemoryPoolImpl;\",\"Lsun/nio/fs/UnixConstants;\"],JVM=function(){function a(b,c){var d=this;if(this.systemProperties=null,this.internedStrings=new SafeMap,this.bsCl=null,this.threadPool=null,this.natives={},this.heap=new Heap(20971520),this.nativeClasspath=null,this.startupTime=new Date,this.terminationCb=null,this.firstThread=null,this.responsiveness=null,this.enableSystemAssertions=!1,this.enabledAssertions=!1,this.disabledAssertions=[],this.printJITCompilation=!1,this.systemClassLoader=null,this.nextRef=0,this.vtraceMethods={},this.dumpCompiledCodeDir=null,this.parker=new Parker,this.status=enums_1.JVMStatus.BOOTING,this.exitCode=0,this.jitDisabled=!1,this.dumpJITStats=!1,this.globalRequire=null,\"string\"!=typeof b.doppioHomePath)throw new TypeError(\"opts.doppioHomePath *must* be specified.\");b=util.merge(a.getDefaultOptions(b.doppioHomePath),b),this.jitDisabled=b.intMode,this.dumpJITStats=b.dumpJITStats;var e,f,g=b.bootstrapClasspath.map(function(a){return path.resolve(a)}),h=[];if(!Array.isArray(b.bootstrapClasspath)||0===b.bootstrapClasspath.length)throw new TypeError(\"opts.bootstrapClasspath must be specified as an array of file paths.\");if(!Array.isArray(b.classpath))throw new TypeError(\"opts.classpath must be specified as an array of file paths.\");if(\"string\"!=typeof b.javaHomePath)throw new TypeError(\"opts.javaHomePath must be specified.\");if(!Array.isArray(b.nativeClasspath)||0===b.nativeClasspath.length)throw new TypeError(\"opts.nativeClasspath must be specified as an array of file paths.\");this.nativeClasspath=b.nativeClasspath,b.enableSystemAssertions&&(this.enableSystemAssertions=b.enableSystemAssertions),b.enableAssertions&&(this.enabledAssertions=b.enableAssertions),b.disableAssertions&&(this.disabledAssertions=b.disableAssertions),this.responsiveness=b.responsiveness,this._initSystemProperties(g,b.classpath.map(function(a){return path.resolve(a)}),path.resolve(b.javaHomePath),path.resolve(b.tmpDir),b.properties),h.push(function(a){d.initializeNatives(a)}),h.push(function(a){d.bsCl=new ClassLoader.BootstrapClassLoader(d.systemProperties[\"java.home\"],g,a)}),h.push(function(a){d.threadPool=new threadpool_1[\"default\"](function(){return d.threadPoolIsEmpty()}),d.bsCl.resolveClass(null,\"Ljava/lang/Thread;\",function(b){null==b?a(\"Failed to resolve java/lang/Thread.\"):(f=new(b.getConstructor(null))(null),f.$thread=e=d.firstThread=new threading_1.JVMThread(d,d.threadPool,f),f.ref=1,f[\"java/lang/Thread/priority\"]=5,f[\"java/lang/Thread/name\"]=util.initCarr(d.bsCl,\"main\"),f[\"java/lang/Thread/blockerLock\"]=new(d.bsCl.getResolvedClass(\"Ljava/lang/Object;\").getConstructor(e))(e),a())})}),h.push(function(a){util.asyncForEach(coreClasses,function(a,b){d.bsCl.initializeClass(e,a,function(c){if(null==c)b(\"Failed to initialize \"+a);else if(\"Ljava/lang/ThreadGroup;\"===a){var d=c.getConstructor(e),g=new d(e);g[\"<init>()V\"](e,null,function(a){f[\"java/lang/Thread/group\"]=g,b(a)})}else b()})},a)}),h.push(function(a){var b=d.bsCl.getInitializedClass(e,\"Ljava/lang/System;\").getConstructor(e);b[\"java/lang/System/initializeSystemClass()V\"](e,null,a)}),h.push(function(a){var b=d.bsCl.getInitializedClass(e,\"Ljava/lang/ClassLoader;\").getConstructor(e);b[\"java/lang/ClassLoader/getSystemClassLoader()Ljava/lang/ClassLoader;\"](e,null,function(b,c){if(b)a(b);else{d.systemClassLoader=c.$loader,f[\"java/lang/Thread/contextClassLoader\"]=c;var g=d.enabledAssertions===!0?1:0;c[\"java/lang/ClassLoader/setDefaultAssertionStatus(Z)V\"](e,[g],a)}})}),h.push(function(a){d.bsCl.initializeClass(e,\"Ldoppio/security/DoppioProvider;\",function(b){a(b?null:new Error(\"Failed to initialize DoppioProvider.\"))})}),util.asyncSeries(h,function(a){setImmediate(function(){a?(d.status=enums_1.JVMStatus.TERMINATED,c(a)):(d.status=enums_1.JVMStatus.BOOTED,c(null,d))})})}return a.isReleaseBuild=function(){return!0},a.prototype.getResponsiveness=function(){var a=this.responsiveness;return\"number\"==typeof a?a:\"function\"==typeof a?a():void 0},a.getDefaultOptions=function(a){var b=path.join(a,\"vendor\",\"java_home\");return{doppioHomePath:a,classpath:[\".\"],bootstrapClasspath:JDKInfo.classpath.map(function(a){return path.join(b,a)}),javaHomePath:b,nativeClasspath:[path.join(a,\"natives\")],enableSystemAssertions:!1,enableAssertions:!1,disableAssertions:null,properties:{},tmpDir:\"/tmp\",responsiveness:1e3,intMode:!1,dumpJITStats:!1}},a.getCompiledJDKURL=function(){return JDKInfo.url},a.getJDKInfo=function(){return JDKInfo},a.prototype.getSystemClassLoader=function(){return this.systemClassLoader},a.prototype.getNextRef=function(){return this.nextRef++},a.prototype.getParker=function(){return this.parker},a.prototype.runClass=function(a,b,c){var d=this;if(this.status!==enums_1.JVMStatus.BOOTED)switch(this.status){case enums_1.JVMStatus.BOOTING:throw new Error(\"JVM is currently booting up. Please wait for it to call the bootup callback, which you passed to the constructor.\");case enums_1.JVMStatus.RUNNING:throw new Error(\"JVM is already running.\");case enums_1.JVMStatus.TERMINATED:throw new Error(\"This JVM has already terminated. Please create a new JVM.\");case enums_1.JVMStatus.TERMINATING:throw new Error(\"This JVM is currently terminating. You should create a new JVM for each class you wish to run.\")}this.terminationCb=c;var e=this.firstThread;a=util.int_classname(a),this.systemClassLoader.initializeClass(e,a,function(c){if(null!=c){var f,g=d.bsCl.getInitializedClass(e,\"[Ljava/lang/String;\").getConstructor(e),h=new g(e,b.length);for(f=0;f<b.length;f++)h.array[f]=util.initString(d.bsCl,b[f]);d.status=enums_1.JVMStatus.RUNNING;var i=c.getConstructor(e);i[\"main([Ljava/lang/String;)V\"]?i[\"main([Ljava/lang/String;)V\"](e,[h]):e.throwNewException(\"Ljava/lang/NoSuchMethodError;\",\"Could not find main method in class \"+c.getExternalName()+\".\")}else process.stdout.write(\"Error: Could not find or load main class \"+util.ext_classname(a)+\"\\n\"),d.terminationCb(1)})},a.prototype.isJITDisabled=function(){return this.jitDisabled},a.prototype.shouldVtrace=function(a){return this.vtraceMethods[a]===!0},a.prototype.vtraceMethod=function(a){this.vtraceMethods[a]=!0},a.prototype.runJar=function(a,b){this.runClass(\"doppio.JarLauncher\",a,b)},a.prototype.threadPoolIsEmpty=function(){var a,b;switch(this.status){case enums_1.JVMStatus.BOOTING:return!1;case enums_1.JVMStatus.BOOTED:return!1;case enums_1.JVMStatus.RUNNING:return this.status=enums_1.JVMStatus.TERMINATING,a=this.bsCl.getInitializedClass(this.firstThread,\"Ljava/lang/System;\"),b=a.getConstructor(this.firstThread),b[\"java/lang/System/exit(I)V\"](this.firstThread,[0]),!1;case enums_1.JVMStatus.TERMINATED:return!1;case enums_1.JVMStatus.TERMINATING:return this.status=enums_1.JVMStatus.TERMINATED,this.terminationCb&&this.terminationCb(this.exitCode),this.firstThread.close(),!0}},a.prototype.hasVMBooted=function(){return!(this.status===enums_1.JVMStatus.BOOTING||this.status===enums_1.JVMStatus.BOOTED)},a.prototype.halt=function(a){this.exitCode=a,this.status=enums_1.JVMStatus.TERMINATING,this.threadPool.getThreads().forEach(function(a){a.setStatus(enums_1.ThreadStatus.TERMINATED)})},a.prototype.getSystemProperty=function(a){return this.systemProperties[a]},a.prototype.getSystemPropertyNames=function(){return Object.keys(this.systemProperties)},a.prototype.getHeap=function(){return this.heap},a.prototype.internString=function(a,b){return this.internedStrings.has(a)?this.internedStrings.get(a):(b||(b=util.initString(this.bsCl,a)),this.internedStrings.set(a,b),b)},a.prototype.evalNativeModule=function(a){function b(a){e=a}function c(a){switch(a){case\"doppiojvm\":case\"../doppiojvm\":return f;case\"fs\":return fs;case\"path\":return path;case\"buffer\":return buffer;case\"browserfs\":return BrowserFS;case\"pako/lib/zlib/zstream\":return zstream;case\"pako/lib/zlib/inflate\":return inflate;case\"pako/lib/zlib/deflate\":return deflate;case\"pako/lib/zlib/crc32\":return crc32;case\"pako/lib/zlib/adler32\":return adler32;case\"crypto\":return util.are_in_browser()?null:g(\"crypto\");default:return g(a)}}function d(a,b){var d=[];a.forEach(function(a){switch(a){case\"require\":d.push(c);break;case\"exports\":d.push({});break;default:d.push(c(a))}}),b.apply(null,d)}this.globalRequire||(this.globalRequire=global_require_1[\"default\"]());var e,f=__webpack_require__(1),g=this.globalRequire,h=new Function(\"require\",\"define\",\"registerNatives\",\"process\",\"DoppioJVM\",\"Buffer\",a);return h(c,d,b,process,f,Buffer),e},a.prototype.registerNatives=function(a){var b,c;for(b in a)if(a.hasOwnProperty(b)){this.natives.hasOwnProperty(b)||(this.natives[b]={});var d=a[b];for(c in d)d.hasOwnProperty(c)&&(this.natives[b][c]=d[c])}},a.prototype.registerNative=function(a,b,c){this.registerNatives({clsName:{methSig:c}})},a.prototype.getNative=function(a,b){if(a=util.descriptor2typestr(a),this.natives.hasOwnProperty(a)){var c=this.natives[a];if(c.hasOwnProperty(b))return c[b]}return null},a.prototype.getNatives=function(){return this.natives},a.prototype.initializeNatives=function(a){var b=this,c=function(){if(d===b.nativeClasspath.length){var f=e.length;e.forEach(function(c){fs.readFile(c,function(c,d){c||b.registerNatives(b.evalNativeModule(d.toString())),0===--f&&a()})})}else{var g=b.nativeClasspath[d++];fs.readdir(g,function(b,d){if(b)return a();var f,h;for(f=0;f<d.length;f++)h=d[f],\".js\"===h.substring(h.length-3,h.length)&&e.push(path.join(g,h));c()})}},d=0,e=[];c()},a.prototype._initSystemProperties=function(a,b,c,d,e){this.systemProperties=util.merge({\"java.class.path\":b.join(\":\"),\"java.home\":c,\"java.ext.dirs\":path.join(c,\"lib\",\"ext\"),\"java.io.tmpdir\":d,\"sun.boot.class.path\":a.join(\":\"),\"file.encoding\":\"UTF-8\",\"java.vendor\":\"Doppio\",\"java.version\":\"1.8\",\"java.vendor.url\":\"https://github.com/plasma-umass/doppio\",\"java.class.version\":\"52.0\",\"java.specification.version\":\"1.8\",\"line.separator\":\"\\n\",\"file.separator\":path.sep,\"path.separator\":\":\",\"user.dir\":path.resolve(\".\"),\"user.home\":\".\",\"user.name\":\"DoppioUser\",\"os.name\":\"doppio\",\"os.arch\":\"js\",\"os.version\":\"0\",\"java.vm.name\":\"DoppioJVM 32-bit VM\",\"java.vm.version\":pkg.version,\"java.vm.vendor\":\"PLASMA@UMass\",\"java.awt.headless\":util.are_in_browser().toString(),\"java.awt.graphicsenv\":\"classes.awt.CanvasGraphicsEnvironment\",\"jline.terminal\":\"jline.UnsupportedTerminal\",\"sun.arch.data.model\":\"32\",\"sun.jnu.encoding\":\"UTF-8\"},e)},a.prototype.getBootstrapClassLoader=function(){return this.bsCl},a.prototype.getStartupTime=function(){return this.startupTime},a.prototype.areSystemAssertionsEnabled=function(){return this.enableSystemAssertions},a.prototype.getEnabledAssertions=function(){return this.enabledAssertions},a.prototype.getDisabledAssertions=function(){return this.disabledAssertions},a.prototype.setPrintJITCompilation=function(a){this.printJITCompilation=a},a.prototype.shouldPrintJITCompilation=function(){return this.printJITCompilation},a.prototype.dumpCompiledCode=function(a){this.dumpCompiledCodeDir=a},a.prototype.shouldDumpCompiledCode=function(){return null!==this.dumpCompiledCodeDir},a.prototype.dumpObjectDefinition=function(a,b){this.shouldDumpCompiledCode()&&fs.writeFile(path.resolve(this.dumpCompiledCodeDir,a.getExternalName()+\".js\"),b,function(){})},a.prototype.dumpBridgeMethod=function(a,b){this.shouldDumpCompiledCode()&&fs.appendFile(path.resolve(this.dumpCompiledCodeDir,\"vmtarget_bridge_methods.dump\"),a+\":\\n\"+b+\"\\n\\n\",function(){})},a.prototype.dumpCompiledMethod=function(a,b,c){this.shouldDumpCompiledCode()&&fs.appendFile(path.resolve(this.dumpCompiledCodeDir,\"JIT_compiled_methods.dump\"),a+\":\"+b+\":\\n\"+c+\"\\n\\n\",function(){})},a.prototype.dumpState=function(a,b){fs.appendFile(a,this.threadPool.getThreads().map(function(a){return\"Thread \"+a.getRef()+\":\\n\"+a.getPrintableStackTrace()}).join(\"\\n\\n\"),b)},a}();module.exports=JVM;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(6)))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BrowserFS = __webpack_require__(4);module.exports=BrowserFS.BFSRequire('buffer').Buffer;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, Buffer) {\"use strict\";function merge(){for(var a=[],b=0;b<arguments.length;b++)a[b-0]=arguments[b];var c={};return a.forEach(function(a){Object.keys(a).forEach(function(b){c[b]=a[b]})}),c}function are_in_browser(){return\"browser\"===process.platform}function jvmName2JSName(a){switch(a[0]){case\"L\":return a.slice(1,a.length-1).replace(/_/g,\"__\").replace(/[\\/.;$<>\\[\\]:\\\\=^-]/g,\"_\");case\"[\":return\"ARR_\"+jvmName2JSName(a.slice(1));default:return a}}function reescapeJVMName(a){return a.replace(/\\\\/g,\"\\\\\\\\\")}function asyncForEach(a,b,c){function d(f){f?c(f):(e++,e<a.length?b(a[e],d):c())}var e=-1;d()}function asyncSeries(a,b){function c(e){e?b(e):(d++,d<a.length?a[d](c):b())}var d=-1;c()}function asyncFind(a,b,c){function d(f){f?c(a[e]):(e++,e<a.length?b(a[e],d):c())}var e=-1;d(!1)}function checkAccess(a,b,c){return!!c.isPublic()||(c.isProtected()?a.getPackageName()===b.getPackageName()||a.isSubclass(b):c.isPrivate()?a===b:a.getPackageName()===b.getPackageName())}function float2int(a){return a>enums.Constants.INT_MAX?enums.Constants.INT_MAX:a<enums.Constants.INT_MIN?enums.Constants.INT_MIN:0|a}function byteArray2Buffer(a,b,c){if(void 0===b&&(b=0),void 0===c&&(c=a.length),supportsArrayBuffers&&ArrayBuffer.isView(a)){var d=a.byteOffset;return new Buffer(a.buffer.slice(d,d+a.length))}var e,f=new Buffer(c);for(e=0;e<c;e++)f.writeInt8(a[b+e],e);return f}function isUint8Array(a){return!!(a&&\"undefined\"!=typeof Uint8Array&&a instanceof Uint8Array)}function isInt8Array(a){return!!(a&&\"undefined\"!=typeof Int8Array&&a instanceof Int8Array)}function i82u8(a,b,c){if(isInt8Array(a))return new Uint8Array(a.buffer,a.byteOffset+b,c);if(Array.isArray(a)){if(\"undefined\"!=typeof Uint8Array){var d=new Int8Array(c);return 0===b&&c===a.length?d.set(a,0):d.set(a.slice(b,b+c),0),new Uint8Array(d.buffer)}for(var e=new Array(c),f=0;f<c;f++)e[f]=255&a[b+f];return e}throw new TypeError(\"Invalid array.\")}function u82i8(a,b,c){if(isUint8Array(a))return new Int8Array(a.buffer,a.byteOffset+b,c);if(Array.isArray(a)){if(\"undefined\"!=typeof Int8Array){var d=new Uint8Array(c);return 0===b&&c===a.length?d.set(a,0):d.set(a.slice(b,b+c),0),new Int8Array(d.buffer)}for(var e=new Array(c),f=0;f<c;f++)e[f]=a[b+f],e[f]>127&&(e[f]|=4294967168);return e}throw new TypeError(\"Invalid array.\")}function buff2i8(a){var b=BFSUtils.buffer2Arrayish(a);return u82i8(b,0,b.length)}function wrapFloat(a){return a>3.4028234663852886e38?Number.POSITIVE_INFINITY:0<a&&a<1.401298464324817e-45?0:a<-3.4028234663852886e38?Number.NEGATIVE_INFINITY:0>a&&a>-1.401298464324817e-45?0:a}function chars2jsStr(a,b,c){void 0===b&&(b=0),void 0===c&&(c=a.array.length);var d,e=a.array,f=\"\",g=b+c;for(d=b;d<g;d++)f+=String.fromCharCode(e[d]);return f}function bytestr2Array(a){for(var b=[],c=0;c<a.length;c++)b.push(a.charCodeAt(c));return b}function array2bytestr(a){for(var b=\"\",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b}function initialValue(a){if(\"J\"===a)return gLong.ZERO;var b=a[0];return\"[\"===b||\"L\"===b?null:0}function ext_classname(a){return descriptor2typestr(a).replace(/\\//g,\".\")}function int_classname(a){return typestr2descriptor(a.replace(/\\./g,\"/\"))}function verify_int_classname(a){var b=a.match(/^\\[*/)[0].length;if(b>255)return!1;if(b>0&&(a=a.slice(b)),\"L\"===a[0]){if(\";\"!==a[a.length-1])return!1;a=a.slice(1,-1)}if(a in exports.internal2external)return!0;if(a.match(/\\/{2,}/))return!1;for(var c=a.split(\"/\"),d=0;d<c.length;d++)if(c[d].match(/[^$_a-z0-9]/i))return!1;return!0}function getTypes(a){var b,c=0,d=[];for(c=0;c<a.length;c++)switch(a.charAt(c)){case\"(\":case\")\":break;case\"L\":b=a.indexOf(\";\",c),d.push(a.slice(c,b+1)),c=b;break;case\"[\":for(b=c+1;\"[\"===a.charAt(b);)b++;\"L\"===a.charAt(b)?(b=a.indexOf(\";\",b),d.push(a.slice(c,b+1))):d.push(a.slice(c,b+1)),c=b;break;default:d.push(a.charAt(c))}return d}function get_component_type(a){return a.slice(1)}function is_array_type(a){return\"[\"===a[0]}function is_primitive_type(a){return a in exports.internal2external}function is_reference_type(a){return\"L\"===a[0]}function descriptor2typestr(a){var b=a[0];if(b in exports.internal2external)return exports.internal2external[b];if(\"L\"===b)return a.slice(1,-1);if(\"[\"===b)return a;throw new Error(\"Unrecognized type string: \"+a)}function carr2descriptor(a){var b=a.shift();if(null==b)return null;if(void 0!==exports.internal2external[b])return b;if(\"L\"===b){for(var c=\"L\";\";\"!==(b=a.shift());)c+=b;return c+\";\"}if(\"[\"===b)return\"[\"+carr2descriptor(a);throw a.unshift(b),new Error(\"Unrecognized descriptor: \"+a.join(\"\"))}function typestr2descriptor(a){return void 0!==exports.external2internal[a]?exports.external2internal[a]:\"[\"===a[0]?a:\"L\"+a+\";\"}function unboxArguments(a,b,c){var d,e,f,g=[];for(d=0;d<b.length;d++)e=b[d],f=c[d],is_primitive_type(e)?(g.push(f.unbox()),\"J\"!==e&&\"D\"!==e||g.push(null)):g.push(f);return g}function createMethodType(a,b,c,d){b.initializeClass(a,\"Ljava/lang/invoke/MethodHandleNatives;\",function(e){if(null!==e){var f=e.getConstructor(a),g=getTypes(c);g.push(\"[Ljava/lang/Class;\"),b.resolveClasses(a,g,function(b){var c=g.map(function(c){return b[c].getClassObject(a)});c.pop();var e=c.pop(),h=b[\"[Ljava/lang/Class;\"].getConstructor(a),i=new h(a,c.length);i.array=c,f[\"java/lang/invoke/MethodHandleNatives/findMethodHandleType(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/invoke/MethodType;\"](a,[e,i],d)})}})}function getMethodDescriptorWordSize(a){var b,c,d=getTypes(a),e=d.length-1;for(d.pop(),b=0;b<d.length;b++)c=d[b],\"D\"!==c&&\"J\"!==c||e++;return e}function getDescriptorString(a,b){var c=\"(\";return void 0!==b&&null!==b&&b.array.forEach(function(a){c+=a.$cls.getInternalName()}),c+=\")\"+a.$cls.getInternalName()}function getLoader(a,b){return null!=b&&null!=b.$loader?b.$loader:a.getBsCl()}function arraycopyNoCheck(a,b,c,d,e){for(var f=d,g=b+e,h=b;h<g;h++)c.array[f++]=a.array[h]}function arraycopyCheck(a,b,c,d,e,f){for(var g=e,h=c+f,i=d.getClass().getComponentClass(),j=c;j<h;j++){if(null!==b.array[j]&&!b.array[j].getClass().isCastable(i))return void a.throwNewException(\"Ljava/lang/ArrayStoreException;\",\"Array element in src cannot be cast to dest array type.\");d.array[g]=b.array[j],g++}}function initString(a,b){var c=initCarr(a,b),d=a.getResolvedClass(\"Ljava/lang/String;\").getConstructor(null),e=new d(null);return e[\"java/lang/String/value\"]=c,e}function initCarr(a,b){for(var c=a.getInitializedClass(null,\"[C\").getConstructor(null),d=new c(null,b.length),e=d.array,f=0;f<b.length;f++)e[f]=b.charCodeAt(f);return d}function newArrayFromClass(a,b,c){return new(b.getConstructor(a))(a,c)}function newArray(a,b,c,d){var e=b.getInitializedClass(a,c);return newArrayFromClass(a,e,d)}function multiNewArray(a,b,c,d){var e=b.getInitializedClass(a,c);return new(e.getConstructor(a))(a,d)}function newObjectFromClass(a,b){return new(b.getConstructor(a))(a)}function newObject(a,b,c){var d=b.getInitializedClass(a,c);return newObjectFromClass(a,d)}function getStaticFields(a,b,c){return b.getInitializedClass(a,c).getConstructor(a)}function newArrayFromDataWithClass(a,b,c){var d=newArrayFromClass(a,b,0);return d.array=c,d}function newArrayFromData(a,b,c,d){var e=newArray(a,b,c,0);return e.array=d,e}function boxClassName(a){switch(a){case\"B\":return\"Ljava/lang/Byte;\";case\"C\":return\"Ljava/lang/Character;\";case\"D\":return\"Ljava/lang/Double;\";case\"F\":return\"Ljava/lang/Float;\";case\"I\":return\"Ljava/lang/Integer;\";case\"J\":return\"Ljava/lang/Long;\";case\"S\":return\"Ljava/lang/Short;\";case\"Z\":return\"Ljava/lang/Boolean;\";case\"V\":return\"Ljava/lang/Void;\";default:throw new Error(\"Tried to box a non-primitive class: \"+this.className)}}function boxPrimitiveValue(a,b,c){var d=a.getBsCl().getInitializedClass(a,boxClassName(b)),e=d.getConstructor(a);return e.box(c)}function boxArguments(a,b,c,d,e,f){void 0===f&&(f=0);var g,h,i=getTypes(c),j=newArrayFromClass(a,b,i.length-(e?1:2)-f),k=0,l=j.array;for(i.pop(),e||i.shift(),f>0&&(i=i.slice(f),d=d.slice(f)),g=0;g<i.length;g++){switch(h=i[g],h[0]){case\"[\":case\"L\":l[g]=d[k];break;case\"J\":case\"D\":l[g]=boxPrimitiveValue(a,h,d[k]),k++;break;default:l[g]=boxPrimitiveValue(a,h,d[k])}k++}return j}function forwardResult(a){return function(b,c){b?a.throwException(b):a.asyncReturn(c)}}var gLong=__webpack_require__(8),enums=__webpack_require__(9),BrowserFS=__webpack_require__(4),BFSUtils=BrowserFS.BFSRequire(\"bfs_utils\");exports.merge=merge,exports.are_in_browser=are_in_browser,exports.typedArraysSupported=\"undefined\"!=typeof ArrayBuffer,exports.jvmName2JSName=jvmName2JSName,exports.reescapeJVMName=reescapeJVMName,exports.asyncForEach=asyncForEach,exports.asyncSeries=asyncSeries,exports.asyncFind=asyncFind,Math.imul||(Math.imul=function(a,b){var c=a>>>16&65535,d=65535&a,e=b>>>16&65535,f=65535&b;return d*f+(c*f+d*e<<16>>>0)|0}),Math.expm1||(Math.expm1=function(a){return Math.abs(a)<1e-5?a+.5*a*a:Math.exp(a)-1}),Math.sinh||(Math.sinh=function(a){var b=Math.exp(a);return(b-1/b)/2}),Array.prototype.indexOf||(Array.prototype.indexOf=function(a,b){if(null==this)throw new TypeError;var c=Object(this),d=c.length>>>0;if(0===d)return-1;var e=0;if(void 0!==b&&(e=Number(b),e!=e?e=0:0!=e&&e!=1/0&&e!=-(1/0)&&(e=((e>0?1:0)||-1)*Math.floor(Math.abs(e)))),e>=d)return-1;for(var f=e>=0?e:Math.max(d-Math.abs(e),0);f<d;f++)if(f in c&&c[f]===a)return f;return-1}),exports.checkAccess=checkAccess,exports.float2int=float2int;var supportsArrayBuffers=\"undefined\"!=typeof ArrayBuffer;exports.byteArray2Buffer=byteArray2Buffer,exports.isUint8Array=isUint8Array,exports.isInt8Array=isInt8Array,exports.i82u8=i82u8,exports.u82i8=u82i8,exports.buff2i8=buff2i8,exports.wrapFloat=wrapFloat,exports.chars2jsStr=chars2jsStr,exports.bytestr2Array=bytestr2Array,exports.array2bytestr=array2bytestr,function(a){a[a.PUBLIC=1]=\"PUBLIC\",a[a.PRIVATE=2]=\"PRIVATE\",a[a.PROTECTED=4]=\"PROTECTED\",a[a.STATIC=8]=\"STATIC\",a[a.FINAL=16]=\"FINAL\",a[a.SYNCHRONIZED=32]=\"SYNCHRONIZED\",a[a.SUPER=32]=\"SUPER\",a[a.VOLATILE=64]=\"VOLATILE\",a[a.TRANSIENT=128]=\"TRANSIENT\",a[a.VARARGS=128]=\"VARARGS\",a[a.NATIVE=256]=\"NATIVE\",a[a.INTERFACE=512]=\"INTERFACE\",a[a.ABSTRACT=1024]=\"ABSTRACT\",a[a.STRICT=2048]=\"STRICT\"}(exports.FlagMasks||(exports.FlagMasks={}));var FlagMasks=exports.FlagMasks,Flags=function(){function a(a){this[\"byte\"]=a}return a.prototype.isPublic=function(){return(this[\"byte\"]&FlagMasks.PUBLIC)>0},a.prototype.isPrivate=function(){return(this[\"byte\"]&FlagMasks.PRIVATE)>0},a.prototype.isProtected=function(){return(this[\"byte\"]&FlagMasks.PROTECTED)>0},a.prototype.isStatic=function(){return(this[\"byte\"]&FlagMasks.STATIC)>0},a.prototype.isFinal=function(){return(this[\"byte\"]&FlagMasks.FINAL)>0},a.prototype.isSynchronized=function(){return(this[\"byte\"]&FlagMasks.SYNCHRONIZED)>0},a.prototype.isSuper=function(){return(this[\"byte\"]&FlagMasks.SUPER)>0},a.prototype.isVolatile=function(){return(this[\"byte\"]&FlagMasks.VOLATILE)>0},a.prototype.isTransient=function(){return(this[\"byte\"]&FlagMasks.TRANSIENT)>0},a.prototype.isNative=function(){return(this[\"byte\"]&FlagMasks.NATIVE)>0},a.prototype.isInterface=function(){return(this[\"byte\"]&FlagMasks.INTERFACE)>0},a.prototype.isAbstract=function(){return(this[\"byte\"]&FlagMasks.ABSTRACT)>0},a.prototype.isStrict=function(){return(this[\"byte\"]&FlagMasks.STRICT)>0},a.prototype.setNative=function(a){a?this[\"byte\"]=this[\"byte\"]|FlagMasks.NATIVE:this[\"byte\"]=this[\"byte\"]&~FlagMasks.NATIVE},a.prototype.isVarArgs=function(){return(this[\"byte\"]&FlagMasks.VARARGS)>0},a.prototype.getRawByte=function(){return this[\"byte\"]},a}();exports.Flags=Flags,exports.initialValue=initialValue,exports.ext_classname=ext_classname,exports.int_classname=int_classname,exports.verify_int_classname=verify_int_classname,exports.internal2external={B:\"byte\",C:\"char\",D:\"double\",F:\"float\",I:\"int\",J:\"long\",S:\"short\",V:\"void\",Z:\"boolean\"},exports.external2internal={};for(var k in exports.internal2external)exports.external2internal[exports.internal2external[k]]=k;exports.getTypes=getTypes,exports.get_component_type=get_component_type,exports.is_array_type=is_array_type,exports.is_primitive_type=is_primitive_type,exports.is_reference_type=is_reference_type,exports.descriptor2typestr=descriptor2typestr,exports.carr2descriptor=carr2descriptor,exports.typestr2descriptor=typestr2descriptor,exports.unboxArguments=unboxArguments,exports.createMethodType=createMethodType,exports.getMethodDescriptorWordSize=getMethodDescriptorWordSize,exports.getDescriptorString=getDescriptorString,exports.getLoader=getLoader,exports.arraycopyNoCheck=arraycopyNoCheck,exports.arraycopyCheck=arraycopyCheck,exports.initString=initString,exports.initCarr=initCarr,exports.newArrayFromClass=newArrayFromClass,exports.newArray=newArray,exports.multiNewArray=multiNewArray,exports.newObjectFromClass=newObjectFromClass,exports.newObject=newObject,exports.getStaticFields=getStaticFields,exports.newArrayFromDataWithClass=newArrayFromDataWithClass,exports.newArrayFromData=newArrayFromData,exports.boxClassName=boxClassName,exports.boxPrimitiveValue=boxPrimitiveValue,exports.boxArguments=boxArguments,exports.forwardResult=forwardResult;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(6)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";var gLong=function(){function a(a,b){this.low_=0|a,this.high_=0|b}return a.fromInt=function(b){if(-128<=b&&b<128){var c=a.IntCache_[b];if(c)return c}var d=new a(b,b<0?-1:0);return-128<=b&&b<128&&(a.IntCache_[b]=d),d},a.fromNumber=function(b){return isNaN(b)||!isFinite(b)?a.ZERO:b<=-a.TWO_PWR_63_DBL_?a.MIN_VALUE:b+1>=a.TWO_PWR_63_DBL_?a.MAX_VALUE:b<0?a.fromNumber(-b).negate():new a(b%a.TWO_PWR_32_DBL_|0,b/a.TWO_PWR_32_DBL_|0)},a.fromBits=function(b,c){return new a(b,c)},a.fromString=function(b,c){if(0==b.length)throw Error(\"number format error: empty string\");var d=c||10;if(d<2||36<d)throw Error(\"radix out of range: \"+d);if(\"-\"==b.charAt(0))return a.fromString(b.substring(1),d).negate();if(b.indexOf(\"-\")>=0)throw Error('number format error: interior \"-\" character: '+b);for(var e=a.fromNumber(Math.pow(d,8)),f=a.ZERO,g=0;g<b.length;g+=8){var h=Math.min(8,b.length-g),i=parseInt(b.substring(g,g+h),d);if(h<8){var j=a.fromNumber(Math.pow(d,h));f=f.multiply(j).add(a.fromNumber(i))}else f=f.multiply(e),f=f.add(a.fromNumber(i))}return f},a.prototype.toInt=function(){return this.low_},a.prototype.toNumber=function(){return this.high_*a.TWO_PWR_32_DBL_+this.getLowBitsUnsigned()},a.prototype.toString=function(b){var c=b||10;if(c<2||36<c)throw Error(\"radix out of range: \"+c);if(this.isZero())return\"0\";if(this.isNegative()){if(this.equals(a.MIN_VALUE)){var d=a.fromNumber(c),e=this.div(d),f=e.multiply(d).subtract(this);return e.toString(c)+f.toInt().toString(c)}return\"-\"+this.negate().toString(c)}for(var g=a.fromNumber(Math.pow(c,6)),f=this,h=\"\";;){var i=f.div(g),j=f.subtract(i.multiply(g)).toInt(),k=j.toString(c);if(f=i,f.isZero())return k+h;for(;k.length<6;)k=\"0\"+k;h=\"\"+k+h}},a.prototype.getHighBits=function(){return this.high_},a.prototype.getLowBits=function(){return this.low_},a.prototype.getLowBitsUnsigned=function(){return this.low_>=0?this.low_:a.TWO_PWR_32_DBL_+this.low_},a.prototype.getNumBitsAbs=function(){if(this.isNegative())return this.equals(a.MIN_VALUE)?64:this.negate().getNumBitsAbs();for(var b=0!=this.high_?this.high_:this.low_,c=31;c>0&&0==(b&1<<c);c--);return 0!=this.high_?c+33:c+1},a.prototype.isZero=function(){return 0==this.high_&&0==this.low_},a.prototype.isNegative=function(){return this.high_<0},a.prototype.isOdd=function(){return 1==(1&this.low_)},a.prototype.equals=function(a){return this.high_==a.high_&&this.low_==a.low_},a.prototype.notEquals=function(a){return this.high_!=a.high_||this.low_!=a.low_},a.prototype.lessThan=function(a){return this.compare(a)<0},a.prototype.lessThanOrEqual=function(a){return this.compare(a)<=0},a.prototype.greaterThan=function(a){return this.compare(a)>0},a.prototype.greaterThanOrEqual=function(a){return this.compare(a)>=0},a.prototype.compare=function(a){if(this.equals(a))return 0;var b=this.isNegative(),c=a.isNegative();return b&&!c?-1:!b&&c?1:this.subtract(a).isNegative()?-1:1},a.prototype.negate=function(){return this.equals(a.MIN_VALUE)?a.MIN_VALUE:this.not().add(a.ONE)},a.prototype.add=function(b){var c=this.high_>>>16,d=65535&this.high_,e=this.low_>>>16,f=65535&this.low_,g=b.high_>>>16,h=65535&b.high_,i=b.low_>>>16,j=65535&b.low_,k=0,l=0,m=0,n=0;return n+=f+j,m+=n>>>16,n&=65535,m+=e+i,l+=m>>>16,m&=65535,l+=d+h,k+=l>>>16,l&=65535,k+=c+g,k&=65535,a.fromBits(m<<16|n,k<<16|l)},a.prototype.subtract=function(a){return this.add(a.negate())},a.prototype.multiply=function(b){if(this.isZero())return a.ZERO;if(b.isZero())return a.ZERO;if(this.equals(a.MIN_VALUE))return b.isOdd()?a.MIN_VALUE:a.ZERO;if(b.equals(a.MIN_VALUE))return this.isOdd()?a.MIN_VALUE:a.ZERO;if(this.isNegative())return b.isNegative()?this.negate().multiply(b.negate()):this.negate().multiply(b).negate();if(b.isNegative())return this.multiply(b.negate()).negate();if(this.lessThan(a.TWO_PWR_24_)&&b.lessThan(a.TWO_PWR_24_))return a.fromNumber(this.toNumber()*b.toNumber());var c=this.high_>>>16,d=65535&this.high_,e=this.low_>>>16,f=65535&this.low_,g=b.high_>>>16,h=65535&b.high_,i=b.low_>>>16,j=65535&b.low_,k=0,l=0,m=0,n=0;return n+=f*j,m+=n>>>16,n&=65535,m+=e*j,l+=m>>>16,m&=65535,m+=f*i,l+=m>>>16,m&=65535,l+=d*j,k+=l>>>16,l&=65535,l+=e*i,k+=l>>>16,l&=65535,l+=f*h,k+=l>>>16,l&=65535,k+=c*j+d*i+e*h+f*g,k&=65535,a.fromBits(m<<16|n,k<<16|l)},a.prototype.div=function(b){if(b.isZero())throw Error(\"division by zero\");if(this.isZero())return a.ZERO;if(this.equals(a.MIN_VALUE)){if(b.equals(a.ONE)||b.equals(a.NEG_ONE))return a.MIN_VALUE;if(b.equals(a.MIN_VALUE))return a.ONE;var c=this.shiftRight(1),d=c.div(b).shiftLeft(1);if(d.equals(a.ZERO))return b.isNegative()?a.ONE:a.NEG_ONE;var e=this.subtract(b.multiply(d)),f=d.add(e.div(b));return f}if(b.equals(a.MIN_VALUE))return a.ZERO;if(this.isNegative())return b.isNegative()?this.negate().div(b.negate()):this.negate().div(b).negate();if(b.isNegative())return this.div(b.negate()).negate();for(var g=a.ZERO,e=this;e.greaterThanOrEqual(b);){var h=Math.max(1,Math.floor(e.toNumber()/b.toNumber())),i=Math.ceil(Math.log(h)/Math.LN2),j=1;i>48&&(j=Math.pow(2,i-48));for(var k=a.fromNumber(h),l=k.multiply(b);l.isNegative()||l.greaterThan(e);)h-=j,k=a.fromNumber(h),l=k.multiply(b);k.isZero()&&(k=a.ONE),g=g.add(k),e=e.subtract(l)}return g},a.prototype.modulo=function(a){return this.subtract(this.div(a).multiply(a))},a.prototype.not=function(){return a.fromBits(~this.low_,~this.high_)},a.prototype.and=function(b){return a.fromBits(this.low_&b.low_,this.high_&b.high_)},a.prototype.or=function(b){return a.fromBits(this.low_|b.low_,this.high_|b.high_)},a.prototype.xor=function(b){return a.fromBits(this.low_^b.low_,this.high_^b.high_)},a.prototype.shiftLeft=function(b){if(b&=63,0==b)return this;var c=this.low_;if(b<32){var d=this.high_;return a.fromBits(c<<b,d<<b|c>>>32-b)}return a.fromBits(0,c<<b-32)},a.prototype.shiftRight=function(b){if(b&=63,0==b)return this;var c=this.high_;if(b<32){var d=this.low_;return a.fromBits(d>>>b|c<<32-b,c>>b)}return a.fromBits(c>>b-32,c>=0?0:-1)},a.prototype.shiftRightUnsigned=function(b){if(b&=63,0==b)return this;var c=this.high_;if(b<32){var d=this.low_;return a.fromBits(d>>>b|c<<32-b,c>>>b)}return 32==b?a.fromBits(c,0):a.fromBits(c>>>b-32,0)},a.IntCache_={},a.TWO_PWR_16_DBL_=65536,a.TWO_PWR_24_DBL_=1<<24,a.TWO_PWR_32_DBL_=a.TWO_PWR_16_DBL_*a.TWO_PWR_16_DBL_,a.TWO_PWR_31_DBL_=a.TWO_PWR_32_DBL_/2,a.TWO_PWR_48_DBL_=a.TWO_PWR_32_DBL_*a.TWO_PWR_16_DBL_,a.TWO_PWR_64_DBL_=a.TWO_PWR_32_DBL_*a.TWO_PWR_32_DBL_,a.TWO_PWR_63_DBL_=a.TWO_PWR_64_DBL_/2,a.ZERO=a.fromInt(0),a.ONE=a.fromInt(1),a.NEG_ONE=a.fromInt(-1),a.MAX_VALUE=a.fromBits(4294967295,2147483647),a.MIN_VALUE=a.fromBits(0,2147483648),a.TWO_PWR_24_=a.fromInt(a.TWO_PWR_24_DBL_),a}();module.exports=gLong;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";function assignOpcodeLayout(a,b){b.forEach(function(b){olt[b]=a})}!function(a){a[a.NOT_LOADED=0]=\"NOT_LOADED\",a[a.LOADED=1]=\"LOADED\",a[a.RESOLVED=2]=\"RESOLVED\",a[a.INITIALIZED=3]=\"INITIALIZED\"}(exports.ClassState||(exports.ClassState={}));var ClassState=exports.ClassState;!function(a){a[a.NEW=0]=\"NEW\",a[a.RUNNABLE=1]=\"RUNNABLE\",a[a.BLOCKED=2]=\"BLOCKED\",a[a.UNINTERRUPTABLY_BLOCKED=3]=\"UNINTERRUPTABLY_BLOCKED\",a[a.WAITING=4]=\"WAITING\",a[a.TIMED_WAITING=5]=\"TIMED_WAITING\",a[a.ASYNC_WAITING=6]=\"ASYNC_WAITING\",a[a.PARKED=7]=\"PARKED\",a[a.TERMINATED=8]=\"TERMINATED\"}(exports.ThreadStatus||(exports.ThreadStatus={}));var ThreadStatus=exports.ThreadStatus;!function(a){a[a.ALIVE=1]=\"ALIVE\",a[a.TERMINATED=2]=\"TERMINATED\",a[a.RUNNABLE=4]=\"RUNNABLE\",a[a.BLOCKED_ON_MONITOR_ENTER=1024]=\"BLOCKED_ON_MONITOR_ENTER\",a[a.WAITING_INDEFINITELY=16]=\"WAITING_INDEFINITELY\",a[a.WAITING_WITH_TIMEOUT=32]=\"WAITING_WITH_TIMEOUT\"}(exports.JVMTIThreadState||(exports.JVMTIThreadState={}));var JVMTIThreadState=exports.JVMTIThreadState;!function(a){a[a.TRUE=0]=\"TRUE\",a[a.FALSE=1]=\"FALSE\",a[a.INDETERMINATE=2]=\"INDETERMINATE\"}(exports.TriState||(exports.TriState={}));var TriState=exports.TriState;!function(a){a[a.BOOTING=0]=\"BOOTING\",a[a.BOOTED=1]=\"BOOTED\",a[a.RUNNING=2]=\"RUNNING\",a[a.TERMINATING=3]=\"TERMINATING\",a[a.TERMINATED=4]=\"TERMINATED\"}(exports.JVMStatus||(exports.JVMStatus={}));var JVMStatus=exports.JVMStatus;!function(a){a[a.INTERNAL=0]=\"INTERNAL\",a[a.BYTECODE=1]=\"BYTECODE\",a[a.NATIVE=2]=\"NATIVE\"}(exports.StackFrameType||(exports.StackFrameType={}));var StackFrameType=exports.StackFrameType;!function(a){a[a.INT_MAX=Math.pow(2,31)-1]=\"INT_MAX\",a[a.INT_MIN=-a.INT_MAX-1]=\"INT_MIN\",a[a.FLOAT_POS_INFINITY=Math.pow(2,128)]=\"FLOAT_POS_INFINITY\",a[a.FLOAT_NEG_INFINITY=-1*a.FLOAT_POS_INFINITY]=\"FLOAT_NEG_INFINITY\",a[a.FLOAT_POS_INFINITY_AS_INT=2139095040]=\"FLOAT_POS_INFINITY_AS_INT\",a[a.FLOAT_NEG_INFINITY_AS_INT=-8388608]=\"FLOAT_NEG_INFINITY_AS_INT\",a[a.FLOAT_NaN_AS_INT=2143289344]=\"FLOAT_NaN_AS_INT\"}(exports.Constants||(exports.Constants={}));var Constants=exports.Constants;!function(a){a[a.CLASS=7]=\"CLASS\",a[a.FIELDREF=9]=\"FIELDREF\",a[a.METHODREF=10]=\"METHODREF\",a[a.INTERFACE_METHODREF=11]=\"INTERFACE_METHODREF\",a[a.STRING=8]=\"STRING\",a[a.INTEGER=3]=\"INTEGER\",a[a.FLOAT=4]=\"FLOAT\",a[a.LONG=5]=\"LONG\",a[a.DOUBLE=6]=\"DOUBLE\",a[a.NAME_AND_TYPE=12]=\"NAME_AND_TYPE\",a[a.UTF8=1]=\"UTF8\",a[a.METHOD_HANDLE=15]=\"METHOD_HANDLE\",a[a.METHOD_TYPE=16]=\"METHOD_TYPE\",a[a.INVOKE_DYNAMIC=18]=\"INVOKE_DYNAMIC\"}(exports.ConstantPoolItemType||(exports.ConstantPoolItemType={}));var ConstantPoolItemType=exports.ConstantPoolItemType;!function(a){a[a.SAME_FRAME=0]=\"SAME_FRAME\",a[a.SAME_LOCALS_1_STACK_ITEM_FRAME=1]=\"SAME_LOCALS_1_STACK_ITEM_FRAME\",a[a.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED=2]=\"SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\",a[a.CHOP_FRAME=3]=\"CHOP_FRAME\",a[a.SAME_FRAME_EXTENDED=4]=\"SAME_FRAME_EXTENDED\",a[a.APPEND_FRAME=5]=\"APPEND_FRAME\",a[a.FULL_FRAME=6]=\"FULL_FRAME\"}(exports.StackMapTableEntryType||(exports.StackMapTableEntryType={}));var StackMapTableEntryType=exports.StackMapTableEntryType;!function(a){a[a.GETFIELD=1]=\"GETFIELD\",a[a.GETSTATIC=2]=\"GETSTATIC\",a[a.PUTFIELD=3]=\"PUTFIELD\",a[a.PUTSTATIC=4]=\"PUTSTATIC\",a[a.INVOKEVIRTUAL=5]=\"INVOKEVIRTUAL\",a[a.INVOKESTATIC=6]=\"INVOKESTATIC\",a[a.INVOKESPECIAL=7]=\"INVOKESPECIAL\",a[a.NEWINVOKESPECIAL=8]=\"NEWINVOKESPECIAL\",a[a.INVOKEINTERFACE=9]=\"INVOKEINTERFACE\"}(exports.MethodHandleReferenceKind||(exports.MethodHandleReferenceKind={}));var MethodHandleReferenceKind=exports.MethodHandleReferenceKind;!function(a){a[a.AALOAD=50]=\"AALOAD\",a[a.AASTORE=83]=\"AASTORE\",a[a.ACONST_NULL=1]=\"ACONST_NULL\",a[a.ALOAD=25]=\"ALOAD\",a[a.ALOAD_0=42]=\"ALOAD_0\",a[a.ALOAD_1=43]=\"ALOAD_1\",a[a.ALOAD_2=44]=\"ALOAD_2\",a[a.ALOAD_3=45]=\"ALOAD_3\",a[a.ANEWARRAY=189]=\"ANEWARRAY\",a[a.ARETURN=176]=\"ARETURN\",a[a.ARRAYLENGTH=190]=\"ARRAYLENGTH\",a[a.ASTORE=58]=\"ASTORE\",a[a.ASTORE_0=75]=\"ASTORE_0\",a[a.ASTORE_1=76]=\"ASTORE_1\",a[a.ASTORE_2=77]=\"ASTORE_2\",a[a.ASTORE_3=78]=\"ASTORE_3\",a[a.ATHROW=191]=\"ATHROW\",a[a.BALOAD=51]=\"BALOAD\",a[a.BASTORE=84]=\"BASTORE\",a[a.BIPUSH=16]=\"BIPUSH\",a[a.BREAKPOINT=202]=\"BREAKPOINT\",a[a.CALOAD=52]=\"CALOAD\",a[a.CASTORE=85]=\"CASTORE\",a[a.CHECKCAST=192]=\"CHECKCAST\",a[a.D2F=144]=\"D2F\",a[a.D2I=142]=\"D2I\",a[a.D2L=143]=\"D2L\",a[a.DADD=99]=\"DADD\",a[a.DALOAD=49]=\"DALOAD\",a[a.DASTORE=82]=\"DASTORE\",a[a.DCMPG=152]=\"DCMPG\",a[a.DCMPL=151]=\"DCMPL\",a[a.DCONST_0=14]=\"DCONST_0\",a[a.DCONST_1=15]=\"DCONST_1\",a[a.DDIV=111]=\"DDIV\",a[a.DLOAD=24]=\"DLOAD\",a[a.DLOAD_0=38]=\"DLOAD_0\",a[a.DLOAD_1=39]=\"DLOAD_1\",a[a.DLOAD_2=40]=\"DLOAD_2\",a[a.DLOAD_3=41]=\"DLOAD_3\",a[a.DMUL=107]=\"DMUL\",a[a.DNEG=119]=\"DNEG\",a[a.DREM=115]=\"DREM\",a[a.DRETURN=175]=\"DRETURN\",a[a.DSTORE=57]=\"DSTORE\",a[a.DSTORE_0=71]=\"DSTORE_0\",a[a.DSTORE_1=72]=\"DSTORE_1\",a[a.DSTORE_2=73]=\"DSTORE_2\",a[a.DSTORE_3=74]=\"DSTORE_3\",a[a.DSUB=103]=\"DSUB\",a[a.DUP=89]=\"DUP\",a[a.DUP_X1=90]=\"DUP_X1\",a[a.DUP_X2=91]=\"DUP_X2\",a[a.DUP2=92]=\"DUP2\",a[a.DUP2_X1=93]=\"DUP2_X1\",a[a.DUP2_X2=94]=\"DUP2_X2\",a[a.F2D=141]=\"F2D\",a[a.F2I=139]=\"F2I\",a[a.F2L=140]=\"F2L\",a[a.FADD=98]=\"FADD\",a[a.FALOAD=48]=\"FALOAD\",a[a.FASTORE=81]=\"FASTORE\",a[a.FCMPG=150]=\"FCMPG\",a[a.FCMPL=149]=\"FCMPL\",a[a.FCONST_0=11]=\"FCONST_0\",a[a.FCONST_1=12]=\"FCONST_1\",a[a.FCONST_2=13]=\"FCONST_2\",a[a.FDIV=110]=\"FDIV\",a[a.FLOAD=23]=\"FLOAD\",a[a.FLOAD_0=34]=\"FLOAD_0\",a[a.FLOAD_1=35]=\"FLOAD_1\",a[a.FLOAD_2=36]=\"FLOAD_2\",a[a.FLOAD_3=37]=\"FLOAD_3\",a[a.FMUL=106]=\"FMUL\",a[a.FNEG=118]=\"FNEG\",a[a.FREM=114]=\"FREM\",a[a.FRETURN=174]=\"FRETURN\",a[a.FSTORE=56]=\"FSTORE\",a[a.FSTORE_0=67]=\"FSTORE_0\",a[a.FSTORE_1=68]=\"FSTORE_1\",a[a.FSTORE_2=69]=\"FSTORE_2\",a[a.FSTORE_3=70]=\"FSTORE_3\",a[a.FSUB=102]=\"FSUB\",a[a.GETFIELD=180]=\"GETFIELD\",a[a.GETSTATIC=178]=\"GETSTATIC\",a[a.GOTO=167]=\"GOTO\",a[a.GOTO_W=200]=\"GOTO_W\",a[a.I2B=145]=\"I2B\",a[a.I2C=146]=\"I2C\",a[a.I2D=135]=\"I2D\",a[a.I2F=134]=\"I2F\",a[a.I2L=133]=\"I2L\",a[a.I2S=147]=\"I2S\",a[a.IADD=96]=\"IADD\",a[a.IALOAD=46]=\"IALOAD\",a[a.IAND=126]=\"IAND\",a[a.IASTORE=79]=\"IASTORE\",a[a.ICONST_M1=2]=\"ICONST_M1\",a[a.ICONST_0=3]=\"ICONST_0\",a[a.ICONST_1=4]=\"ICONST_1\",a[a.ICONST_2=5]=\"ICONST_2\",a[a.ICONST_3=6]=\"ICONST_3\",a[a.ICONST_4=7]=\"ICONST_4\",a[a.ICONST_5=8]=\"ICONST_5\",a[a.IDIV=108]=\"IDIV\",a[a.IF_ACMPEQ=165]=\"IF_ACMPEQ\",a[a.IF_ACMPNE=166]=\"IF_ACMPNE\",a[a.IF_ICMPEQ=159]=\"IF_ICMPEQ\",a[a.IF_ICMPGE=162]=\"IF_ICMPGE\",a[a.IF_ICMPGT=163]=\"IF_ICMPGT\",a[a.IF_ICMPLE=164]=\"IF_ICMPLE\",a[a.IF_ICMPLT=161]=\"IF_ICMPLT\",a[a.IF_ICMPNE=160]=\"IF_ICMPNE\",a[a.IFEQ=153]=\"IFEQ\",a[a.IFGE=156]=\"IFGE\",a[a.IFGT=157]=\"IFGT\",a[a.IFLE=158]=\"IFLE\",a[a.IFLT=155]=\"IFLT\",a[a.IFNE=154]=\"IFNE\",a[a.IFNONNULL=199]=\"IFNONNULL\",a[a.IFNULL=198]=\"IFNULL\",a[a.IINC=132]=\"IINC\",a[a.ILOAD=21]=\"ILOAD\",a[a.ILOAD_0=26]=\"ILOAD_0\",a[a.ILOAD_1=27]=\"ILOAD_1\",a[a.ILOAD_2=28]=\"ILOAD_2\",a[a.ILOAD_3=29]=\"ILOAD_3\",a[a.IMUL=104]=\"IMUL\",a[a.INEG=116]=\"INEG\",a[a.INSTANCEOF=193]=\"INSTANCEOF\",a[a.INVOKEDYNAMIC=186]=\"INVOKEDYNAMIC\",a[a.INVOKEINTERFACE=185]=\"INVOKEINTERFACE\",a[a.INVOKESPECIAL=183]=\"INVOKESPECIAL\",a[a.INVOKESTATIC=184]=\"INVOKESTATIC\",a[a.INVOKEVIRTUAL=182]=\"INVOKEVIRTUAL\",a[a.IOR=128]=\"IOR\",a[a.IREM=112]=\"IREM\",a[a.IRETURN=172]=\"IRETURN\",a[a.ISHL=120]=\"ISHL\",a[a.ISHR=122]=\"ISHR\",a[a.ISTORE=54]=\"ISTORE\",a[a.ISTORE_0=59]=\"ISTORE_0\",a[a.ISTORE_1=60]=\"ISTORE_1\",a[a.ISTORE_2=61]=\"ISTORE_2\",a[a.ISTORE_3=62]=\"ISTORE_3\",a[a.ISUB=100]=\"ISUB\",a[a.IUSHR=124]=\"IUSHR\",a[a.IXOR=130]=\"IXOR\",a[a.JSR=168]=\"JSR\",a[a.JSR_W=201]=\"JSR_W\",a[a.L2D=138]=\"L2D\",a[a.L2F=137]=\"L2F\",a[a.L2I=136]=\"L2I\",a[a.LADD=97]=\"LADD\",a[a.LALOAD=47]=\"LALOAD\",a[a.LAND=127]=\"LAND\",a[a.LASTORE=80]=\"LASTORE\",a[a.LCMP=148]=\"LCMP\",a[a.LCONST_0=9]=\"LCONST_0\",a[a.LCONST_1=10]=\"LCONST_1\",a[a.LDC=18]=\"LDC\",a[a.LDC_W=19]=\"LDC_W\",a[a.LDC2_W=20]=\"LDC2_W\",a[a.LDIV=109]=\"LDIV\",a[a.LLOAD=22]=\"LLOAD\",a[a.LLOAD_0=30]=\"LLOAD_0\",a[a.LLOAD_1=31]=\"LLOAD_1\",a[a.LLOAD_2=32]=\"LLOAD_2\",a[a.LLOAD_3=33]=\"LLOAD_3\",a[a.LMUL=105]=\"LMUL\",a[a.LNEG=117]=\"LNEG\",a[a.LOOKUPSWITCH=171]=\"LOOKUPSWITCH\",a[a.LOR=129]=\"LOR\",a[a.LREM=113]=\"LREM\",a[a.LRETURN=173]=\"LRETURN\",a[a.LSHL=121]=\"LSHL\",a[a.LSHR=123]=\"LSHR\",a[a.LSTORE=55]=\"LSTORE\",a[a.LSTORE_0=63]=\"LSTORE_0\",a[a.LSTORE_1=64]=\"LSTORE_1\",a[a.LSTORE_2=65]=\"LSTORE_2\",a[a.LSTORE_3=66]=\"LSTORE_3\",a[a.LSUB=101]=\"LSUB\",a[a.LUSHR=125]=\"LUSHR\",a[a.LXOR=131]=\"LXOR\",a[a.MONITORENTER=194]=\"MONITORENTER\",a[a.MONITOREXIT=195]=\"MONITOREXIT\",a[a.MULTIANEWARRAY=197]=\"MULTIANEWARRAY\",a[a.NEW=187]=\"NEW\",a[a.NEWARRAY=188]=\"NEWARRAY\",a[a.NOP=0]=\"NOP\",a[a.POP=87]=\"POP\",a[a.POP2=88]=\"POP2\",a[a.PUTFIELD=181]=\"PUTFIELD\",a[a.PUTSTATIC=179]=\"PUTSTATIC\",a[a.RET=169]=\"RET\",a[a.RETURN=177]=\"RETURN\",a[a.SALOAD=53]=\"SALOAD\",a[a.SASTORE=86]=\"SASTORE\",a[a.SIPUSH=17]=\"SIPUSH\";a[a.SWAP=95]=\"SWAP\";a[a.TABLESWITCH=170]=\"TABLESWITCH\",a[a.WIDE=196]=\"WIDE\",a[a.GETSTATIC_FAST32=208]=\"GETSTATIC_FAST32\",a[a.GETSTATIC_FAST64=209]=\"GETSTATIC_FAST64\",a[a.NEW_FAST=210]=\"NEW_FAST\",a[a.ANEWARRAY_FAST=213]=\"ANEWARRAY_FAST\",a[a.CHECKCAST_FAST=214]=\"CHECKCAST_FAST\",a[a.INSTANCEOF_FAST=215]=\"INSTANCEOF_FAST\",a[a.MULTIANEWARRAY_FAST=216]=\"MULTIANEWARRAY_FAST\",a[a.PUTSTATIC_FAST32=217]=\"PUTSTATIC_FAST32\",a[a.PUTSTATIC_FAST64=218]=\"PUTSTATIC_FAST64\",a[a.GETFIELD_FAST32=219]=\"GETFIELD_FAST32\",a[a.GETFIELD_FAST64=220]=\"GETFIELD_FAST64\",a[a.PUTFIELD_FAST32=221]=\"PUTFIELD_FAST32\",a[a.PUTFIELD_FAST64=222]=\"PUTFIELD_FAST64\",a[a.INVOKENONVIRTUAL_FAST=223]=\"INVOKENONVIRTUAL_FAST\",a[a.INVOKESTATIC_FAST=240]=\"INVOKESTATIC_FAST\",a[a.INVOKEVIRTUAL_FAST=241]=\"INVOKEVIRTUAL_FAST\",a[a.INVOKEINTERFACE_FAST=242]=\"INVOKEINTERFACE_FAST\",a[a.INVOKEHANDLE=243]=\"INVOKEHANDLE\",a[a.INVOKEBASIC=244]=\"INVOKEBASIC\",a[a.LINKTOSPECIAL=245]=\"LINKTOSPECIAL\",a[a.LINKTOVIRTUAL=247]=\"LINKTOVIRTUAL\",a[a.INVOKEDYNAMIC_FAST=248]=\"INVOKEDYNAMIC_FAST\"}(exports.OpCode||(exports.OpCode={}));var OpCode=exports.OpCode;!function(a){a[a.OPCODE_ONLY=0]=\"OPCODE_ONLY\",a[a.CONSTANT_POOL_UINT8=1]=\"CONSTANT_POOL_UINT8\",a[a.CONSTANT_POOL=2]=\"CONSTANT_POOL\",a[a.CONSTANT_POOL_AND_UINT8_VALUE=3]=\"CONSTANT_POOL_AND_UINT8_VALUE\",a[a.UINT8_VALUE=4]=\"UINT8_VALUE\",a[a.UINT8_AND_INT8_VALUE=5]=\"UINT8_AND_INT8_VALUE\",a[a.INT8_VALUE=6]=\"INT8_VALUE\",a[a.INT16_VALUE=7]=\"INT16_VALUE\",a[a.INT32_VALUE=8]=\"INT32_VALUE\",a[a.ARRAY_TYPE=9]=\"ARRAY_TYPE\",a[a.WIDE=10]=\"WIDE\"}(exports.OpcodeLayoutType||(exports.OpcodeLayoutType={}));var OpcodeLayoutType=exports.OpcodeLayoutType,olt=new Array(255);!function(){for(var a=0;a<255;a++)olt[a]=OpcodeLayoutType.OPCODE_ONLY}(),assignOpcodeLayout(OpcodeLayoutType.UINT8_VALUE,[OpCode.ALOAD,OpCode.ASTORE,OpCode.DLOAD,OpCode.DSTORE,OpCode.FLOAD,OpCode.FSTORE,OpCode.ILOAD,OpCode.ISTORE,OpCode.LLOAD,OpCode.LSTORE,OpCode.RET]),assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_UINT8,[OpCode.LDC]),assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL,[OpCode.LDC_W,OpCode.LDC2_W,OpCode.ANEWARRAY,OpCode.CHECKCAST,OpCode.GETFIELD,OpCode.GETSTATIC,OpCode.INSTANCEOF,OpCode.INVOKEDYNAMIC,OpCode.INVOKESPECIAL,OpCode.INVOKESTATIC,OpCode.INVOKEVIRTUAL,OpCode.NEW,OpCode.PUTFIELD,OpCode.PUTSTATIC,OpCode.MULTIANEWARRAY_FAST,OpCode.INVOKENONVIRTUAL_FAST,OpCode.INVOKESTATIC_FAST,OpCode.CHECKCAST_FAST,OpCode.NEW_FAST,OpCode.ANEWARRAY_FAST,OpCode.INSTANCEOF_FAST,OpCode.GETSTATIC_FAST32,OpCode.GETSTATIC_FAST64,OpCode.PUTSTATIC_FAST32,OpCode.PUTSTATIC_FAST64,OpCode.PUTFIELD_FAST32,OpCode.PUTFIELD_FAST64,OpCode.GETFIELD_FAST32,OpCode.GETFIELD_FAST64,OpCode.INVOKEVIRTUAL_FAST]),assignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE,[OpCode.INVOKEINTERFACE,OpCode.INVOKEINTERFACE_FAST,OpCode.MULTIANEWARRAY]),assignOpcodeLayout(OpcodeLayoutType.INT8_VALUE,[OpCode.BIPUSH]),assignOpcodeLayout(OpcodeLayoutType.INT16_VALUE,[OpCode.SIPUSH,OpCode.GOTO,OpCode.IFGT,OpCode.IFEQ,OpCode.IFGE,OpCode.IFLE,OpCode.IFLT,OpCode.IFNE,OpCode.IFNULL,OpCode.IFNONNULL,OpCode.IF_ICMPLE,OpCode.IF_ACMPEQ,OpCode.IF_ACMPNE,OpCode.IF_ICMPEQ,OpCode.IF_ICMPGE,OpCode.IF_ICMPGT,OpCode.IF_ICMPLT,OpCode.IF_ICMPNE,OpCode.JSR]),assignOpcodeLayout(OpcodeLayoutType.INT32_VALUE,[OpCode.GOTO_W,OpCode.JSR_W]),assignOpcodeLayout(OpcodeLayoutType.UINT8_AND_INT8_VALUE,[OpCode.IINC]),assignOpcodeLayout(OpcodeLayoutType.ARRAY_TYPE,[OpCode.NEWARRAY]),exports.OpcodeLayouts=olt;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";var SafeMap=function(){function a(){this.cache=Object.create(null)}return a.prototype.fixKey=function(a){return\";\"+a},a.prototype.get=function(a){if(a=this.fixKey(a),void 0!==this.cache[a])return this.cache[a]},a.prototype.has=function(a){return void 0!==this.get(a)},a.prototype.set=function(a,b){this.cache[this.fixKey(a)]=b},a}();module.exports=SafeMap;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function getTrappedMethod(a,b){return a=util.descriptor2typestr(a),trapped_methods.hasOwnProperty(a)&&trapped_methods[a].hasOwnProperty(b)?trapped_methods[a][b]:null}function makeOnError(a){return a.length>0?\"f.opStack.pushAll(\"+a.join(\",\")+\");\":\"\"}function dumpStats(){for(var a=new Array(256),b=0;b<256;b++)a[b]=b;a.sort(function(a,b){return statTraceCloser[b]-statTraceCloser[a]});var c=a.slice(0,24);console.log(\"Opcodes that closed a trace (number of times encountered):\");for(var b=0;b<c.length;b++){var d=c[b];statTraceCloser[d]>0&&console.log(enums.OpCode[d],statTraceCloser[d])}}var __extends=this&&this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)},util=__webpack_require__(7),attributes=__webpack_require__(12),threading=__webpack_require__(14),assert=__webpack_require__(13),enums=__webpack_require__(9),StringOutputStream=__webpack_require__(17),global=__webpack_require__(18),jit_1=__webpack_require__(19),trapped_methods={\"java/lang/ref/Reference\":{\"<clinit>()V\":function(a){}},\"java/lang/System\":{\"loadLibrary(Ljava/lang/String;)V\":function(a,b){var c=b.toString();switch(c){case\"zip\":case\"net\":case\"nio\":case\"awt\":case\"fontmanager\":case\"management\":return;default:a.throwNewException(\"Ljava/lang/UnsatisfiedLinkError;\",\"no \"+c+\" in java.library.path\")}}},\"java/lang/Terminator\":{\"setup()V\":function(a){}},\"java/nio/charset/Charset$3\":{\"run()Ljava/lang/Object;\":function(a,b){return null}},\"sun/nio/fs/DefaultFileSystemProvider\":{\"create()Ljava/nio/file/spi/FileSystemProvider;\":function(a){a.setStatus(enums.ThreadStatus.ASYNC_WAITING);var b=a.getBsCl().getInitializedClass(a,\"Lsun/nio/fs/DefaultFileSystemProvider;\"),c=b.getConstructor(a);c[\"createProvider(Ljava/lang/String;)Ljava/nio/file/spi/FileSystemProvider;\"](a,[a.getJVM().internString(\"sun.nio.fs.LinuxFileSystemProvider\")],util.forwardResult(a))}}},AbstractMethodField=function(){function a(a,b,c,d){this.cls=a,this.slot=c,this.accessFlags=new util.Flags(d.getUint16()),this.name=b.get(d.getUint16()).value,this.rawDescriptor=b.get(d.getUint16()).value,this.attrs=attributes.makeAttributes(d,b)}return a.prototype.getAttribute=function(a){for(var b=0;b<this.attrs.length;b++){var c=this.attrs[b];if(c.getName()===a)return c}return null},a.prototype.getAttributes=function(a){return this.attrs.filter(function(b){return b.getName()===a})},a.prototype.getAnnotationType=function(a,b){var c=this.getAttribute(b);if(null===c)return null;var d,e=a.getBsCl().getInitializedClass(a,\"[B\").getConstructor(a),f=new e(a,0),g=c.rawBytes.length,h=new Array(g);for(d=0;d<g;d++)h[d]=c.rawBytes.readInt8(d);return f.array=h,f},a.prototype.parseDescriptor=function(a){throw new Error(\"Unimplemented error.\")},a}();exports.AbstractMethodField=AbstractMethodField;var Field=function(a){function b(b,c,d,e){a.call(this,b,c,d,e),this.fullName=util.descriptor2typestr(b.getInternalName())+\"/\"+this.name}return __extends(b,a),b.prototype.reflector=function(a,b){var c=this,d=this.getAttribute(\"Signature\"),e=a.getJVM(),f=a.getBsCl(),g=function(b){var g=f.getInitializedClass(a,\"Ljava/lang/reflect/Field;\"),h=new(g.getConstructor(a))(a);return h[\"java/lang/reflect/Field/clazz\"]=c.cls.getClassObject(a),h[\"java/lang/reflect/Field/name\"]=e.internString(c.name),h[\"java/lang/reflect/Field/type\"]=b,h[\"java/lang/reflect/Field/modifiers\"]=c.accessFlags.getRawByte(),h[\"java/lang/reflect/Field/slot\"]=c.slot,h[\"java/lang/reflect/Field/signature\"]=null!==d?util.initString(f,d.sig):null,h[\"java/lang/reflect/Field/annotations\"]=c.getAnnotationType(a,\"RuntimeVisibleAnnotations\"),h};this.cls.getLoader().resolveClass(a,this.rawDescriptor,function(c){b(null!=c?g(c.getClassObject(a)):null)})},b.prototype.getDefaultFieldValue=function(){var a=this.rawDescriptor;if(\"J\"===a)return\"gLongZero\";var b=a[0];return\"[\"===b||\"L\"===b?\"null\":\"0\"},b.prototype.outputJavaScriptField=function(a,b){this.accessFlags.isStatic()?b.write(a+'[\"'+util.reescapeJVMName(this.fullName)+'\"] = cls._getInitialStaticFieldValue(thread, \"'+util.reescapeJVMName(this.name)+'\");\\n'):b.write('this[\"'+util.reescapeJVMName(this.fullName)+'\"] = '+this.getDefaultFieldValue()+\";\\n\")},b}(AbstractMethodField);exports.Field=Field;var opcodeSize=function(){var a=[],b=enums.OpcodeLayoutType;return a[b.OPCODE_ONLY]=1,a[b.CONSTANT_POOL_UINT8]=2,a[b.CONSTANT_POOL]=3,a[b.CONSTANT_POOL_AND_UINT8_VALUE]=4,a[b.UINT8_VALUE]=2,a[b.UINT8_AND_INT8_VALUE]=3,a[b.INT8_VALUE]=2,a[b.INT16_VALUE]=3,a[b.INT32_VALUE]=5,a[b.ARRAY_TYPE]=2,a[b.WIDE]=1,a}(),TraceInfo=function(){function a(a,b){this.pc=a,this.jitInfo=b,this.pops=[],this.pushes=[],this.prefixEmit=\"\"}return a}(),Trace=function(){function a(a,b,c){this.startPC=a,this.code=b,this.method=c,this.infos=[],this.endPc=-1}return a.prototype.emitEndPC=function(a){this.endPc=a},a.prototype.addOp=function(a,b){this.infos.push(new TraceInfo(a,b))},a.prototype.close=function(a){if(this.infos.length>1){for(var b=[],c=0,d=this.endPc>-1?\"f.pc=\"+this.endPc+\";\":\"\",e=0;e<this.infos.length;e++){for(var f=this.infos[e],g=f.jitInfo,h=f.pops,i=g.pops<0?Math.min(-g.pops,b.length):g.pops,j=0;j<i;j++)if(b.length>0)h.push(b.pop());else{var k=\"s\"+c++;f.prefixEmit+=\"var \"+k+\" = f.opStack.pop();\",h.push(k)}f.onErrorPushes=b.slice();for(var l=f.pushes,j=0;j<g.pushes;j++){var k=\"s\"+c++;b.push(k),l.push(k)}}1===b.length?d+=\"f.opStack.push(\"+b[0]+\");\":b.length>1&&(d+=\"f.opStack.pushAll(\"+b.join(\",\")+\");\");for(var e=this.infos.length-1;e>=0;e--){var f=this.infos[e],g=f.jitInfo;d=f.prefixEmit+g.emit(f.pops,f.pushes,\"\"+e,d,this.code,f.pc,f.onErrorPushes,this.method)}return new Function(\"f\",\"t\",\"u\",d)}return null},a}(),Method=function(a){function b(b,c,d,e){a.call(this,b,c,d,e),this.numBBEntries=0,this.compiledFunctions=[],this.failedCompile=[];var f,g,h=util.getTypes(this.rawDescriptor);for(this.signature=this.name+this.rawDescriptor,this.fullSignature=util.descriptor2typestr(this.cls.getInternalName())+\"/\"+this.signature,this.returnType=h.pop(),this.parameterTypes=h,this.parameterWords=h.length,f=0;f<this.parameterTypes.length;f++)g=this.parameterTypes[f],\"D\"!==g&&\"J\"!==g||this.parameterWords++;var i=this.cls.getInternalName();if(null!==getTrappedMethod(i,this.signature))this.code=getTrappedMethod(i,this.signature),this.accessFlags.setNative(!0);else if(this.accessFlags.isNative())if(this.signature.indexOf(\"registerNatives()V\",0)<0&&this.signature.indexOf(\"initIDs()V\",0)<0){var j=this;this.code=function(a){var b=a.getJVM(),c=b.getNative(i,j.signature);return null!=c?(j.code=c,c.apply(j,arguments)):void a.throwNewException(\"Ljava/lang/UnsatisfiedLinkError;\",\"Native method '\"+j.getFullSignature()+\"' not implemented.\\nPlease fix or file a bug at https://github.com/plasma-umass/doppio/issues\")}}else this.code=function(){};else if(!this.accessFlags.isAbstract()){this.code=this.getAttribute(\"Code\");var k=this.code.code.length;this.numBBEntries=k>3?200:1e3*k}}return __extends(b,a),b.prototype.incrBBEntries=function(){this.numBBEntries--},b.prototype.isDefault=function(){return this.accessFlags.isPublic()&&!this.accessFlags.isAbstract()&&!this.accessFlags.isStatic()&&this.cls.accessFlags.isInterface()},b.prototype.getFullSignature=function(){return this.cls.getExternalName()+\".\"+this.name+this.rawDescriptor},b.prototype.isHidden=function(){var a=this.getAttribute(\"RuntimeVisibleAnnotations\");return null!==a&&a.isHidden},b.prototype.isCallerSensitive=function(){var a=this.getAttribute(\"RuntimeVisibleAnnotations\");return null!==a&&a.isCallerSensitive},b.prototype.getParamWordSize=function(){return this.parameterWords},b.prototype.getCodeAttribute=function(){return this.code},b.prototype.getOp=function(a,b,c){if(this.numBBEntries<=0&&!this.failedCompile[a]){var d=this.compiledFunctions[a];if(d)return d;var e=this.jitCompileFrom(a,c);if(e)return e;this.failedCompile[a]=!0}return b.readUInt8(a)},b.prototype.makeInvokeStaticJitInfo=function(a,b){var c=a.readUInt16BE(b+1),d=this.cls.constantPool.get(c),e=d.paramWordSize;d.jsConstructor[d.fullSignature];return{hasBranch:!0,pops:-e,pushes:0,emit:function(a,d,f,g){var h=e>a.length?\"f.opStack.sliceAndDropFromTop(\"+(e-a.length)+\");\":\"[\"+a.reduce(function(a,b){return b+\",\"+a},\"\")+\"];\",i=\"var args\"+f+\"=\"+h;return e>a.length&&a.length>0&&(i+=\"args\"+f+\".push(\"+a.slice().reverse().join(\",\")+\");\"),i+(\"\\nvar methodReference\"+f+\"=f.method.cls.constantPool.get(\"+c+\");\\nf.pc=\"+b+\";\\nmethodReference\"+f+\".jsConstructor[methodReference\"+f+\".fullSignature](t,args\"+f+\");\\nf.returnToThreadLoop=true;\\n\"+g)}}},b.prototype.makeInvokeVirtualJitInfo=function(a,b){var c=a.readUInt16BE(b+1),d=this.cls.constantPool.get(c),e=d.paramWordSize;return{hasBranch:!0,pops:-(e+1),pushes:0,emit:function(a,b,c,f,g,h,i){var j=makeOnError(i),k=e>a.length?\"f.opStack.sliceAndDropFromTop(\"+(e-a.length)+\");\":\"[\"+a.slice(0,e).reduce(function(a,b){return b+\",\"+a},\"\")+\"];\",l=\"var args\"+c+\"=\"+k;return e>a.length&&a.length>0&&(l+=\"args\"+c+\".push(\"+a.slice().reverse().join(\",\")+\");\"),l+(\"var obj\"+c+\"=\"+(e+1===a.length?a[e]:\"f.opStack.pop()\")+\";f.pc=\"+h+\";\\nif(!u.isNull(t,f,obj\"+c+\")){obj\"+c+\"['\"+d.signature+\"'](t,args\"+c+\");f.returnToThreadLoop=true;\"+f+\"}else{\"+j+\"}\")}}},b.prototype.makeInvokeNonVirtualJitInfo=function(a,b){var c=a.readUInt16BE(b+1),d=this.cls.constantPool.get(c),e=d.paramWordSize;return{hasBranch:!0,pops:-(e+1),pushes:0,emit:function(a,b,c,f,g,h,i){var j=makeOnError(i),k=e>a.length?\"f.opStack.sliceAndDropFromTop(\"+(e-a.length)+\");\":\"[\"+a.slice(0,e).reduce(function(a,b){return b+\",\"+a},\"\")+\"];\",l=\"var args\"+c+\"=\"+k;return e>a.length&&a.length>0&&(l+=\"args\"+c+\".push(\"+a.slice().reverse().join(\",\")+\");\"),l+(\"var obj\"+c+\"=\"+(e+1===a.length?a[e]:\"f.opStack.pop()\")+\";f.pc=\"+h+\";\\nif(!u.isNull(t,f,obj\"+c+\")){obj\"+c+\"['\"+d.fullSignature+\"'](t, args\"+c+\");f.returnToThreadLoop=true;\"+f+\"}else{\"+j+\"}\")}}},b.prototype.jitCompileFrom=function(a,b){function c(){if(null!==e){var a=e.close(b);a&&(f.compiledFunctions[e.startPC]=a),e=null}g=!0}for(var d=this.getCodeAttribute().getCode(),e=null,f=this,g=!1,h=a;h<d.length&&!g;){var i=d.readUInt8(h),j=jit_1.opJitInfo[i];if(j)null===e&&(e=new Trace(h,d,f)),e.addOp(h,j),j.hasBranch&&(this.failedCompile[h]=!0,c());else if(i===enums.OpCode.INVOKESTATIC_FAST&&null!==e){var k=this.makeInvokeStaticJitInfo(d,h);e.addOp(h,k),this.failedCompile[h]=!0,c()}else if(i!==enums.OpCode.INVOKEVIRTUAL_FAST&&i!==enums.OpCode.INVOKEINTERFACE_FAST||null===e)if(i===enums.OpCode.INVOKENONVIRTUAL_FAST&&null!==e){var k=this.makeInvokeNonVirtualJitInfo(d,h);e.addOp(h,k),this.failedCompile[h]=!0,c()}else this.failedCompile[h]=!0,e&&e.emitEndPC(h),c();else{var k=this.makeInvokeVirtualJitInfo(d,h);e.addOp(h,k),this.failedCompile[h]=!0,c()}h+=opcodeSize[enums.OpcodeLayouts[i]]}return f.compiledFunctions[a]},b.prototype.getNativeFunction=function(){return this.code},b.prototype._resolveReferencedClasses=function(a,b){var c=this.parameterTypes.concat(this.returnType),d=this.code,e=this.getAttribute(\"Exceptions\");!this.accessFlags.isNative()&&!this.accessFlags.isAbstract()&&d.exceptionHandlers.length>0&&(c.push(\"Ljava/lang/Throwable;\"),c=c.concat(d.exceptionHandlers.filter(function(a){return\"<any>\"!==a.catchType}).map(function(a){return a.catchType}))),null!==e&&(c=c.concat(e.exceptions)),this.cls.getLoader().resolveClasses(a,c,function(c){a.getBsCl().resolveClasses(a,[\"Ljava/lang/reflect/Method;\",\"Ljava/lang/reflect/Constructor;\"],function(a){null===c||null===a?b(null):(c[\"Ljava/lang/reflect/Method;\"]=a[\"Ljava/lang/reflect/Method;\"],c[\"Ljava/lang/reflect/Constructor;\"]=a[\"Ljava/lang/reflect/Constructor;\"],b(c))})})},b.prototype.reflector=function(a,b){var c=this,d=a.getBsCl(),e=d.getInitializedClass(a,\"[Ljava/lang/Class;\").getConstructor(a),f=a.getJVM(),g=this.getAttribute(\"Signature\"),h=this.getAttribute(\"Exceptions\");this._resolveReferencedClasses(a,function(d){if(null===d)return b(null);var i=c.cls.getClassObject(a),j=f.internString(c.name),k=new e(a,0),l=d[c.returnType].getClassObject(a),m=new e(a,0),n=c.accessFlags.getRawByte(),o=null!==g?f.internString(g.sig):null;if(k.array=c.parameterTypes.map(function(b){return d[b].getClassObject(a)}),null!==h&&(m.array=h.exceptions.map(function(b){return d[b].getClassObject(a)})),\"<init>\"===c.name){var p=d[\"Ljava/lang/reflect/Constructor;\"].getConstructor(a),q=new p(a);q[\"java/lang/reflect/Constructor/clazz\"]=i,q[\"java/lang/reflect/Constructor/parameterTypes\"]=k,q[\"java/lang/reflect/Constructor/exceptionTypes\"]=m,q[\"java/lang/reflect/Constructor/modifiers\"]=n,q[\"java/lang/reflect/Constructor/slot\"]=c.slot,q[\"java/lang/reflect/Constructor/signature\"]=o,q[\"java/lang/reflect/Constructor/annotations\"]=c.getAnnotationType(a,\"RuntimeVisibleAnnotations\"),q[\"java/lang/reflect/Constructor/parameterAnnotations\"]=c.getAnnotationType(a,\"RuntimeVisibleParameterAnnotations\"),b(q)}else{var r=d[\"Ljava/lang/reflect/Method;\"].getConstructor(a),s=new r(a);s[\"java/lang/reflect/Method/clazz\"]=i,s[\"java/lang/reflect/Method/name\"]=j,s[\"java/lang/reflect/Method/parameterTypes\"]=k,s[\"java/lang/reflect/Method/returnType\"]=l,s[\"java/lang/reflect/Method/exceptionTypes\"]=m,s[\"java/lang/reflect/Method/modifiers\"]=n,s[\"java/lang/reflect/Method/slot\"]=c.slot,s[\"java/lang/reflect/Method/signature\"]=o,s[\"java/lang/reflect/Method/annotations\"]=c.getAnnotationType(a,\"RuntimeVisibleAnnotations\"),s[\"java/lang/reflect/Method/annotationDefault\"]=c.getAnnotationType(a,\"AnnotationDefault\"),s[\"java/lang/reflect/Method/parameterAnnotations\"]=c.getAnnotationType(a,\"RuntimeVisibleParameterAnnotations\"),b(s)}})},b.prototype.convertArgs=function(a,b){if(this.isSignaturePolymorphic())return b.unshift(a),b;var c,d=[a],e=0;for(this.accessFlags.isStatic()||(d.push(b[0]),e=1),c=0;c<this.parameterTypes.length;c++){var f=this.parameterTypes[c];d.push(b[e]),e+=\"J\"===f||\"D\"===f?2:1}return d},b.prototype.methodLock=function(a,b){return this.accessFlags.isStatic()?this.cls.getClassObject(a).getMonitor():b.locals[0].getMonitor()},b.prototype.isSignaturePolymorphic=function(){return\"Ljava/lang/invoke/MethodHandle;\"===this.cls.getInternalName()&&this.accessFlags.isNative()&&this.accessFlags.isVarArgs()&&\"([Ljava/lang/Object;)Ljava/lang/Object;\"===this.rawDescriptor},b.prototype.getVMTargetBridgeMethod=function(a,b){var c=new StringOutputStream,d=!(b===enums.MethodHandleReferenceKind.INVOKESTATIC||b===enums.MethodHandleReferenceKind.INVOKESPECIAL);this.accessFlags.isStatic()&&c.write(\"var jsCons = cls.getConstructor(thread);\\n\"),c.write(\"function bridgeMethod(thread, descriptor, args, cb) {\\n\"),this.accessFlags.isStatic()?c.write('  jsCons[\"'+util.reescapeJVMName(this.fullSignature)+'\"](thread, '):(c.write(\"  var obj = args.shift();\\n\"),c.write(\"  if (obj === null) { return thread.throwNewException('Ljava/lang/NullPointerException;', ''); }\\n\"),c.write('  obj[\"'+util.reescapeJVMName(d?this.signature:this.fullSignature)+'\"](thread, ')),c.write(\"args\"),c.write(\", cb);\\n  }\\n  return bridgeMethod;\");var e=c.flush();return new Function(\"thread\",\"cls\",\"util\",e)(a,this.cls,util)},b.prototype.outputJavaScriptFunction=function(a,b,c){void 0===c&&(c=!1);var d;if(this.accessFlags.isStatic()?b.write(a+'[\"'+util.reescapeJVMName(this.fullSignature)+'\"] = '+a+'[\"'+util.reescapeJVMName(this.signature)+'\"] = '):(c||b.write(a+'.prototype[\"'+util.reescapeJVMName(this.signature)+'\"] = '),b.write(a+'.prototype[\"'+util.reescapeJVMName(this.fullSignature)+'\"] = ')),b.write(\"(function(method) {\\n  return function(thread, args, cb) {\\n    if (typeof cb === 'function') {\\n      thread.stack.push(new InternalStackFrame(cb));\\n    }\\n    thread.stack.push(new \"+(this.accessFlags.isNative()?\"NativeStackFrame\":\"BytecodeStackFrame\")+\"(method, \"),this.accessFlags.isStatic())this.parameterWords>0?b.write(\"args\"):b.write(\"[]\");else{for(b.write(\"[this\"),d=0;d<this.parameterWords;d++)b.write(\", args[\"+d+\"]\");b.write(\"]\")}b.write(\"));\\n    thread.setStatus(\"+enums.ThreadStatus.RUNNABLE+');\\n  };\\n})(cls.getSpecificMethod(\"'+util.reescapeJVMName(this.cls.getInternalName())+'\", \"'+util.reescapeJVMName(this.signature)+'\"));\\n')},b}(AbstractMethodField);exports.Method=Method;var statTraceCloser=new Array(256),i;exports.dumpStats=dumpStats;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function makeAttributes(a,b){for(var c={Code:Code,LineNumberTable:LineNumberTable,SourceFile:SourceFile,StackMapTable:StackMapTable,LocalVariableTable:LocalVariableTable,LocalVariableTypeTable:LocalVariableTypeTable,ConstantValue:ConstantValue,Exceptions:Exceptions,InnerClasses:InnerClasses,Synthetic:Synthetic,Deprecated:Deprecated,Signature:Signature,RuntimeVisibleAnnotations:RuntimeVisibleAnnotations,AnnotationDefault:AnnotationDefault,EnclosingMethod:EnclosingMethod,BootstrapMethods:BootstrapMethods,RuntimeVisibleParameterAnnotations:RuntimeVisibleParameterAnnotations},d=a.getUint16(),e=[],f=0;f<d;f++){var g=b.get(a.getUint16()).value,h=a.getUint32();if(null!=c[g]){var i=a.size(),j=c[g].parse(a,b,h,g),k=a.size();i-k!==h&&a.skip(h-i+k),e.push(j)}else a.skip(h)}return e}var util=__webpack_require__(7),enums=__webpack_require__(9),assert=__webpack_require__(13),ExceptionHandler=function(){function a(a,b,c,d){this.startPC=a,this.endPC=b,this.handlerPC=c,this.catchType=d}return a.prototype.getName=function(){return\"ExceptionHandler\"},a.parse=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=a.getUint16(),f=a.getUint16(),g=0===f?\"<any>\":b.get(f).name;return new this(c,d,e,g)},a}();exports.ExceptionHandler=ExceptionHandler;var Code=function(){function a(a,b,c,d,e){this.maxStack=a,this.maxLocals=b,this.exceptionHandlers=c,this.attrs=d,this.code=e}return a.prototype.getName=function(){return\"Code\"},a.prototype.getMaxStack=function(){return this.maxStack},a.parse=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=a.getUint32();if(0===e)throw\"Error parsing code: Code length is zero\";for(var f=a.slice(e).getBuffer(),g=a.getUint16(),h=[],i=0;i<g;i++)h.push(ExceptionHandler.parse(a,b));var j=makeAttributes(a,b);return new this(c,d,h,j,f)},a.prototype.getCode=function(){return this.code},a.prototype.getAttribute=function(a){for(var b=0;b<this.attrs.length;b++){var c=this.attrs[b];if(c.getName()===a)return c}return null},a}();exports.Code=Code;var LineNumberTable=function(){function a(a){this.entries=a}return a.prototype.getName=function(){return\"LineNumberTable\"},a.prototype.getLineNumber=function(a){var b,c=-1;for(b=0;b<this.entries.length;b++){var d=this.entries[b];if(!(d.startPC<=a))break;c=d.lineNumber}return c},a.parse=function(a,b){for(var c=[],d=a.getUint16(),e=0;e<d;e++){var f=a.getUint16(),g=a.getUint16();c.push({startPC:f,lineNumber:g})}return new this(c)},a}();exports.LineNumberTable=LineNumberTable;var SourceFile=function(){function a(a){this.filename=a}return a.prototype.getName=function(){return\"SourceFile\"},a.parse=function(a,b){return new this(b.get(a.getUint16()).value)},a}();exports.SourceFile=SourceFile;var StackMapTable=function(){function a(a){this.entries=a}return a.prototype.getName=function(){return\"StackMapTable\"},a.parse=function(a,b){for(var c=a.getUint16(),d=[],e=0;e<c;e++)d.push(this.parseEntry(a,b));return new this(d)},a.parseEntry=function(a,b){var c,d,e,f=a.getUint8();if(f<64)return{type:enums.StackMapTableEntryType.SAME_FRAME,offsetDelta:f};if(f<128)return{type:enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME,offsetDelta:f-64,stack:[this.parseVerificationTypeInfo(a,b)]};if(f<247);else{if(247===f)return{type:enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED,offsetDelta:a.getUint16(),stack:[this.parseVerificationTypeInfo(a,b)]};if(f<251)return{type:enums.StackMapTableEntryType.CHOP_FRAME,offsetDelta:a.getUint16(),k:251-f};if(251===f)return{type:enums.StackMapTableEntryType.SAME_FRAME_EXTENDED,offsetDelta:a.getUint16()};if(f<255){for(d=a.getUint16(),c=[],e=0;e<f-251;e++)c.push(this.parseVerificationTypeInfo(a,b));return{type:enums.StackMapTableEntryType.APPEND_FRAME,offsetDelta:d,locals:c}}if(255===f){d=a.getUint16();var g=a.getUint16();for(c=[],e=0;e<g;e++)c.push(this.parseVerificationTypeInfo(a,b));var h=a.getUint16(),i=[];for(e=0;e<h;e++)i.push(this.parseVerificationTypeInfo(a,b));return{type:enums.StackMapTableEntryType.FULL_FRAME,offsetDelta:d,numLocals:g,locals:c,numStackItems:h,stack:i}}}},a.parseVerificationTypeInfo=function(a,b){var c=a.getUint8();if(7===c){var d=b.get(a.getUint16()).name;return\"class \"+(/\\w/.test(d[0])?util.descriptor2typestr(d):'\"'+d+'\"')}if(8===c)return\"uninitialized \"+a.getUint16();var e=[\"bogus\",\"int\",\"float\",\"double\",\"long\",\"null\",\"this\",\"object\",\"uninitialized\"];return e[c]},a}();exports.StackMapTable=StackMapTable;var LocalVariableTable=function(){function a(a){this.entries=a}return a.prototype.getName=function(){return\"LocalVariableTable\"},a.parse=function(a,b){for(var c=a.getUint16(),d=[],e=0;e<c;e++)d.push(this.parseEntries(a,b));return new this(d)},a.parseEntries=function(a,b){return{startPC:a.getUint16(),length:a.getUint16(),name:b.get(a.getUint16()).value,descriptor:b.get(a.getUint16()).value,ref:a.getUint16()}},a}();exports.LocalVariableTable=LocalVariableTable;var LocalVariableTypeTable=function(){function a(a){this.entries=a}return a.prototype.getName=function(){return\"LocalVariableTypeTable\"},a.parse=function(a,b){var c,d=a.getUint16(),e=[];for(c=0;c<d;c++)e.push(this.parseTableEntry(a,b));return new this(e)},a.parseTableEntry=function(a,b){return{startPC:a.getUint16(),length:a.getUint16(),name:b.get(a.getUint16()).value,signature:b.get(a.getUint16()).value,index:a.getUint16()}},a}();exports.LocalVariableTypeTable=LocalVariableTypeTable;var Exceptions=function(){function a(a){this.exceptions=a}return a.prototype.getName=function(){return\"Exceptions\"},a.parse=function(a,b){for(var c=a.getUint16(),d=[],e=0;e<c;e++)d.push(a.getUint16());return new this(d.map(function(a){return b.get(a).name}))},a}();exports.Exceptions=Exceptions;var InnerClasses=function(){function a(a){this.classes=a}return a.prototype.getName=function(){return\"InnerClasses\"},a.parse=function(a,b){for(var c=a.getUint16(),d=[],e=0;e<c;e++)d.push(this.parseClass(a,b));return new this(d)},a.parseClass=function(a,b){return{innerInfoIndex:a.getUint16(),outerInfoIndex:a.getUint16(),innerNameIndex:a.getUint16(),innerAccessFlags:a.getUint16()}},a}();exports.InnerClasses=InnerClasses;var ConstantValue=function(){function a(a){this.value=a}return a.prototype.getName=function(){return\"ConstantValue\"},a.parse=function(a,b){var c=a.getUint16();return new this(b.get(c))},a}();exports.ConstantValue=ConstantValue;var Synthetic=function(){function a(){}return a.prototype.getName=function(){return\"Synthetic\"},a.parse=function(a,b){return new this},a}();exports.Synthetic=Synthetic;var Deprecated=function(){function a(){}return a.prototype.getName=function(){return\"Deprecated\"},a.parse=function(a,b){return new this},a}();exports.Deprecated=Deprecated;var Signature=function(){function a(a){this.sig=a}return a.prototype.getName=function(){return\"Signature\"},a.parse=function(a,b){return new this(b.get(a.getUint16()).value)},a}();exports.Signature=Signature;var RuntimeVisibleAnnotations=function(){function a(a,b,c,d){this.rawBytes=a,this.isHidden=b,this.isCallerSensitive=c,this.isCompiled=d}return a.prototype.getName=function(){return\"RuntimeVisibleAnnotations\"},a.parse=function(a,b,c){function d(){a.skip(2);var b,c=a.getUint16();for(b=0;b<c;b++)a.skip(2),e()}function e(){var b=String.fromCharCode(a.getUint8());switch(b){case\"e\":a.skip(2);case\"Z\":case\"B\":case\"C\":case\"S\":case\"I\":case\"F\":case\"J\":case\"D\":case\"s\":case\"c\":a.skip(2);break;case\"@\":d();break;case\"[\":var c,f=a.getUint16();for(c=0;c<f;c++)e()}}var f=a.read(c),g=!1,h=!1,i=!1;a.seek(a.pos()-f.length);var j,k=a.getUint16();for(j=0;j<k;j++){var l=b.get(a.getUint16());switch(a.seek(a.pos()-2),d(),l.value){case\"Ljava/lang/invoke/LambdaForm$Hidden;\":g=!0;break;case\"Lsig/sun/reflect/CallerSensitive;\":i=!0;break;case\"Lsig/java/lang/invoke/LambdaForm$Compiled\":h=!0}}return new this(f,g,i,h)},a}();exports.RuntimeVisibleAnnotations=RuntimeVisibleAnnotations;var AnnotationDefault=function(){function a(a){this.rawBytes=a}return a.prototype.getName=function(){return\"AnnotationDefault\"},a.parse=function(a,b,c){return new this(a.read(c))},a}();exports.AnnotationDefault=AnnotationDefault;var EnclosingMethod=function(){function a(a,b){this.encClass=a,this.encMethod=b}return a.prototype.getName=function(){return\"EnclosingMethod\"},a.parse=function(a,b){var c=b.get(a.getUint16()),d=a.getUint16(),e=null;return d>0&&(e=b.get(d)),new this(c,e)},a}();exports.EnclosingMethod=EnclosingMethod;var BootstrapMethods=function(){function a(a){this.bootstrapMethods=a}return a.prototype.getName=function(){return\"BootstrapMethods\"},a.parse=function(a,b){for(var c=a.getUint16(),d=[],e=0;e<c;e++){for(var f=b.get(a.getUint16()),g=a.getUint16(),h=[],i=0;i<g;i++)h.push(b.get(a.getUint16()));d.push([f,h])}return new this(d)},a}();exports.BootstrapMethods=BootstrapMethods;var RuntimeVisibleParameterAnnotations=function(){function a(a){this.rawBytes=a}return a.prototype.getName=function(){return\"RuntimeVisibleParameterAnnotations\"},a.parse=function(a,b,c){return new this(a.read(c))},a}();exports.RuntimeVisibleParameterAnnotations=RuntimeVisibleParameterAnnotations,exports.makeAttributes=makeAttributes;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";function assert(a,b,c){if(!a)throw new Error(\"Assertion failed: \"+b+\"\\n\"+(c?c.getPrintableStackTrace():\"\"))}module.exports=assert;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function validateThreadTransition(a,b){var c=exports.validTransitions.hasOwnProperty(\"\"+a)&&exports.validTransitions[a].hasOwnProperty(\"\"+b);return c}function validateReturnValue(a,b,c,d,e,f,g){if(\"java/lang/invoke/MethodHandle/invokeBasic([Ljava/lang/Object;)Ljava/lang/Object;\"===b.fullSignature)return!0;var h;if(util.is_primitive_type(c))switch(c){case\"Z\":break;case\"B\":break;case\"C\":break;case\"S\":break;case\"I\":break;case\"J\":break;case\"F\":break;case\"D\":break;case\"V\":}else util.is_array_type(c)?null!=f&&(h=assertClassInitializedOrResolved(a,e,c,!0)):null!=f&&(h=assertClassInitializedOrResolved(a,e,c,!1),h.accessFlags.isInterface()||assertClassInitializedOrResolved(a,e,c,!0));return!0}function assertClassInitializedOrResolved(a,b,c,d){for(var e=null;null===e;)e=d?b.getInitializedClass(a,c):b.getResolvedClass(c),null!==b.getLoaderObject()&&(b=null===b.getLoaderObject()[\"java/lang/ClassLoader/parent\"]?a.getBsCl():b.getLoaderObject()[\"java/lang/ClassLoader/parent\"].$loader);return e}function printConstantPoolItem(a){switch(a.getType()){case enums.ConstantPoolItemType.METHODREF:var b=a;return util.ext_classname(b.classInfo.name)+\".\"+b.signature;case enums.ConstantPoolItemType.INTERFACE_METHODREF:var c=a;return util.ext_classname(c.classInfo.name)+\".\"+c.signature;case enums.ConstantPoolItemType.FIELDREF:var d=a;return util.ext_classname(d.classInfo.name)+\".\"+d.nameAndTypeInfo.name+\":\"+util.ext_classname(d.nameAndTypeInfo.descriptor);case enums.ConstantPoolItemType.NAME_AND_TYPE:var e=a;return e.name+\":\"+e.descriptor;case enums.ConstantPoolItemType.CLASS:var f=a;return util.ext_classname(f.name);default:return logging.debug_var(a.value)}}function annotateOpcode(a,b,c,d){return exports.OpcodeLayoutPrinters[enums.OpcodeLayouts[a]](b,c,d)}var enums=__webpack_require__(9),assert=__webpack_require__(13),gLong=__webpack_require__(8),opcodes=__webpack_require__(15),logging=__webpack_require__(16),util=__webpack_require__(7),ThreadStatus=enums.ThreadStatus,debug=logging.debug,vtrace=logging.vtrace,trace=logging.trace,maxMethodResumes=1e4,methodResumesLeft=maxMethodResumes,numSamples=1,PreAllocatedStack=function(){function a(a){this.curr=0,this.store=new Array(a)}return a.prototype.push=function(a){this.store[this.curr++]=a},a.prototype.pushAll=function(){for(var a=arguments.length,b=0;b<a;b++)this.store[this.curr++]=arguments[b]},a.prototype.pushWithNull=function(a){this.store[this.curr]=a,this.curr+=2},a.prototype.push6=function(a,b,c,d,e,f){this.store[this.curr++]=a,this.store[this.curr++]=b,this.store[this.curr++]=c,this.store[this.curr++]=d,this.store[this.curr++]=e,this.store[this.curr++]=f},a.prototype.swap=function(){var a=this.store[this.curr-1];this.store[this.curr-1]=this.store[this.curr-2],this.store[this.curr-2]=a},a.prototype.dup=function(){this.store[this.curr]=this.store[this.curr-1],this.curr++},a.prototype.dup2=function(){this.store[this.curr]=this.store[this.curr-2],this.store[this.curr+1]=this.store[this.curr-1],this.curr+=2},a.prototype.dup_x1=function(){var a=this.store[this.curr-1];this.store[this.curr-1]=this.store[this.curr-2],this.store[this.curr]=a,this.store[this.curr-2]=a,this.curr++},a.prototype.dup_x2=function(){var a=this.store[this.curr-1];this.store[this.curr-1]=this.store[this.curr-2],this.store[this.curr-2]=this.store[this.curr-3],this.store[this.curr]=a,this.store[this.curr-3]=a,this.curr++},a.prototype.dup2_x1=function(){var a=this.store[this.curr-1],b=this.store[this.curr-2];this.store[this.curr]=b,this.store[this.curr+1]=a,this.store[this.curr-1]=this.store[this.curr-3],this.store[this.curr-2]=a,this.store[this.curr-3]=b,this.curr+=2},a.prototype.pop=function(){return this.store[--this.curr]},a.prototype.pop2=function(){return this.curr-=2,this.store[this.curr]},a.prototype.bottom=function(){return this.store[0]},a.prototype.top=function(){return this.store[this.curr-1]},a.prototype.fromTop=function(a){return this.store[this.curr-(a+1)]},a.prototype.sliceFromBottom=function(a){return this.store.slice(a,this.curr)},a.prototype.sliceFromTop=function(a){return this.store.slice(this.curr-a,this.curr)},a.prototype.dropFromTop=function(a){this.curr-=a},a.prototype.sliceAndDropFromTop=function(a){var b=this.curr;return this.curr-=a,this.store.slice(b-a,b)},a.prototype.getRaw=function(){return this.store.slice(0,this.curr)},a.prototype.clear=function(){this.curr=0},a}();exports.PreAllocatedStack=PreAllocatedStack;var jitUtil={isNull:opcodes.isNull,resolveCPItem:opcodes.resolveCPItem,throwException:opcodes.throwException,gLong:gLong,float2int:util.float2int,wrapFloat:util.wrapFloat,Constants:enums.Constants},BytecodeStackFrame=function(){function a(a,b){this.pc=0,this.returnToThreadLoop=!1,this.lockedMethodLock=!1,this.type=enums.StackFrameType.BYTECODE,this.method=a,a.incrBBEntries(),this.locals=b,this.opStack=new PreAllocatedStack(a.getCodeAttribute().getMaxStack())}return a.prototype.run=function(a){var b=this,c=this.method,d=this.method.getCodeAttribute().getCode(),e=opcodes.LookupTable;if(!c.accessFlags.isSynchronized()||this.lockedMethodLock||(this.lockedMethodLock=c.methodLock(a,this).enter(a,function(){b.lockedMethodLock=!0}),this.lockedMethodLock))if(this.returnToThreadLoop=!1,a.getJVM().isJITDisabled())for(;!this.returnToThreadLoop;){var f=d.readUInt8(this.pc);e[f](a,this,d)}else for(;!this.returnToThreadLoop;){var g=c.getOp(this.pc,d,a);\"function\"==typeof g?g(this,a,jitUtil):e[g](a,this,d)}},a.prototype.scheduleResume=function(a,b,c){var d=this.method.getCodeAttribute().getCode().readUInt8(this.pc);switch(d){case enums.OpCode.INVOKEINTERFACE:case enums.OpCode.INVOKEINTERFACE_FAST:this.pc+=5;break;case enums.OpCode.INVOKESPECIAL:case enums.OpCode.INVOKESTATIC:case enums.OpCode.INVOKEVIRTUAL:case enums.OpCode.INVOKESTATIC_FAST:case enums.OpCode.INVOKENONVIRTUAL_FAST:case enums.OpCode.INVOKEVIRTUAL_FAST:case enums.OpCode.INVOKEHANDLE:case enums.OpCode.INVOKEBASIC:case enums.OpCode.LINKTOSPECIAL:case enums.OpCode.LINKTOVIRTUAL:case enums.OpCode.INVOKEDYNAMIC:case enums.OpCode.INVOKEDYNAMIC_FAST:this.pc+=3}void 0!==b&&this.opStack.push(b),void 0!==c&&this.opStack.push(c)},a.prototype.scheduleException=function(a,b){for(var c,d=this.method.getCodeAttribute(),e=this.pc,f=this.method,g=d.exceptionHandlers,h=b.getClass(),i=0;i<g.length;i++){var j=g[i];if(j.startPC<=e&&e<j.endPC){if(\"<any>\"===j.catchType){c=j;break}var k=f.cls.getLoader().getResolvedClass(j.catchType);if(null==k){for(var l=[],m=0;m<g.length;m++){var n=g[m];\"<any>\"!==n.catchType&&l.push(n.catchType)}return a.setStatus(ThreadStatus.ASYNC_WAITING),f.cls.getLoader().resolveClasses(a,l,function(c){null!==c&&a.throwException(b)}),!0}if(h.isCastable(k)){c=j;break}}}return null!=c?(this.opStack.clear(),this.opStack.push(b),this.pc=c.handlerPC,!0):(f.accessFlags.isSynchronized()&&f.methodLock(a,this).exit(a),!1)},a.prototype.getLoader=function(){return this.method.cls.getLoader()},a.prototype.getStackTraceFrame=function(){return{method:this.method,pc:this.pc,stack:this.opStack.sliceFromBottom(0),locals:this.locals.slice(0)}},a}();exports.BytecodeStackFrame=BytecodeStackFrame;var NativeStackFrame=function(){function a(a,b){this.type=enums.StackFrameType.NATIVE,this.method=a,this.args=b,this.nativeMethod=a.getNativeFunction()}return a.prototype.run=function(a){var b=this.nativeMethod.apply(null,this.method.convertArgs(a,this.args));if(a.getStatus()===ThreadStatus.RUNNABLE&&a.currentMethod()===this.method){var c=this.method.returnType;switch(c){case\"J\":case\"D\":a.asyncReturn(b,null);break;case\"Z\":a.asyncReturn(b?1:0);break;default:a.asyncReturn(b)}}},a.prototype.scheduleResume=function(a,b,c){},a.prototype.scheduleException=function(a,b){return!1},a.prototype.getStackTraceFrame=function(){return{method:this.method,pc:-1,stack:[],locals:[]}},a.prototype.getLoader=function(){return this.method.cls.getLoader()},a}();exports.NativeStackFrame=NativeStackFrame;var InternalStackFrame=function(){function a(a){this.isException=!1,this.type=enums.StackFrameType.INTERNAL,this.cb=a}return a.prototype.run=function(a){a.framePop(),a.setStatus(ThreadStatus.ASYNC_WAITING),this.isException?this.cb(this.val):this.cb(null,this.val)},a.prototype.scheduleResume=function(a,b){this.isException=!1,this.val=b},a.prototype.scheduleException=function(a,b){return this.isException=!0,this.val=b,!0},a.prototype.getStackTraceFrame=function(){return null},a.prototype.getLoader=function(){throw new Error(\"Internal stack frames have no loader.\")},a}();exports.InternalStackFrame=InternalStackFrame;var JVMThread=function(){function a(a,b,c){this.status=ThreadStatus.NEW,this.stack=[],this.interrupted=!1,this.monitor=null,this.jvm=a,this.bsCl=a.getBootstrapClassLoader(),this.tpool=b,this.jvmThreadObj=c}return a.prototype.getJVMObject=function(){return this.jvmThreadObj},a.prototype.isDaemon=function(){return 0!==this.jvmThreadObj[\"java/lang/Thread/daemon\"]},a.prototype.getPriority=function(){return this.jvmThreadObj[\"java/lang/Thread/priority\"]},a.prototype.setJVMObject=function(a){a[\"java/lang/Thread/threadStatus\"]=this.jvmThreadObj[\"java/lang/Thread/threadStatus\"],this.jvmThreadObj=a},a.prototype.getRef=function(){return this.jvmThreadObj.ref},a.prototype.isInterrupted=function(){return this.interrupted},a.prototype.currentMethod=function(){for(var a,b=this.stack,c=b.length;--c>=0;)if(a=b[c].getStackTraceFrame().method,null!==a)return a;return null},a.prototype.setInterrupted=function(a){this.interrupted=a},a.prototype.getBsCl=function(){return this.bsCl},a.prototype.getLoader=function(){var a=this.stack[this.stack.length-1].getLoader();if(a)return a;for(var b=this.stack.length,c=2;c<=b;c++)if(a=this.stack[b-c].getLoader())return a;throw new Error(\"Unable to find loader.\")},a.prototype[\"import\"]=function(a,b,c){var d=this;void 0===c&&(c=!0);var e=this.getLoader();if(this.setStatus(ThreadStatus.ASYNC_WAITING),Array.isArray(a)){var f=[];util.asyncForEach(a,function(a,b){d._import(a,e,function(a){f.push(a),b()},c)},function(a){b(f)})}else this._import(a,e,b,c)},a.prototype._import=function(a,b,c,d){var e=this,f=b.getInitializedClass(this,a);f?setImmediate(function(){return c(f.getConstructor(e))}):b.initializeClass(this,a,function(a){a&&c(a.getConstructor(e))},d)},a.prototype.getJVM=function(){return this.jvm},a.prototype.getThreadPool=function(){return this.tpool},a.prototype.getStackTrace=function(){var a,b,c=[];for(a=0;a<this.stack.length;a++)b=this.stack[a].getStackTraceFrame(),null!=b&&c.push(b);return c},a.prototype.getPrintableStackTrace=function(){var a=\"\";return this.getStackTrace().reverse().forEach(function(b){if(a+=\"\\tat \"+util.ext_classname(b.method.cls.getInternalName())+\"::\"+b.method.name+\"(\",b.pc>=0){var c=b.method.getCodeAttribute(),d=c.getAttribute(\"LineNumberTable\"),e=b.method.cls.getAttribute(\"SourceFile\");if(a+=null!=e?e.filename:\"unknown\",null!=d){var f=d.getLineNumber(b.pc);a+=\":\"+f,a+=\" Bytecode offset: \"+b.pc}}else a+=\"native\";a+=\")\\n\"}),a},a.prototype.run=function(){var a=this.stack,b=(new Date).getTime();for(methodResumesLeft=maxMethodResumes;this.status===ThreadStatus.RUNNABLE&&a.length>0;){var c=a[a.length-1];if(c.run(this),0===--methodResumesLeft){var d=(new Date).getTime(),e=d-b,f=maxMethodResumes/e*this.jvm.getResponsiveness()|0;maxMethodResumes=(f+numSamples*maxMethodResumes)/(numSamples+1)|0,maxMethodResumes<=0&&(maxMethodResumes=10),numSamples++,this.tpool.quantumOver(this);break}}0===a.length&&this.setStatus(ThreadStatus.TERMINATED)},a.prototype.sanityCheck=function(){switch(this.status){case ThreadStatus.NEW:return!0;case ThreadStatus.RUNNABLE:return!0;case ThreadStatus.TIMED_WAITING:return!0;case ThreadStatus.WAITING:return!0;case ThreadStatus.BLOCKED:case ThreadStatus.UNINTERRUPTABLY_BLOCKED:return!0;case ThreadStatus.ASYNC_WAITING:return!0;case ThreadStatus.TERMINATED:return!0;case ThreadStatus.PARKED:return!0;default:return!1}},a.prototype.rawSetStatus=function(a){var b=0,c=this.status;switch(logging.log_level===logging.VTRACE,this.status=a,a){case ThreadStatus.NEW:b|=enums.JVMTIThreadState.ALIVE;break;case ThreadStatus.RUNNABLE:b|=enums.JVMTIThreadState.RUNNABLE;break;case ThreadStatus.BLOCKED:case ThreadStatus.UNINTERRUPTABLY_BLOCKED:b|=enums.JVMTIThreadState.BLOCKED_ON_MONITOR_ENTER;break;case ThreadStatus.WAITING:case ThreadStatus.ASYNC_WAITING:case ThreadStatus.PARKED:b|=enums.JVMTIThreadState.WAITING_INDEFINITELY;break;case ThreadStatus.TIMED_WAITING:b|=enums.JVMTIThreadState.WAITING_WITH_TIMEOUT;break;case ThreadStatus.TERMINATED:b|=enums.JVMTIThreadState.TERMINATED;break;default:b=enums.JVMTIThreadState.RUNNABLE}this.jvmThreadObj[\"java/lang/Thread/threadStatus\"]=b,this.tpool.statusChange(this,c,this.status)},a.prototype.setStatus=function(a,b){if(void 0===b&&(b=null),this.status!==a){this.status;this.monitor=b,a!==ThreadStatus.TERMINATED?this.rawSetStatus(a):this.exit()}},a.prototype.exit=function(){var a=this,b=this.jvmThreadObj.getMonitor();if(!b.isBlocked(this)&&b.getOwner()!==this&&this.status!==ThreadStatus.TERMINATED)if(0===this.stack.length){if(this.setStatus(ThreadStatus.ASYNC_WAITING),this.jvm.hasVMBooted()){var c=function(){a.jvmThreadObj[\"exit()V\"](a,null,function(c){b.notifyAll(a),b.exit(a),a.rawSetStatus(ThreadStatus.TERMINATED)})};b.enter(this,c)&&c()}}else{for(;this.stack.length>0;)this.stack.pop();this.rawSetStatus(ThreadStatus.TERMINATED)}},a.prototype.signalPriorityChange=function(){this.tpool.priorityChange(this)},a.prototype.getMonitorBlock=function(){return this.monitor},a.prototype.getStatus=function(){return this.status},a.prototype.asyncReturn=function(a,b){var c=this.stack,d=c.pop();if(d.type!=enums.StackFrameType.INTERNAL){d.type===enums.StackFrameType.BYTECODE}var e=c.length-1;e>=0&&c[e].scheduleResume(this,a,b),this.setStatus(ThreadStatus.RUNNABLE)},a.prototype.framePop=function(){this.stack.pop()},a.prototype.throwException=function(a){var b=this.stack,c=b.length-1;if(c>=0)for(b[c].type===enums.StackFrameType.INTERNAL&&(b.pop(),c--),this.setStatus(ThreadStatus.RUNNABLE);b.length>0&&!b[c].scheduleException(this,a);)b.pop(),c--;0===b.length&&this.handleUncaughtException(a)},a.prototype.throwNewException=function(a,b){var c=this,d=this.getLoader().getInitializedClass(this,a),e=function(){var a=d.getConstructor(c),e=new a(c);e[\"<init>(Ljava/lang/String;)V\"](c,[util.initString(c.bsCl,b)],function(a){a?c.throwException(a):c.throwException(e)})};null!=d?e():(this.setStatus(ThreadStatus.ASYNC_WAITING),this.getLoader().initializeClass(this,a,function(a){null!=a&&(d=a,e())},!1))},a.prototype.handleUncaughtException=function(a){this.jvmThreadObj[\"dispatchUncaughtException(Ljava/lang/Throwable;)V\"](this,[a])},a.prototype.close=function(){this.jvm=null},a}();exports.JVMThread=JVMThread,exports.validTransitions={},exports.validTransitions[ThreadStatus.NEW]={},exports.validTransitions[ThreadStatus.NEW][ThreadStatus.RUNNABLE]=\"RunMethod invoked on new thread\",exports.validTransitions[ThreadStatus.NEW][ThreadStatus.ASYNC_WAITING]=\"[JVM bootup only] Internal operation occurs on new thread\",exports.validTransitions[ThreadStatus.NEW][ThreadStatus.TERMINATED]=\"[JVM halt0 only] When the JVM shuts down, it terminates all threads, including those that have never been run.\",exports.validTransitions[ThreadStatus.ASYNC_WAITING]={},exports.validTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.RUNNABLE]=\"Async operation completes\",exports.validTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.TERMINATED]=\"RunMethod completes and callstack is empty\",exports.validTransitions[ThreadStatus.BLOCKED]={},exports.validTransitions[ThreadStatus.BLOCKED][ThreadStatus.RUNNABLE]=\"Acquires monitor, or is interrupted\",exports.validTransitions[ThreadStatus.BLOCKED][ThreadStatus.TERMINATED]=\"Thread is terminated whilst blocked.\",exports.validTransitions[ThreadStatus.PARKED]={},exports.validTransitions[ThreadStatus.PARKED][ThreadStatus.ASYNC_WAITING]=\"Balancing unpark, or is interrupted\",exports.validTransitions[ThreadStatus.PARKED][ThreadStatus.TERMINATED]=\"Thread is terminated whilst parked.\",exports.validTransitions[ThreadStatus.RUNNABLE]={},exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.ASYNC_WAITING]=\"Thread performs an asynchronous JavaScript operation\",exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TERMINATED]=\"Callstack is empty\",exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.BLOCKED]=\"Thread waits to acquire monitor\",exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.WAITING]=\"Thread waits on monitor (Object.wait)\",exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TIMED_WAITING]=\"Thread waits on monitor with timeout (Object.wait)\",exports.validTransitions[ThreadStatus.RUNNABLE][ThreadStatus.PARKED]=\"Thread parks itself\",exports.validTransitions[ThreadStatus.TERMINATED]={},exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.NEW]=\"Thread is resurrected for re-use\",exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.RUNNABLE]=\"Thread is resurrected for re-use\",exports.validTransitions[ThreadStatus.TERMINATED][ThreadStatus.ASYNC_WAITING]=\"[JVM Bootup] Thread is resurrected for internal operation\",exports.validTransitions[ThreadStatus.TIMED_WAITING]={},exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.RUNNABLE]=\"Timer expires, or thread is interrupted, and thread immediately acquires lock\",exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED]=\"Thread is interrupted or notified, or timer expires, and lock already owned\",exports.validTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.TERMINATED]=\"Thread is terminated whilst waiting.\",exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED]={},exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.RUNNABLE]=\"Thread acquires monitor\",exports.validTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.TERMINATED]=\"Thread is terminated whilst blocked.\",exports.validTransitions[ThreadStatus.WAITING]={},exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.RUNNABLE]=\"Thread is interrupted, and immediately acquires lock\",exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED]=\"Thread is notified or interrupted, and does not immediately acquire lock\",exports.validTransitions[ThreadStatus.WAITING][ThreadStatus.TERMINATED]=\"Thread is terminated whilst waiting.\",exports.OpcodeLayoutPrinters={},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.OPCODE_ONLY]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+printConstantPoolItem(a.cls.constantPool.get(b.readUInt16BE(c+1)))},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_UINT8]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+printConstantPoolItem(a.cls.constantPool.get(b.readUInt8(c+1)))},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+printConstantPoolItem(a.cls.constantPool.get(b.readUInt16BE(c+1)))+\" \"+b.readUInt8(c+3)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+b.readUInt8(c+1)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_AND_INT8_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+b.readUInt8(c+1)+\" \"+b.readInt8(c+2)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT8_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+b.readInt8(c+1)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT16_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+b.readInt16BE(c+1)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.INT32_VALUE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+b.readInt32BE(c+1)},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.ARRAY_TYPE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()+\" \"+opcodes.ArrayTypes[b.readUInt8(c+1)]},exports.OpcodeLayoutPrinters[enums.OpcodeLayoutType.WIDE]=function(a,b,c){return enums.OpCode[b.readUInt8(c)].toLowerCase()},exports.annotateOpcode=annotateOpcode;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function isNull(a,b,c){return null==c&&(throwException(a,b,\"Ljava/lang/NullPointerException;\",\"\"),!0)}function pop2(a){return a.pop(),a.pop()}function resolveCPItem(a,b,c){a.setStatus(enums.ThreadStatus.ASYNC_WAITING),c.resolve(a,b.getLoader(),b.method.cls,function(b){b&&a.setStatus(enums.ThreadStatus.RUNNABLE)},!1),b.returnToThreadLoop=!0}function initializeClassFromClass(a,b,c){a.setStatus(enums.ThreadStatus.ASYNC_WAITING),c.initialize(a,function(b){null!=b&&a.setStatus(enums.ThreadStatus.RUNNABLE)},!1),b.returnToThreadLoop=!0}function initializeClass(a,b,c){function d(b){b.initialize(a,function(b){null!=b&&a.setStatus(enums.ThreadStatus.RUNNABLE)})}a.setStatus(enums.ThreadStatus.ASYNC_WAITING),c.isResolved()?d(c.cls):c.resolve(a,b.getLoader(),b.method.cls,function(a){a&&d(c.cls)},!1),b.returnToThreadLoop=!0}function throwException(a,b,c,d){a.throwNewException(c,d),b.returnToThreadLoop=!0}var gLong=__webpack_require__(8),util=__webpack_require__(7),enums=__webpack_require__(9),assert=__webpack_require__(13);exports.isNull=isNull,exports.pop2=pop2,exports.resolveCPItem=resolveCPItem,exports.initializeClassFromClass=initializeClassFromClass,exports.initializeClass=initializeClass,exports.throwException=throwException,exports.ArrayTypes={4:\"Z\",5:\"C\",6:\"F\",7:\"D\",8:\"B\",9:\"S\",10:\"I\",11:\"J\"};var Opcodes=function(){function a(){}return a._aload_32=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();if(!isNull(a,b,e)){var f=e.array.length;d<0||d>=f?throwException(a,b,\"Ljava/lang/ArrayIndexOutOfBoundsException;\",d+\" not in length \"+f+\" array of type \"+e.getClass().getInternalName()):(c.push(e.array[d]),b.pc++)}},a._aload_64=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();if(!isNull(a,b,e)){var f=e.array.length;d<0||d>=f?throwException(a,b,\"Ljava/lang/ArrayIndexOutOfBoundsException;\",d+\" not in length \"+f+\" array of type \"+e.getClass().getInternalName()):(c.push(e.array[d]),c.push(null),b.pc++)}},a._astore_32=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop(),f=c.pop();if(!isNull(a,b,f)){var g=f.array.length;e<0||e>=g?throwException(a,b,\"Ljava/lang/ArrayIndexOutOfBoundsException;\",e+\" not in length \"+g+\" array of type \"+f.getClass().getInternalName()):(f.array[e]=d,b.pc++)}},a._astore_64=function(a,b){var c=b.opStack,d=c.pop2(),e=c.pop(),f=c.pop();if(!isNull(a,b,f)){var g=f.array.length;e<0||e>=g?throwException(a,b,\"Ljava/lang/ArrayIndexOutOfBoundsException;\",e+\" not in length \"+g+\" array of type \"+f.getClass().getInternalName()):(f.array[e]=d,b.pc++)}},a.aconst_null=function(a,b){b.opStack.push(null),b.pc++},a._const_0_32=function(a,b){b.opStack.push(0),b.pc++},a._const_1_32=function(a,b){b.opStack.push(1),b.pc++},a._const_2_32=function(a,b){b.opStack.push(2),b.pc++},a.iconst_m1=function(a,b){b.opStack.push(-1),b.pc++},a.iconst_3=function(a,b){b.opStack.push(3),b.pc++},a.iconst_4=function(a,b){b.opStack.push(4),b.pc++},a.iconst_5=function(a,b){b.opStack.push(5),b.pc++},a.lconst_0=function(a,b){b.opStack.pushWithNull(gLong.ZERO),b.pc++},a.lconst_1=function(a,b){b.opStack.pushWithNull(gLong.ONE),b.pc++},a.dconst_0=function(a,b){b.opStack.pushWithNull(0),b.pc++},a.dconst_1=function(a,b){b.opStack.pushWithNull(1),b.pc++},a._load_32=function(a,b,c){var d=b.pc;b.opStack.push(b.locals[c.readUInt8(d+1)]),b.pc+=2},a._load_0_32=function(a,b){b.opStack.push(b.locals[0]),b.pc++},a._load_1_32=function(a,b){b.opStack.push(b.locals[1]),b.pc++},a._load_2_32=function(a,b){b.opStack.push(b.locals[2]),b.pc++},a._load_3_32=function(a,b){b.opStack.push(b.locals[3]),b.pc++},a._load_64=function(a,b,c){var d=b.pc;b.opStack.pushWithNull(b.locals[c.readUInt8(d+1)]),b.pc+=2},a._load_0_64=function(a,b){b.opStack.pushWithNull(b.locals[0]),b.pc++},a._load_1_64=function(a,b){b.opStack.pushWithNull(b.locals[1]),b.pc++},a._load_2_64=function(a,b){b.opStack.pushWithNull(b.locals[2]),b.pc++},a._load_3_64=function(a,b){b.opStack.pushWithNull(b.locals[3]),b.pc++},a._store_32=function(a,b,c){var d=b.pc;b.locals[c.readUInt8(d+1)]=b.opStack.pop(),b.pc+=2},a._store_0_32=function(a,b){b.locals[0]=b.opStack.pop(),b.pc++},a._store_1_32=function(a,b){b.locals[1]=b.opStack.pop(),b.pc++},a._store_2_32=function(a,b){b.locals[2]=b.opStack.pop(),b.pc++},a._store_3_32=function(a,b){b.locals[3]=b.opStack.pop(),b.pc++},a._store_64=function(a,b,c){var d=b.pc,e=c.readUInt8(d+1);b.locals[e+1]=b.opStack.pop(),b.locals[e]=b.opStack.pop(),b.pc+=2},a._store_0_64=function(a,b){b.locals[1]=b.opStack.pop(),b.locals[0]=b.opStack.pop(),b.pc++},a._store_1_64=function(a,b){b.locals[2]=b.opStack.pop(),b.locals[1]=b.opStack.pop(),b.pc++},a._store_2_64=function(a,b){b.locals[3]=b.opStack.pop(),b.locals[2]=b.opStack.pop(),b.pc++},a._store_3_64=function(a,b){b.locals[4]=b.opStack.pop(),b.locals[3]=b.opStack.pop(),b.pc++},a.sipush=function(a,b,c){var d=b.pc;b.opStack.push(c.readInt16BE(d+1)),b.pc+=3},a.bipush=function(a,b,c){var d=b.pc;b.opStack.push(c.readInt8(d+1)),b.pc+=2},a.pop=function(a,b){b.opStack.dropFromTop(1),b.pc++},a.pop2=function(a,b){b.opStack.dropFromTop(2),b.pc++},a.dup=function(a,b){b.opStack.dup(),b.pc++},a.dup_x1=function(a,b){b.opStack.dup_x1(),b.pc++},a.dup_x2=function(a,b){b.opStack.dup_x2(),b.pc++},a.dup2=function(a,b){b.opStack.dup2(),b.pc++},a.dup2_x1=function(a,b){b.opStack.dup2_x1(),b.pc++},a.dup2_x2=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop(),f=c.pop(),g=c.pop();c.push6(e,d,g,f,e,d),b.pc++},a.swap=function(a,b){b.opStack.swap(),b.pc++},a.iadd=function(a,b){var c=b.opStack;c.push(c.pop()+c.pop()|0),b.pc++},a.ladd=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().add(c.pop2())),b.pc++},a.fadd=function(a,b){var c=b.opStack;c.push(util.wrapFloat(c.pop()+c.pop())),b.pc++},a.dadd=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2()+c.pop2()),b.pc++},a.isub=function(a,b){var c=b.opStack;c.push(-c.pop()+c.pop()|0),b.pc++},a.fsub=function(a,b){var c=b.opStack;c.push(util.wrapFloat(-c.pop()+c.pop())),b.pc++},a.dsub=function(a,b){var c=b.opStack;c.pushWithNull(-c.pop2()+c.pop2()),b.pc++},a.lsub=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().negate().add(c.pop2())),b.pc++},a.imul=function(a,b){var c=b.opStack;c.push(Math.imul(c.pop(),c.pop())),b.pc++},a.lmul=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().multiply(c.pop2())),b.pc++},a.fmul=function(a,b){var c=b.opStack;c.push(util.wrapFloat(c.pop()*c.pop())),b.pc++},a.dmul=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2()*c.pop2()),b.pc++},a.idiv=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();0===d?throwException(a,b,\"Ljava/lang/ArithmeticException;\",\"/ by zero\"):(e===enums.Constants.INT_MIN&&d===-1?c.push(e):c.push(e/d|0),b.pc++)},a.ldiv=function(a,b){var c=b.opStack,d=c.pop2(),e=c.pop2();d.isZero()?throwException(a,b,\"Ljava/lang/ArithmeticException;\",\"/ by zero\"):(c.pushWithNull(e.div(d)),b.pc++)},a.fdiv=function(a,b){var c=b.opStack,d=c.pop();c.push(util.wrapFloat(c.pop()/d)),b.pc++},a.ddiv=function(a,b){var c=b.opStack,d=c.pop2();c.pushWithNull(c.pop2()/d),b.pc++},a.irem=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();0===d?throwException(a,b,\"Ljava/lang/ArithmeticException;\",\"/ by zero\"):(c.push(e%d),b.pc++)},a.lrem=function(a,b){var c=b.opStack,d=c.pop2(),e=c.pop2();d.isZero()?throwException(a,b,\"Ljava/lang/ArithmeticException;\",\"/ by zero\"):(c.pushWithNull(e.modulo(d)),b.pc++)},a.frem=function(a,b){var c=b.opStack,d=c.pop();c.push(c.pop()%d),b.pc++},a.drem=function(a,b){var c=b.opStack,d=c.pop2();c.pushWithNull(c.pop2()%d),b.pc++},a.ineg=function(a,b){var c=b.opStack;c.push(0|-c.pop()),b.pc++},a.lneg=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().negate()),b.pc++},a.fneg=function(a,b){var c=b.opStack;c.push(-c.pop()),b.pc++},a.dneg=function(a,b){var c=b.opStack;c.pushWithNull(-c.pop2()),b.pc++},a.ishl=function(a,b){var c=b.opStack,d=c.pop();c.push(c.pop()<<d),b.pc++},a.lshl=function(a,b){var c=b.opStack,d=c.pop();c.pushWithNull(c.pop2().shiftLeft(gLong.fromInt(d))),b.pc++},a.ishr=function(a,b){var c=b.opStack,d=c.pop();c.push(c.pop()>>d),b.pc++},a.lshr=function(a,b){var c=b.opStack,d=c.pop();c.pushWithNull(c.pop2().shiftRight(gLong.fromInt(d))),b.pc++},a.iushr=function(a,b){var c=b.opStack,d=c.pop();c.push(c.pop()>>>d|0),b.pc++},a.lushr=function(a,b){var c=b.opStack,d=c.pop();c.pushWithNull(c.pop2().shiftRightUnsigned(gLong.fromInt(d))),b.pc++},a.iand=function(a,b){var c=b.opStack;c.push(c.pop()&c.pop()),b.pc++},a.land=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().and(c.pop2())),b.pc++},a.ior=function(a,b){var c=b.opStack;c.push(c.pop()|c.pop()),b.pc++},a.lor=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().or(c.pop2())),b.pc++},a.ixor=function(a,b){var c=b.opStack;c.push(c.pop()^c.pop()),b.pc++},a.lxor=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().xor(c.pop2())),b.pc++},a.iinc=function(a,b,c){var d=b.pc,e=c.readUInt8(d+1),f=c.readInt8(d+2);b.locals[e]=b.locals[e]+f|0,b.pc+=3},a.i2l=function(a,b){var c=b.opStack;c.pushWithNull(gLong.fromInt(c.pop())),b.pc++},a.i2f=function(a,b){b.pc++},a.i2d=function(a,b){b.opStack.push(null),b.pc++},a.l2i=function(a,b){var c=b.opStack;c.push(c.pop2().toInt()),b.pc++},a.l2f=function(a,b){var c=b.opStack;c.push(c.pop2().toNumber()),b.pc++},a.l2d=function(a,b){var c=b.opStack;c.pushWithNull(c.pop2().toNumber()),b.pc++},a.f2i=function(a,b){var c=b.opStack;c.push(util.float2int(c.pop())),b.pc++},a.f2l=function(a,b){var c=b.opStack;c.pushWithNull(gLong.fromNumber(c.pop())),b.pc++},a.f2d=function(a,b){b.opStack.push(null),b.pc++},a.d2i=function(a,b){var c=b.opStack;c.push(util.float2int(c.pop2())),b.pc++},a.d2l=function(a,b){var c=b.opStack,d=c.pop2();d===Number.POSITIVE_INFINITY?c.pushWithNull(gLong.MAX_VALUE):d===Number.NEGATIVE_INFINITY?c.pushWithNull(gLong.MIN_VALUE):c.pushWithNull(gLong.fromNumber(d)),b.pc++},a.d2f=function(a,b){var c=b.opStack;c.pop(),c.push(util.wrapFloat(c.pop())),b.pc++},a.i2b=function(a,b){var c=b.opStack;c.push(c.pop()<<24>>24),b.pc++},a.i2c=function(a,b){var c=b.opStack;c.push(65535&c.pop()),b.pc++},a.i2s=function(a,b){var c=b.opStack;c.push(c.pop()<<16>>16),b.pc++},a.lcmp=function(a,b){var c=b.opStack,d=c.pop2();c.push(c.pop2().compare(d)),b.pc++},a.fcmpl=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();e===d?c.push(0):e>d?c.push(1):c.push(-1),b.pc++},a.fcmpg=function(a,b){var c=b.opStack,d=c.pop(),e=c.pop();e===d?c.push(0):e<d?c.push(-1):c.push(1),b.pc++},a.dcmpl=function(a,b){var c=b.opStack,d=c.pop2(),e=c.pop2();e===d?c.push(0):e>d?c.push(1):c.push(-1),b.pc++},a.dcmpg=function(a,b){var c=b.opStack,d=c.pop2(),e=c.pop2();e===d?c.push(0):e<d?c.push(-1):c.push(1),b.pc++},a.ifeq=function(a,b,c){var d=b.pc;if(0===b.opStack.pop()){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.ifne=function(a,b,c){var d=b.pc;if(0!==b.opStack.pop()){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.iflt=function(a,b,c){var d=b.pc;if(b.opStack.pop()<0){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.ifge=function(a,b,c){var d=b.pc;if(b.opStack.pop()>=0){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.ifgt=function(a,b,c){var d=b.pc;if(b.opStack.pop()>0){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.ifle=function(a,b,c){var d=b.pc;if(b.opStack.pop()<=0){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmpeq=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f===e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmpne=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f!==e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmplt=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f<e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmpge=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f>=e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmpgt=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f>e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_icmple=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f<=e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_acmpeq=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f===e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a.if_acmpne=function(a,b,c){var d=b.pc,e=b.opStack.pop(),f=b.opStack.pop();if(f!==e){var g=c.readInt16BE(d+1);b.pc+=g,g<0&&b.method.incrBBEntries()}else b.pc+=3},a[\"goto\"]=function(a,b,c){var d=b.pc,e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()},a.jsr=function(a,b,c){var d=b.pc;b.opStack.push(d+3);var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()},a.ret=function(a,b,c){var d=b.pc;b.pc=b.locals[c.readUInt8(d+1)]},a.tableswitch=function(a,b,c){var d=b.pc;d+=(4-(d+1)%4)%4+1;var e=c.readInt32BE(d),f=c.readInt32BE(d+4),g=c.readInt32BE(d+8),h=b.opStack.pop();h>=f&&h<=g?b.pc+=c.readInt32BE(d+12+4*(h-f)):b.pc+=e},a.lookupswitch=function(a,b,c){var d=b.pc;d+=(4-(d+1)%4)%4+1;var e,f=c.readInt32BE(d),g=c.readInt32BE(d+4),h=b.opStack.pop();for(d+=8,e=0;e<g;e++){if(c.readInt32BE(d)===h){var i=c.readInt32BE(d+4);return b.pc+=i,void(i<0&&b.method.incrBBEntries())}d+=8}b.pc+=f},a[\"return\"]=function(a,b){b.returnToThreadLoop=!0,b.method.accessFlags.isSynchronized()&&!b.method.methodLock(a,b).exit(a)||a.asyncReturn()},a._return_32=function(a,b){b.returnToThreadLoop=!0,b.method.accessFlags.isSynchronized()&&!b.method.methodLock(a,b).exit(a)||a.asyncReturn(b.opStack.bottom())},a._return_64=function(a,b){b.returnToThreadLoop=!0,b.method.accessFlags.isSynchronized()&&!b.method.methodLock(a,b).exit(a)||a.asyncReturn(b.opStack.bottom(),null)},a.getstatic=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));if(e.isResolved()){var f=e.field.cls;f.isInitialized(a)?(\"J\"===e.nameAndTypeInfo.descriptor||\"D\"===e.nameAndTypeInfo.descriptor?c.writeUInt8(enums.OpCode.GETSTATIC_FAST64,d):c.writeUInt8(enums.OpCode.GETSTATIC_FAST32,d),e.fieldOwnerConstructor=f.getConstructor(a)):initializeClassFromClass(a,b,f)}else resolveCPItem(a,b,e)},a.getstatic_fast32=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));b.opStack.push(e.fieldOwnerConstructor[e.fullFieldName]),b.pc+=3},a.getstatic_fast64=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));b.opStack.pushWithNull(e.fieldOwnerConstructor[e.fullFieldName]),b.pc+=3},a.putstatic=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));if(e.isResolved()){var f=e.field.cls;f.isInitialized(a)?(\"J\"===e.nameAndTypeInfo.descriptor||\"D\"===e.nameAndTypeInfo.descriptor?c.writeUInt8(enums.OpCode.PUTSTATIC_FAST64,d):c.writeUInt8(enums.OpCode.PUTSTATIC_FAST32,d),e.fieldOwnerConstructor=f.getConstructor(a)):initializeClassFromClass(a,b,f)}else resolveCPItem(a,b,e)},a.putstatic_fast32=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.fieldOwnerConstructor[e.fullFieldName]=b.opStack.pop(),b.pc+=3},a.putstatic_fast64=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.fieldOwnerConstructor[e.fullFieldName]=b.opStack.pop2(),b.pc+=3},a.getfield=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=(b.getLoader(),b.opStack.top());if(!isNull(a,b,f))if(e.isResolved()){var g=e.field;\"J\"==g.rawDescriptor||\"D\"==g.rawDescriptor?c.writeUInt8(enums.OpCode.GETFIELD_FAST64,d):c.writeUInt8(enums.OpCode.GETFIELD_FAST32,d)}else resolveCPItem(a,b,e)},a.getfield_fast32=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=f.pop();isNull(a,b,g)||(f.push(g[e.fullFieldName]),b.pc+=3)},a.getfield_fast64=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=f.pop();isNull(a,b,g)||(f.pushWithNull(g[e.fullFieldName]),b.pc+=3)},a.putfield=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=(b.getLoader(),\"J\"==e.nameAndTypeInfo.descriptor||\"D\"==e.nameAndTypeInfo.descriptor),g=b.opStack.fromTop(f?2:1);if(!isNull(a,b,g))if(e.isResolved()){var h=e.field;f?c.writeUInt8(enums.OpCode.PUTFIELD_FAST64,d):c.writeUInt8(enums.OpCode.PUTFIELD_FAST32,d),e.fullFieldName=util.descriptor2typestr(h.cls.getInternalName())+\"/\"+e.nameAndTypeInfo.name}else resolveCPItem(a,b,e)},a.putfield_fast32=function(a,b,c){var d=b.pc,e=b.opStack,f=e.pop(),g=e.pop(),h=b.method.cls.constantPool.get(c.readUInt16BE(d+1));isNull(a,b,g)||(g[h.fullFieldName]=f,b.pc+=3)},a.putfield_fast64=function(a,b,c){var d=b.pc,e=b.opStack,f=e.pop2(),g=e.pop(),h=b.method.cls.constantPool.get(c.readUInt16BE(d+1));isNull(a,b,g)||(g[h.fullFieldName]=f,b.pc+=3)},a.invokevirtual=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));if(e.isResolved()){var f=e.method;if(f.isSignaturePolymorphic())switch(f.name){case\"invokeBasic\":c.writeUInt8(enums.OpCode.INVOKEBASIC,d);break;case\"invoke\":case\"invokeExact\":c.writeUInt8(enums.OpCode.INVOKEHANDLE,d);break;default:throwException(a,b,\"Ljava/lang/AbstractMethodError;\",\"Invalid signature polymorphic method: \"+f.cls.getExternalName()+\".\"+f.name)}else c.writeUInt8(enums.OpCode.INVOKEVIRTUAL_FAST,d)}else resolveCPItem(a,b,e)},a.invokeinterface=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?e.method.cls.isInitialized(a)?c.writeUInt8(enums.OpCode.INVOKEINTERFACE_FAST,d):initializeClass(a,b,e.classInfo):resolveCPItem(a,b,e)},a.invokedynamic=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));a.setStatus(enums.ThreadStatus.ASYNC_WAITING),e.constructCallSiteObject(a,b.getLoader(),b.method.cls,d,function(b){b&&(c.writeUInt8(enums.OpCode.INVOKEDYNAMIC_FAST,d),a.setStatus(enums.ThreadStatus.RUNNABLE))}),b.returnToThreadLoop=!0},a.invokespecial=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?c.writeUInt8(enums.OpCode.INVOKENONVIRTUAL_FAST,d):resolveCPItem(a,b,e)},a.invokestatic=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));if(e.isResolved()){var f=e.method;if(f.cls.isInitialized(a)){var g=enums.OpCode.INVOKESTATIC_FAST;if(e.method.isSignaturePolymorphic())switch(e.method.name){case\"linkToInterface\":case\"linkToVirtual\":g=enums.OpCode.LINKTOVIRTUAL;break;case\"linkToStatic\":case\"linkToSpecial\":g=enums.OpCode.LINKTOSPECIAL}c.writeUInt8(g,d)}else initializeClassFromClass(a,b,f.cls)}else resolveCPItem(a,b,e)},a.invokenonvirtual_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=e.paramWordSize,h=f.fromTop(g);if(!isNull(a,b,h)){var i=f.sliceFromTop(g);f.dropFromTop(g+1),h[e.fullSignature](a,i),b.returnToThreadLoop=!0}},a.invokestatic_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=e.paramWordSize,h=f.sliceAndDropFromTop(g);e.jsConstructor[e.fullSignature](a,h),b.returnToThreadLoop=!0},a.invokevirtual_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=e.paramWordSize,g=b.opStack,h=g.fromTop(f);isNull(a,b,h)||(h[e.signature](a,g.sliceFromTop(f)),g.dropFromTop(f+1),b.returnToThreadLoop=!0)},a.invokedynamic_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=e.getCallSiteObject(d),g=f[1],h=f[0].vmtarget,i=b.opStack,j=e.paramWordSize,k=i.sliceAndDropFromTop(j);null!==g&&k.push(g),h(a,null,k),b.returnToThreadLoop=!0},a.invokehandle=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=e.memberName.vmtarget,h=e.paramWordSize+1,i=e.appendix,j=f.sliceFromTop(h);null!==i&&j.push(i),isNull(a,b,j[0])||(f.dropFromTop(h),g(a,null,j),b.returnToThreadLoop=!0)},a.invokebasic=function(a,b,c){var d,e,f=b.pc,g=b.method.cls.constantPool.get(c.readUInt16BE(f+1)),h=g.getParamWordSize(),i=b.opStack,j=i.fromTop(h),k=i.sliceFromTop(h+1);isNull(a,b,j)||(i.dropFromTop(h+1),d=j[\"java/lang/invoke/MethodHandle/form\"],e=d[\"java/lang/invoke/LambdaForm/vmentry\"],e.vmtarget(a,g.nameAndTypeInfo.descriptor,k),b.returnToThreadLoop=!0)},a.linktospecial=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=b.opStack,g=e.paramWordSize,h=f.sliceFromTop(g),i=h.pop(),j=e.nameAndTypeInfo.descriptor;isNull(a,b,i)||(f.dropFromTop(g),i.vmtarget(a,j.replace(\"Ljava/lang/invoke/MemberName;)\",\")\"),h),b.returnToThreadLoop=!0)},a.linktovirtual=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=e.paramWordSize,g=b.opStack,h=g.sliceFromTop(f),i=h.pop(),j=e.nameAndTypeInfo.descriptor;isNull(a,b,i)||(g.dropFromTop(f),i.vmtarget(a,j.replace(\"Ljava/lang/invoke/MemberName;)\",\")\"),h),b.returnToThreadLoop=!0)},a.breakpoint=function(a,b){throwException(a,b,\"Ljava/lang/Error;\",\"breakpoint not implemented.\")},a[\"new\"]=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));if(e.isResolved()){var f=e.cls;f.isInitialized(a)?c.writeUInt8(enums.OpCode.NEW_FAST,d):initializeClassFromClass(a,b,f)}else resolveCPItem(a,b,e)},a.new_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));b.opStack.push(new e.clsConstructor(a)),b.pc+=3},a.newarray=function(a,b,c){var d=b.pc,e=b.opStack,f=\"[\"+exports.ArrayTypes[c.readUInt8(d+1)],g=b.getLoader().getInitializedClass(a,f),h=e.pop();h>=0?(e.push(new(g.getConstructor(a))(a,h)),b.pc+=2):throwException(a,b,\"Ljava/lang/NegativeArraySizeException;\",\"Tried to init \"+f+\" array with length \"+h)},a.anewarray=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?(c.writeUInt8(enums.OpCode.ANEWARRAY_FAST,d),e.arrayClass=b.getLoader().getInitializedClass(a,\"[\"+e.cls.getInternalName()),e.arrayClassConstructor=e.arrayClass.getConstructor(a)):resolveCPItem(a,b,e)},a.anewarray_fast=function(a,b,c){var d=b.pc,e=b.opStack,f=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),g=e.pop();g>=0?(e.push(new f.arrayClassConstructor(a,g)),b.pc+=3):throwException(a,b,\"Ljava/lang/NegativeArraySizeException;\",\"Tried to init \"+f.arrayClass.getInternalName()+\" array with length \"+g)},a.arraylength=function(a,b){var c=b.opStack,d=c.pop();isNull(a,b,d)||(c.push(d.array.length),b.pc++)},a.athrow=function(a,b){a.throwException(b.opStack.pop()),b.returnToThreadLoop=!0},a.checkcast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?c.writeUInt8(enums.OpCode.CHECKCAST_FAST,d):resolveCPItem(a,b,e)},a.checkcast_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=e.cls,g=b.opStack,h=g.top();if(null==h||h.getClass().isCastable(f))b.pc+=3;else{var i=f.getExternalName(),j=h.getClass().getExternalName();throwException(a,b,\"Ljava/lang/ClassCastException;\",j+\" cannot be cast to \"+i)}},a[\"instanceof\"]=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?c.writeUInt8(enums.OpCode.INSTANCEOF_FAST,d):resolveCPItem(a,b,e)},a.instanceof_fast=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1)),f=e.cls,g=b.opStack,h=g.pop();g.push(null!==h&&h.getClass().isCastable(f)?1:0),b.pc+=3},a.monitorenter=function(a,b){var c=b.opStack,d=c.pop(),e=function(){b.pc++};d.getMonitor().enter(a,e)?e():b.returnToThreadLoop=!0},a.monitorexit=function(a,b){var c=b.opStack.pop();c.getMonitor().exit(a)?b.pc++:b.returnToThreadLoop=!0},a.multianewarray=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?c.writeUInt8(enums.OpCode.MULTIANEWARRAY_FAST,d):resolveCPItem(a,b,e)},a.multianewarray_fast=function(a,b,c){var d,e,f=b.pc,g=b.method.cls.constantPool.get(c.readUInt16BE(f+1)),h=b.opStack,i=c.readUInt8(f+3),j=new Array(i);for(d=0;d<i;d++)if(e=h.pop(),j[i-d-1]=e,e<0)return void throwException(a,b,\"Ljava/lang/NegativeArraySizeException;\",\"Tried to init \"+g.cls.getInternalName()+\" array with a dimension of length \"+e);h.push(new(g.cls.getConstructor(a))(a,j)),b.pc+=4},a.ifnull=function(a,b,c){var d=b.pc;if(null==b.opStack.pop()){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.ifnonnull=function(a,b,c){var d=b.pc;if(null!=b.opStack.pop()){var e=c.readInt16BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()}else b.pc+=3},a.goto_w=function(a,b,c){var d=b.pc,e=c.readInt32BE(d+1);b.pc+=e,e<0&&b.method.incrBBEntries()},a.jsr_w=function(a,b,c){var d=b.pc;b.opStack.push(b.pc+5),b.pc+=c.readInt32BE(d+1)},a.nop=function(a,b){b.pc+=1},a.ldc=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt8(d+1));e.isResolved()?(b.opStack.push(e.getConstant(a)),b.pc+=2):resolveCPItem(a,b,e)},a.ldc_w=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));e.isResolved()?(b.opStack.push(e.getConstant(a)),b.pc+=3):resolveCPItem(a,b,e)},a.ldc2_w=function(a,b,c){var d=b.pc,e=b.method.cls.constantPool.get(c.readUInt16BE(d+1));b.opStack.pushWithNull(e.value),b.pc+=3},a.wide=function(a,b,c){var d=b.pc,e=c.readUInt16BE(d+2);switch(b.pc+=4,c.readUInt8(d+1)){case enums.OpCode.ILOAD:case enums.OpCode.FLOAD:case enums.OpCode.ALOAD:b.opStack.push(b.locals[e]);break;case enums.OpCode.LLOAD:case enums.OpCode.DLOAD:b.opStack.pushWithNull(b.locals[e]);break;case enums.OpCode.ISTORE:case enums.OpCode.FSTORE:case enums.OpCode.ASTORE:b.locals[e]=b.opStack.pop();break;case enums.OpCode.LSTORE:case enums.OpCode.DSTORE:b.locals[e+1]=b.opStack.pop(),b.locals[e]=b.opStack.pop();break;case enums.OpCode.RET:b.pc=b.locals[e];break;case enums.OpCode.IINC:var f=c.readInt16BE(d+4);b.locals[e]=b.locals[e]+f|0,b.pc+=2}},a.iaload=a._aload_32,a.faload=a._aload_32,a.aaload=a._aload_32,a.baload=a._aload_32,a.caload=a._aload_32,a.saload=a._aload_32,a.daload=a._aload_64,a.laload=a._aload_64,a.iastore=a._astore_32,a.fastore=a._astore_32,a.aastore=a._astore_32,a.bastore=a._astore_32,a.castore=a._astore_32,a.sastore=a._astore_32,a.lastore=a._astore_64,a.dastore=a._astore_64,a.iconst_0=a._const_0_32,a.iconst_1=a._const_1_32,a.iconst_2=a._const_2_32,a.fconst_0=a._const_0_32,a.fconst_1=a._const_1_32,a.fconst_2=a._const_2_32,a.iload=a._load_32,a.iload_0=a._load_0_32,a.iload_1=a._load_1_32,a.iload_2=a._load_2_32,a.iload_3=a._load_3_32,a.fload=a._load_32,a.fload_0=a._load_0_32,a.fload_1=a._load_1_32,a.fload_2=a._load_2_32,a.fload_3=a._load_3_32,a.aload=a._load_32,a.aload_0=a._load_0_32,a.aload_1=a._load_1_32,a.aload_2=a._load_2_32,a.aload_3=a._load_3_32,a.lload=a._load_64,a.lload_0=a._load_0_64,a.lload_1=a._load_1_64,a.lload_2=a._load_2_64,a.lload_3=a._load_3_64,a.dload=a._load_64,a.dload_0=a._load_0_64,a.dload_1=a._load_1_64,a.dload_2=a._load_2_64,a.dload_3=a._load_3_64,a.istore=a._store_32,a.istore_0=a._store_0_32,a.istore_1=a._store_1_32,a.istore_2=a._store_2_32,a.istore_3=a._store_3_32,a.fstore=a._store_32,a.fstore_0=a._store_0_32,a.fstore_1=a._store_1_32,a.fstore_2=a._store_2_32,a.fstore_3=a._store_3_32,a.astore=a._store_32,a.astore_0=a._store_0_32,a.astore_1=a._store_1_32,a.astore_2=a._store_2_32,a.astore_3=a._store_3_32,a.lstore=a._store_64,a.lstore_0=a._store_0_64,a.lstore_1=a._store_1_64,a.lstore_2=a._store_2_64,a.lstore_3=a._store_3_64,a.dstore=a._store_64,a.dstore_0=a._store_0_64,a.dstore_1=a._store_1_64,a.dstore_2=a._store_2_64,a.dstore_3=a._store_3_64,a.ireturn=a._return_32,a.freturn=a._return_32,a.areturn=a._return_32,a.lreturn=a._return_64,a.dreturn=a._return_64,a.invokeinterface_fast=a.invokevirtual_fast,a}();exports.Opcodes=Opcodes,exports.LookupTable=new Array(255),function(){for(var a=0;a<255;a++)enums.OpCode.hasOwnProperty(\"\"+a)&&(exports.LookupTable[a]=Opcodes[enums.OpCode[a].toLowerCase()])}();\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function debug_var(a){return null===a?\"!\":void 0===a?\"undef\":null!=a.ref?\"*\"+a.ref:a instanceof gLong?a+\"L\":a}function debug_vars(a){return a.map(debug_var)}function log(a,b){if(a<=exports.log_level){var c=b.join(\" \");1==a?console.error(c):console.log(c)}}function vtrace(){for(var a=[],b=0;b<arguments.length;b++)a[b-0]=arguments[b];log(exports.VTRACE,a)}function trace(){for(var a=[],b=0;b<arguments.length;b++)a[b-0]=arguments[b];log(exports.TRACE,a)}function debug(){for(var a=[],b=0;b<arguments.length;b++)a[b-0]=arguments[b];log(exports.DEBUG,a)}function error(){for(var a=[],b=0;b<arguments.length;b++)a[b-0]=arguments[b];log(exports.ERROR,a)}var gLong=__webpack_require__(8);exports.debug_var=debug_var,exports.debug_vars=debug_vars,exports.VTRACE=10,exports.TRACE=9,exports.DEBUG=5,exports.ERROR=1,exports.log_level=exports.ERROR,exports.vtrace=vtrace,exports.trace=trace,exports.debug=debug,exports.error=error;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\"use strict\";var StringOutputStream=function(){function a(){this._data=[]}return a.prototype.write=function(a){this._data.push(a)},a.prototype.flush=function(){var a=this._data.join(\"\");return this._data=[],a},a}();module.exports=StringOutputStream;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";var toExport;toExport=\"undefined\"!=typeof window?window:\"undefined\"!=typeof self?self:global,module.exports=toExport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function makeOnError(a,b){return a.length>0?\"f.pc=\"+b+\";f.opStack.pushAll(\"+a.join(\",\")+\");\":\"f.pc=\"+b+\";\"}var enums=__webpack_require__(9),opcodes=__webpack_require__(15),escapeStringRegEx=/\\\\/g;exports.opJitInfo=function(){var a=[],b=enums.OpCode;a[b.ACONST_NULL]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=null;\"+d}},a[b.ICONST_M1]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=-1;\"+d}};var c={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[0];\"+d}},d={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[1];\"+d}},e={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[2];\"+d}},f={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[3];\"+d}};a[b.ALOAD_0]=c,a[b.ILOAD_0]=c,a[b.FLOAD_0]=c,a[b.ALOAD_1]=d,a[b.ILOAD_1]=d,a[b.FLOAD_1]=d,a[b.ALOAD_2]=e,a[b.ILOAD_2]=e,a[b.FLOAD_2]=e,a[b.ALOAD_3]=f,a[b.ILOAD_3]=f,a[b.FLOAD_3]=f;var g={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[0],\"+b[1]+\"=null;\"+d}},h={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[1],\"+b[1]+\"=null;\"+d}},i={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[2],\"+b[1]+\"=null;\"+d}},j={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=f.locals[3],\"+b[1]+\"=null;\"+d}};a[b.LLOAD_0]=g,a[b.DLOAD_0]=g,a[b.LLOAD_1]=h,a[b.DLOAD_1]=h,a[b.LLOAD_2]=i,a[b.DLOAD_2]=i,a[b.LLOAD_3]=j,a[b.DLOAD_3]=j;var k={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d){return\"f.locals[0]=\"+a[0]+\";\"+d}},l={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d){return\"f.locals[1]=\"+a[0]+\";\"+d}},m={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d){return\"f.locals[2]=\"+a[0]+\";\"+d}},n={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d){return\"f.locals[3]=\"+a[0]+\";\"+d}};a[b.ASTORE_0]=k,a[b.ISTORE_0]=k,a[b.FSTORE_0]=k,a[b.ASTORE_1]=l,a[b.ISTORE_1]=l,a[b.FSTORE_1]=l,a[b.ASTORE_2]=m,a[b.ISTORE_2]=m,a[b.FSTORE_2]=m,a[b.ASTORE_3]=n,a[b.ISTORE_3]=n,a[b.FSTORE_3]=n;var o={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f){var g=e.readUInt8(f+1);return\"f.locals[\"+(g+1)+\"]=\"+a[0]+\";f.locals[\"+g+\"]=\"+a[1]+\";\"+d}},p={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d){return\"f.locals[1]=\"+a[0]+\";f.locals[0]=\"+a[1]+\";\"+d}},q={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d){return\"f.locals[2]=\"+a[0]+\";f.locals[1]=\"+a[1]+\";\"+d}},r={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d){return\"f.locals[3]=\"+a[0]+\";f.locals[2]=\"+a[1]+\";\"+d}},s={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d){return\"f.locals[4]=\"+a[0]+\";f.locals[3]=\"+a[1]+\";\"+d}};a[b.LSTORE]=o,a[b.DSTORE]=o,a[b.LSTORE_0]=p,a[b.DSTORE_0]=p,a[b.LSTORE_1]=q,a[b.DSTORE_1]=q,a[b.LSTORE_2]=r,a[b.DSTORE_2]=r,a[b.LSTORE_3]=s,a[b.DSTORE_3]=s;var t={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=0;\"+d}},u={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=1;\"+d}},v={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=2;\"+d}};a[b.ICONST_0]=t,a[b.ICONST_1]=u,a[b.ICONST_2]=v,a[b.FCONST_0]=t,a[b.FCONST_1]=u,a[b.FCONST_2]=v,a[b.ICONST_3]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=3;\"+d}},a[b.ICONST_4]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=4;\"+d}},a[b.ICONST_5]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=5;\"+d}},a[b.LCONST_0]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.gLong.ZERO,\"+b[1]+\"=null;\"+d}},a[b.LCONST_1]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.gLong.ONE,\"+b[1]+\"=null;\"+d}},a[b.DCONST_0]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=0,\"+b[1]+\"=null;\"+d}},a[b.DCONST_1]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=1,\"+b[1]+\"=null;\"+d}};var w={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(!u.isNull(t,f,\"+a[1]+\")){\\nvar len\"+c+\"=\"+a[1]+\".array.length;\\nif(\"+a[0]+\"<0||\"+a[0]+\">=len\"+c+\"){\\n\"+h+\"\\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\\\"\\\"+\"+a[0]+'+\" not in length \"+len'+c+'+\" array of type \"+'+a[1]+\".getClass().getInternalName());\\n}else{var \"+b[0]+\"=\"+a[1]+\".array[\"+a[0]+\"];\"+d+\"}\\n}else{\"+h+\"}\"}};a[b.IALOAD]=w,a[b.FALOAD]=w,a[b.AALOAD]=w,a[b.BALOAD]=w,a[b.CALOAD]=w,a[b.SALOAD]=w;var x={hasBranch:!1,pops:2,pushes:2,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(!u.isNull(t,f,\"+a[1]+\")){\\nvar len\"+c+\"=\"+a[1]+\".array.length;\\nif(\"+a[0]+\"<0||\"+a[0]+\">=len\"+c+\"){\\n\"+h+\"\\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\\\"\\\"+\"+a[0]+'+\" not in length \"+len'+c+'+\" array of type \"+'+a[1]+\".getClass().getInternalName());\\n}else{var \"+b[0]+\"=\"+a[1]+\".array[\"+a[0]+\"],\"+b[1]+\"=null;\"+d+\"}\\n}else{\"+h+\"}\"}};a[b.DALOAD]=x,a[b.LALOAD]=x;var y={hasBranch:!1,pops:3,pushes:0,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(!u.isNull(t,f,\"+a[2]+\")){\\nvar len\"+c+\"=\"+a[2]+\".array.length;\\nif(\"+a[1]+\"<0||\"+a[1]+\">=len\"+c+\"){\\n\"+h+\"\\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\\\"\\\"+\"+a[1]+'+\" not in length \"+len'+c+'+\" array of type \"+'+a[2]+\".getClass().getInternalName());\\n}else{\"+a[2]+\".array[\"+a[1]+\"]=\"+a[0]+\";\"+d+\"}\\n}else{\"+h+\"}\"}};a[b.IASTORE]=y,a[b.FASTORE]=y,a[b.AASTORE]=y,a[b.BASTORE]=y,a[b.CASTORE]=y,a[b.SASTORE]=y;var z={hasBranch:!1,pops:4,pushes:0,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(!u.isNull(t,f,\"+a[3]+\")){\\nvar len\"+c+\"=\"+a[3]+\".array.length;\\nif(\"+a[2]+\"<0||\"+a[2]+\">=len\"+c+\"){\\n\"+h+\"\\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\\\"\\\"+\"+a[2]+'+\" not in length \"+len'+c+'+\" array of type \"+'+a[3]+\".getClass().getInternalName());\\n}else{\"+a[3]+\".array[\"+a[2]+\"]=\"+a[1]+\";\"+d+\"}\\n}else{\"+h+\"}\"}};a[b.DASTORE]=z,a[b.LASTORE]=z,a[b.LDC]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f,g){var h=e.readUInt8(f+1),i=makeOnError(g,f);return\"\\nvar cnst\"+c+\"=f.method.cls.constantPool.get(\"+h+\");\\nif(cnst\"+c+\".isResolved()){var \"+b[0]+\"=cnst\"+c+\".getConstant(t);\"+d+\"\\n}else{\"+i+\"u.resolveCPItem(t,f,cnst\"+c+\");}\"}},a[b.LDC_W]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f,g){var h=e.readUInt16BE(f+1),i=makeOnError(g,f);return\"\\nvar cnst\"+c+\"=f.method.cls.constantPool.get(\"+h+\");\\nif(cnst\"+c+\".isResolved()){var \"+b[0]+\"=cnst\"+c+\".getConstant(t);\"+d+\"\\n}else{\"+i+\"u.resolveCPItem(t,f,cnst\"+c+\");}\"}},a[b.LDC2_W]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d,e,f){var g=e.readUInt16BE(f+1);return\"var \"+b[0]+\"=f.method.cls.constantPool.get(\"+g+\").value,\"+b[1]+\"=null;\"+d}},a[b.GETSTATIC_FAST32]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readUInt16BE(f+1);return\"var fi\"+c+\"=f.method.cls.constantPool.get(\"+g+\"),\"+b[0]+\"=fi\"+c+\".fieldOwnerConstructor[fi\"+c+\".fullFieldName];\"+d}},a[b.GETSTATIC_FAST64]={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d,e,f){var g=e.readUInt16BE(f+1);return\"\\nvar fi\"+c+\"=f.method.cls.constantPool.get(\"+g+\"),\"+b[0]+\"=fi\"+c+\".fieldOwnerConstructor[fi\"+c+\".fullFieldName],\\n\"+b[1]+\"=null;\"+d}},a[b.GETFIELD_FAST32]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f,g,h){var i=makeOnError(g,f),j=e.readUInt16BE(f+1),k=h.cls.constantPool.get(j),l=k.fullFieldName.replace(escapeStringRegEx,\"\\\\\\\\\");return\"if(!u.isNull(t,f,\"+a[0]+\")){var \"+b[0]+\"=\"+a[0]+\"['\"+l+\"'];\"+d+\"}else{\"+i+\"}\"}},a[b.GETFIELD_FAST64]={hasBranch:!1,pops:1,pushes:2,emit:function(a,b,c,d,e,f,g,h){var i=makeOnError(g,f),j=e.readUInt16BE(f+1),k=h.cls.constantPool.get(j),l=k.fullFieldName.replace(escapeStringRegEx,\"\\\\\\\\\");return\"if(!u.isNull(t,f,\"+a[0]+\")){var \"+b[0]+\"=\"+a[0]+\"['\"+l+\"'],\"+b[1]+\"=null;\"+d+\"}else{\"+i+\"}\"}},a[b.PUTFIELD_FAST32]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g,h){var i=makeOnError(g,f),j=e.readUInt16BE(f+1),k=h.cls.constantPool.get(j),l=k.fullFieldName.replace(escapeStringRegEx,\"\\\\\\\\\");return\"if(!u.isNull(t,f,\"+a[1]+\")){\"+a[1]+\"['\"+l+\"']=\"+a[0]+\";\"+d+\"}else{\"+i+\"}\"}},a[b.PUTFIELD_FAST64]={hasBranch:!1,pops:3,pushes:0,emit:function(a,b,c,d,e,f,g,h){var i=makeOnError(g,f),j=e.readUInt16BE(f+1),k=h.cls.constantPool.get(j),l=k.fullFieldName.replace(escapeStringRegEx,\"\\\\\\\\\");return\"if(!u.isNull(t,f,\"+a[2]+\")){\"+a[2]+\"['\"+l+\"']=\"+a[1]+\";\"+d+\"}else{\"+i+\"}\"}},a[b.INSTANCEOF_FAST]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readUInt16BE(f+1);return\"var cls\"+c+\"=f.method.cls.constantPool.get(\"+g+\").cls,\"+b[0]+\"=\"+a[0]+\"!==null?(\"+a[0]+\".getClass().isCastable(cls\"+c+\")?1:0):0;\"+d}},a[b.CHECKCAST_FAST]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f,g,h){var i=e.readUInt16BE(f+1),j=h.cls.constantPool.get(i),k=j.cls.getExternalName();return\"var cls\"+c+\"=f.method.cls.constantPool.get(\"+i+\").cls;\\nif((\"+a[0]+\"!=null)&&!\"+a[0]+\".getClass().isCastable(cls\"+c+\")){\\nu.throwException(t,f,'Ljava/lang/ClassCastException;',\"+a[0]+\".getClass().getExternalName()+' cannot be cast to \"+k+\"');\\n}else{var \"+b[0]+\"=\"+a[0]+\";\"+d+\"}\"}},a[b.ARRAYLENGTH]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"if(!u.isNull(t,f,\"+a[0]+\")){var \"+b[0]+\"=\"+a[0]+\".array.length;\"+d+\"}else{\"+h+\"}\"}};var A={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readUInt8(f+1);return\"var \"+b[0]+\"=f.locals[\"+g+\"];\"+d}};a[b.ILOAD]=A,a[b.ALOAD]=A,a[b.FLOAD]=A;var B={hasBranch:!1,pops:0,pushes:2,emit:function(a,b,c,d,e,f){var g=e.readUInt8(f+1);return\"var \"+b[0]+\"=f.locals[\"+g+\"],\"+b[1]+\"=null;\"+d}};a[b.LLOAD]=B,a[b.DLOAD]=B;var C={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f){var g=e.readUInt8(f+1);return\"f.locals[\"+g+\"]=\"+a[0]+\";\"+d}};a[b.ISTORE]=C,a[b.ASTORE]=C,a[b.FSTORE]=C,a[b.BIPUSH]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readInt8(f+1);return\"var \"+b[0]+\"=\"+g+\";\"+d}},a[b.SIPUSH]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readInt16BE(f+1);return\"var \"+b[0]+\"=\"+g+\";\"+d}},a[b.IINC]={hasBranch:!1,pops:0,pushes:0,emit:function(a,b,c,d,e,f){var g=e.readUInt8(f+1),h=e.readInt8(f+2);return\"f.locals[\"+g+\"]=(f.locals[\"+g+\"]+\"+h+\")|0;\"+d}},a[b.ATHROW]={hasBranch:!0,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return h+\"t.throwException(\"+a[0]+\");f.returnToThreadLoop=true;\"}},a[b.GOTO]={hasBranch:!0,pops:0,pushes:0,emit:function(a,b,c,d,e,f){var g=e.readInt16BE(f+1);return\"f.pc=\"+(f+g)+\";\"+d}},a[b.TABLESWITCH]={hasBranch:!0,pops:1,pushes:0,emit:function(a,b,c,d,e,f){var g=f+(4-(f+1)%4)%4+1,h=e.readInt32BE(g),i=e.readInt32BE(g+4),j=e.readInt32BE(g+8);if(j-i<8){for(var k=\"switch(\"+a[0]+\"){\",l=i;l<=j;l++){var m=e.readInt32BE(g+12+4*(l-i));k+=\"case \"+l+\":f.pc=\"+(f+m)+\";break;\"}return k+=\"default:f.pc=\"+(f+h)+\"}\"+d}return\"if(\"+a[0]+\">=\"+i+\"&&\"+a[0]+\"<=\"+j+\"){f.pc=\"+f+\"+f.method.getCodeAttribute().getCode().readInt32BE(\"+(g+12)+\"+((\"+a[0]+\" - \"+i+\")*4))}else{f.pc=\"+(f+h)+\"}\"+d}};var D={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"===\"+a[1]+\"){\"+i+\"}else{\"+d+\"}\"}};a[b.IF_ICMPEQ]=D,a[b.IF_ACMPEQ]=D;var E={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"!==\"+a[1]+\"){\"+i+\"}else{\"+d+\"}\"}};a[b.IF_ICMPNE]=E,a[b.IF_ACMPNE]=E,a[b.IF_ICMPGE]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[1]+\">=\"+a[0]+\"){\"+i+\"}else{\"+d+\"}\"}},a[b.IF_ICMPGT]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[1]+\">\"+a[0]+\"){\"+i+\"}else{\"+d+\"}\"}},a[b.IF_ICMPLE]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[1]+\"<=\"+a[0]+\"){\"+i+\"}else{\"+d+\"}\"}},a[b.IF_ICMPLT]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[1]+\"<\"+a[0]+\"){\"+i+\"}else{\"+d+\"}\"}},a[b.IFNULL]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"==null){\"+i+\"}else{\"+d+\"}\"}},a[b.IFNONNULL]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"!=null){\"+i+\"}else{\"+d+\"}\"}},a[b.IFEQ]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"===0){\"+i+\"}else{\"+d+\"}\"}},a[b.IFNE]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"!==0){\"+i+\"}else{\"+d+\"}\"}},a[b.IFGT]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\">0){\"+i+\"}else{\"+d+\"}\"}},a[b.IFLT]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"<0){\"+i+\"}else{\"+d+\"}\"}},a[b.IFGE]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\">=0){\"+i+\"}else{\"+d+\"}\"}},a[b.IFLE]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=e.readInt16BE(f+1),i=makeOnError(g,f+h);return\"if(\"+a[0]+\"<=0){\"+i+\"}else{\"+d+\"}\"}},a[b.LCMP]={hasBranch:!1,pops:4,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\".compare(\"+a[1]+\");\"+d}},a[b.FCMPL]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"===\"+a[1]+\"?0:(\"+a[1]+\">\"+a[0]+\"?1:-1);\"+d}},a[b.DCMPL]={hasBranch:!1,pops:4,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"===\"+a[1]+\"?0:(\"+a[3]+\">\"+a[1]+\"?1:-1);\"+d}},a[b.FCMPG]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"===\"+a[1]+\"?0:(\"+a[1]+\"<\"+a[0]+\"?-1:1);\"+d}},a[b.DCMPG]={hasBranch:!1,pops:4,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"===\"+a[1]+\"?0:(\"+a[3]+\"<\"+a[1]+\"?-1:1);\"+d}},a[b.RETURN]={hasBranch:!0,pops:0,pushes:0,emit:function(a,b,c,d,e,f,g,h){return h.accessFlags.isSynchronized()?\"f.pc=\"+f+\";f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn();\":\"f.pc=\"+f+\";f.returnToThreadLoop=true;t.asyncReturn();\"}};var F={hasBranch:!0,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g,h){return h.accessFlags.isSynchronized()?\"f.pc=\"+f+\";f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn(\"+a[0]+\");\":\"f.pc=\"+f+\";f.returnToThreadLoop=true;t.asyncReturn(\"+a[0]+\");\"}};a[b.IRETURN]=F,a[b.FRETURN]=F,a[b.ARETURN]=F;var G={hasBranch:!0,pops:2,pushes:0,emit:function(a,b,c,d,e,f,g,h){return h.accessFlags.isSynchronized()?\"f.pc=\"+f+\";f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn(\"+a[1]+\",null);\":\"f.pc=\"+f+\";f.returnToThreadLoop=true;t.asyncReturn(\"+a[1]+\",null);\"}};return a[b.LRETURN]=G,a[b.DRETURN]=G,a[b.MONITOREXIT]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"if(\"+a[0]+\".getMonitor().exit(t)){\"+d+\"}else{\"+h+\"f.returnToThreadLoop=true;}\"}},a[b.IXOR]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"^\"+a[1]+\";\"+d}},a[b.LXOR]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".xor(\"+a[3]+\"),\"+b[1]+\"=null;\"+d}},a[b.IOR]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"|\"+a[1]+\";\"+d}},a[b.LOR]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\".or(\"+a[1]+\"),\"+b[1]+\"=null;\"+d}},a[b.IAND]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"&\"+a[1]+\";\"+d}},a[b.LAND]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\".and(\"+a[1]+\"),\"+b[1]+\"=null;\"+d}},a[b.IADD]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(\"+a[0]+\"+\"+a[1]+\")|0;\"+d}},a[b.LADD]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".add(\"+a[3]+\"),\"+b[1]+\"=null;\"+d}},a[b.DADD]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\"+\"+a[3]+\",\"+b[1]+\"=null;\"+d}},a[b.IMUL]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=Math.imul(\"+a[0]+\", \"+a[1]+\");\"+d}},a[b.FMUL]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.wrapFloat(\"+a[0]+\"*\"+a[1]+\");\"+d}},a[b.LMUL]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\".multiply(\"+a[1]+\"),\"+b[1]+\"= null;\"+d}},a[b.DMUL]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"*\"+a[1]+\",\"+b[1]+\"=null;\"+d}},a[b.IDIV]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(\"+a[0]+\"===0){\"+h+\"u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\\n}else{var \"+b[0]+\"=(\"+a[1]+\"===u.Constants.INT_MIN&&\"+a[0]+\"===-1)?\"+a[1]+\":((\"+a[1]+\"/\"+a[0]+\")|0);\"+d+\"}\"}},a[b.LDIV]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"\\nif(\"+a[1]+\".isZero()){\"+h+\"u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\\n}else{var \"+b[0]+\"=\"+a[3]+\".div(\"+a[1]+\"),\"+b[1]+\"=null;\"+d+\"}\"}},a[b.DDIV]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"/\"+a[1]+\",\"+b[1]+\"=null;\"+d}},a[b.ISUB]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(\"+a[1]+\"-\"+a[0]+\")|0;\"+d}},a[b.LSUB]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".negate().add(\"+a[3]+\"),\"+b[1]+\"= null;\"+d}},a[b.DSUB]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"-\"+a[1]+\",\"+b[1]+\"=null;\"+d}},a[b.IREM]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"if(\"+a[0]+\"===0){\"+h+\"u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\\n}else{var \"+b[0]+\"=\"+a[1]+\"%\"+a[0]+\";\"+d+\"}\"}},a[b.LREM]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d,e,f,g){var h=makeOnError(g,f);return\"if(\"+a[1]+\".isZero()){\"+h+\"u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\\n}else{var \"+b[0]+\"=\"+a[3]+\".modulo(\"+a[1]+\"),\"+b[1]+\"=null;\"+d+\"}\"}},a[b.DREM]={hasBranch:!1,pops:4,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[3]+\"%\"+a[1]+\",\"+b[1]+\"=null;\"+d}},a[b.INEG]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(-\"+a[0]+\")|0;\"+d}},a[b.LNEG]={hasBranch:!1,pops:2,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".negate(),\"+b[1]+\"=null;\"+d}},a[b.ISHL]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\"<<\"+a[0]+\";\"+d}},a[b.LSHL]={hasBranch:!1,pops:3,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[2]+\".shiftLeft(u.gLong.fromInt(\"+a[0]+\")),\"+b[1]+\"=null;\"+d}},a[b.ISHR]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\">>\"+a[0]+\";\"+d}},a[b.LSHR]={hasBranch:!1,pops:3,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[2]+\".shiftRight(u.gLong.fromInt(\"+a[0]+\")),\"+b[1]+\"=null;\"+d}},a[b.IUSHR]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(\"+a[1]+\">>>\"+a[0]+\")|0;\"+d}},a[b.LUSHR]={hasBranch:!1,pops:3,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[2]+\".shiftRightUnsigned(u.gLong.fromInt(\"+a[0]+\")),\"+b[1]+\"=null;\"+d}},a[b.I2B]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(\"+a[0]+\"<<24)>>24;\"+d}},a[b.I2S]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=(\"+a[0]+\"<<16)>>16;\"+d}},a[b.I2C]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\"&0xFFFF;\"+d}},a[b.I2L]={hasBranch:!1,pops:1,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.gLong.fromInt(\"+a[0]+\"),\"+b[1]+\"=null;\"+d}},a[b.I2F]={hasBranch:!1,pops:0,pushes:0,emit:function(a,b,c,d){return\"\"+d}},a[b.I2D]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=null;\"+d}},a[b.F2I]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.float2int(\"+a[0]+\");\"+d}},a[b.F2D]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=null;\"+d}},a[b.L2I]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".toInt();\"+d}},a[b.L2D]={hasBranch:!1,pops:2,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\".toNumber(),\"+b[1]+\"=null;\"+d}},a[b.D2I]={hasBranch:!1,pops:2,pushes:1,emit:function(a,b,c,d){return\"var \"+b[0]+\"=u.float2int(\"+a[1]+\");\"+d}},a[b.DUP]={hasBranch:!1,pops:1,pushes:2,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\",\"+b[1]+\"=\"+a[0]+\";\"+d}},a[b.DUP2]={hasBranch:!1,pops:2,pushes:4,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\",\"+b[1]+\"=\"+a[0]+\",\"+b[2]+\"=\"+a[1]+\",\"+b[3]+\"=\"+a[0]+\";\"+d}},a[b.DUP_X1]={hasBranch:!1,pops:2,pushes:3,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\",\"+b[1]+\"=\"+a[1]+\",\"+b[2]+\"=\"+a[0]+\";\"+d}},a[b.DUP_X2]={hasBranch:!1,pops:3,pushes:4,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[0]+\",\"+b[1]+\"=\"+a[2]+\",\"+b[2]+\"=\"+a[1]+\",\"+b[3]+\"=\"+a[0]+\";\"+d}},a[b.DUP2_X1]={hasBranch:!1,pops:3,pushes:5,emit:function(a,b,c,d){return\"var \"+b[0]+\"=\"+a[1]+\",\"+b[1]+\"=\"+a[0]+\",\"+b[2]+\"=\"+a[2]+\",\"+b[3]+\"=\"+a[1]+\",\"+b[4]+\"=\"+a[0]+\";\"+d}},a[b.NEW_FAST]={hasBranch:!1,pops:0,pushes:1,emit:function(a,b,c,d,e,f){var g=e.readUInt16BE(f+1);return\"var cr\"+c+\"=f.method.cls.constantPool.get(\"+g+\"),\"+b[0]+\"=(new cr\"+c+\".clsConstructor(t));\"+d}},a[b.NEWARRAY]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f,g){var h=e.readUInt8(f+1),i=\"[\"+opcodes.ArrayTypes[h],j=makeOnError(g,f);return\"\\nvar cls\"+c+\"=f.getLoader().getInitializedClass(t,'\"+i+\"');\\nif(\"+a[0]+\">=0){var \"+b[0]+\"=new (cls\"+c+\".getConstructor(t))(t,\"+a[0]+\");\"+d+\"\\n}else{\"+j+\"u.throwException(t,f,'Ljava/lang/NegativeArraySizeException;','Tried to init \"+i+\" array with length '+\"+a[0]+\");}\"}},a[b.ANEWARRAY_FAST]={hasBranch:!1,pops:1,pushes:1,emit:function(a,b,c,d,e,f,g){var h=e.readUInt16BE(f+1),i=(\"[\"+opcodes.ArrayTypes[h],makeOnError(g,f));return\"\\nvar cr\"+c+\"=f.method.cls.constantPool.get(\"+h+\");\\nif(\"+a[0]+\">=0){var \"+b[0]+\"=new cr\"+c+\".arrayClassConstructor(t,\"+a[0]+\");\"+d+\"\\n}else{\"+i+\"u.throwException(t,f,'Ljava/lang/NegativeArraySizeException;','Tried to init '+cr\"+c+\".arrayClass.getInternalName()+' array with length '+\"+a[0]+\");}\"}},a[b.NOP]={hasBranch:!1,pops:0,pushes:0,emit:function(a,b,c,d){return\"\"+d}},a[b.POP]={hasBranch:!1,pops:1,pushes:0,emit:function(a,b,c,d){return\"\"+d}},a[b.POP2]={hasBranch:!1,pops:2,pushes:0,emit:function(a,b,c,d){return\"\"+d}},a}();\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var __extends=this&&this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)},ClassData_1=__webpack_require__(21),ClassLock=__webpack_require__(24),classpath_1=__webpack_require__(26),enums_1=__webpack_require__(9),util=__webpack_require__(7),logging=__webpack_require__(16),assert=__webpack_require__(13),debug=logging.debug,ClassLocks=function(){function a(){this.locks={}}return a.prototype.tryLock=function(a,b,c){return\"undefined\"==typeof this.locks[a]&&(this.locks[a]=new ClassLock),this.locks[a].tryLock(b,c)},a.prototype.unlock=function(a,b){this.locks[a].unlock(b),delete this.locks[a]},a.prototype.getOwner=function(a){return this.locks[a]?this.locks[a].getOwner():null},a}(),ClassLoader=function(){function a(a){this.bootstrap=a,this.loadedClasses={},this.loadClassLocks=new ClassLocks}return a.prototype.getLoadedClassNames=function(){return Object.keys(this.loadedClasses)},a.prototype.addClass=function(a,b){this.loadedClasses[a]=b},a.prototype.getClass=function(a){return this.loadedClasses[a]},a.prototype.defineClass=function(a,b,c,d){try{var e=new ClassData_1.ReferenceClassData(c,d,this);return this.addClass(b,e),e}catch(e){return null===a?(logging.error(\"JVM initialization failed: \"+e),logging.error(e.stack)):a.throwNewException(\"Ljava/lang/ClassFormatError;\",e),null}},a.prototype.defineArrayClass=function(a){var b=new ClassData_1.ArrayClassData(util.get_component_type(a),this);return this.addClass(a,b),b},a.prototype.getLoadedClass=function(a){var b=this.loadedClasses[a];if(null!=b)return b;if(util.is_primitive_type(a))return this.bootstrap.getPrimitiveClass(a);if(util.is_array_type(a)){var c=this.getLoadedClass(util.get_component_type(a));if(null!=c){var d=c.getLoader();return d===this?this.defineArrayClass(a):(b=d.getLoadedClass(a),this.addClass(a,b),b)}}return null},a.prototype.getResolvedClass=function(a){var b=this.getLoadedClass(a);return null!==b&&(b.isResolved()||b.tryToResolve())?b:null},a.prototype.getInitializedClass=function(a,b){var c=this.getLoadedClass(b);return null!==c?c.isInitialized(a)||c.tryToInitialize()?c:null:c},a.prototype.loadClass=function(a,b,c,d){var e=this;void 0===d&&(d=!0);var f=this.getLoadedClass(b);f?setImmediate(function(){c(f)}):this.loadClassLocks.tryLock(b,a,c)&&(util.is_reference_type(b)?this._loadClass(a,b,function(a){e.loadClassLocks.unlock(b,a)},d):this.loadClass(a,util.get_component_type(b),function(a){null!=a&&e.loadClassLocks.unlock(b,e.getLoadedClass(b))},d))},a.prototype.resolveClasses=function(a,b,c){var d=this,e={};util.asyncForEach(b,function(b,c){d.resolveClass(a,b,function(a){null===a?c(\"Error resolving class: \"+b):(e[b]=a,c())})},function(a){c(a?null:e)})},a.prototype.resolveClass=function(a,b,c,d){void 0===d&&(d=!0),this.loadClass(a,b,function(b){null===b||b.isResolved()?setImmediate(function(){c(b)}):b.resolve(a,c,d)},d)},a.prototype.initializeClass=function(a,b,c,d){void 0===d&&(d=!0),this.resolveClass(a,b,function(b){null===b||b.isInitialized(a)?setImmediate(function(){c(b)}):b.initialize(a,c,d)},d)},a.prototype.throwClassNotFoundException=function(a,b,c){a.throwNewException(c?\"Ljava/lang/ClassNotFoundException;\":\"Ljava/lang/NoClassDefFoundError;\",\"Cannot load class: \"+util.ext_classname(b))},a}();exports.ClassLoader=ClassLoader;var BootstrapClassLoader=function(a){function b(b,c,d){var e=this;a.call(this,null),this.bootstrap=this,this.classpath=null,this.loadedPackages={},classpath_1.ClasspathFactory(b,c,function(a){e.classpath=a.reverse(),d()})}return __extends(b,a),b.prototype._registerLoadedClass=function(a,b){var c=a.slice(0,a.lastIndexOf(\"/\")),d=this.loadedPackages[c];d?d[0]!==b&&d.indexOf(b)===-1&&d.push(b):this.loadedPackages[c]=[b]},b.prototype.getPackages=function(){var a=this;return Object.keys(this.loadedPackages).map(function(b){return[b,a.loadedPackages[b].map(function(a){return a.getPath()})]})},b.prototype.getPrimitiveClass=function(a){var b=this.getClass(a);return null==b&&(b=new ClassData_1.PrimitiveClassData(a,this),this.addClass(a,b)),b},b.prototype._loadClass=function(a,b,c,d){var e=this;void 0===d&&(d=!0);var f,g=util.descriptor2typestr(b),h=this.classpath.length,i=[];a:for(var j=0;j<h;j++){var k=this.classpath[j];switch(k.hasClass(g)){case enums_1.TriState.INDETERMINATE:i.push(k);break;case enums_1.TriState.TRUE:i.push(k);break a}}util.asyncFind(i,function(a,b){a.loadClass(g,function(a,c){a?b(!1):(f=c,b(!0))})},function(h){if(h){var i=e.defineClass(a,b,f,null);null!==i&&e._registerLoadedClass(g,h),c(i)}else e.throwClassNotFoundException(a,b,d),c(null)})},b.prototype.getLoadedClassFiles=function(){var a=this.getLoadedClassNames();return a.filter(function(a){return util.is_reference_type(a)})},b.prototype.getLoaderObject=function(){return null},b.prototype.getClassPath=function(){for(var a=this.classpath.length,b=new Array(a),c=0;c<a;c++)b[c]=this.classpath[a-c-1].getPath();return b},b.prototype.getClassPathItems=function(){return this.classpath.slice(0)},b}(ClassLoader);exports.BootstrapClassLoader=BootstrapClassLoader;var CustomClassLoader=function(a){function b(b,c){a.call(this,b),this.loaderObj=c}return __extends(b,a),b.prototype._loadClass=function(a,b,c,d){var e=this;void 0===d&&(d=!0),this.loaderObj[\"loadClass(Ljava/lang/String;)Ljava/lang/Class;\"](a,[util.initString(this.bootstrap,util.ext_classname(b))],function(f,g){if(f)e.throwClassNotFoundException(a,b,d),c(null);else{var h=g.$cls;e.addClass(b,h),c(h)}})},b.prototype.getLoaderObject=function(){return this.loaderObj},b}(ClassLoader);exports.CustomClassLoader=CustomClassLoader;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function getRef(){return ref++}function extendClass(a,b){function c(){this.constructor=a}c.prototype=b.prototype,a.prototype=new c}var __extends=this&&this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)},util=__webpack_require__(7),ByteStream=__webpack_require__(22),ConstantPool=__webpack_require__(23),attributes=__webpack_require__(12),threading_1=__webpack_require__(14),logging=__webpack_require__(16),methods=__webpack_require__(11),enums=__webpack_require__(9),ClassLock=__webpack_require__(24),assert=__webpack_require__(13),gLong=__webpack_require__(8),StringOutputStream=__webpack_require__(17),ClassState=enums.ClassState,trace=logging.trace,debug=logging.debug,global=__webpack_require__(18),ref=1,injectedFields={\"Ljava/lang/invoke/MemberName;\":{vmtarget:[\"(thread: JVMThread, descriptor: string, args: any[], cb?: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void) => void\",\"null\"],vmindex:[\"number\",\"-1\"]},\"Ljava/lang/Object;\":{ref:[\"number\",\"getRef()\"],$monitor:[\"Monitor\",\"null\"]},\"Ljava/net/PlainSocketImpl;\":{$is_shutdown:[\"boolean\",\"false\"],$ws:[\"Interfaces.IWebsock\",\"null\"]},\"Ljava/lang/Class;\":{$cls:[\"ClassData\",\"null\"],signers:[\"JVMTypes.java_lang_Object[]\",\"null\"]},\"Ljava/lang/ClassLoader;\":{$loader:[\"ClassLoader\",\"new ClassLoader.CustomClassLoader(thread.getBsCl(), this);\"]},\"Ljava/lang/Thread;\":{$thread:[\"JVMThread\",\"thread ? new thread.constructor(thread.getJVM(), thread.getThreadPool(), this) : null\"]}},injectedMethods={\"Ljava/lang/Object;\":{getClass:[\"(): ClassData\",\"function() { return this.constructor.cls }\"],getMonitor:[\"(): Monitor\",\"function() {\\n  if (this.$monitor === null) {\\n    this.$monitor = new Monitor();\\n  }\\n  return this.$monitor;\\n}\"]},\"Ljava/lang/String;\":{toString:[\"(): string\",\"function() { return util.chars2jsStr(this['java/lang/String/value']); }\"]},\"Ljava/lang/Byte;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Byte/value']; }\"]},\"Ljava/lang/Character;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Character/value']; }\"]},\"Ljava/lang/Double;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Double/value']; }\"]},\"Ljava/lang/Float;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Float/value']; }\"]},\"Ljava/lang/Integer;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Integer/value']; }\"]},\"Ljava/lang/Long;\":{unbox:[\"(): Long\",\"function() { return this['java/lang/Long/value']; }\"]},\"Ljava/lang/Short;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Short/value']; }\"]},\"Ljava/lang/Boolean;\":{unbox:[\"(): number\",\"function() { return this['java/lang/Boolean/value']; }\"]},\"Ljava/lang/Void;\":{unbox:[\"(): number\",'function() { throw new Error(\"Cannot unbox a Void type.\"); }']},\"Ljava/lang/invoke/MethodType;\":{toString:[\"(): string\",'function() { return \"(\" + this[\\'java/lang/invoke/MethodType/ptypes\\'].array.map(function (type) { return type.$cls.getInternalName(); }).join(\"\") + \")\" + this[\\'java/lang/invoke/MethodType/rtype\\'].$cls.getInternalName(); }']}},injectedStaticMethods={\"Ljava/lang/Byte;\":{box:[\"(val: number): java_lang_Byte\",\"function(val) { var rv = new this(null); rv['java/lang/Byte/value'] = val; return rv; }\"]},\"Ljava/lang/Character;\":{box:[\"(val: number): java_lang_Character\",\"function(val) { var rv = new this(null); rv['java/lang/Character/value'] = val; return rv; }\"]},\"Ljava/lang/Double;\":{box:[\"(val: number): java_lang_Double\",\"function(val) { var rv = new this(null); rv['java/lang/Double/value'] = val; return rv; }\"]},\"Ljava/lang/Float;\":{box:[\"(val: number): java_lang_Float\",\"function(val) { var rv = new this(null); rv['java/lang/Float/value'] = val; return rv; }\"]},\"Ljava/lang/Integer;\":{box:[\"(val: number): java_lang_Integer\",\"function(val) { var rv = new this(null); rv['java/lang/Integer/value'] = val; return rv; }\"]},\"Ljava/lang/Long;\":{box:[\"(val: Long): java_lang_Long\",\"function(val) { var rv = new this(null); rv['java/lang/Long/value'] = val; return rv; }\"]},\"Ljava/lang/Short;\":{box:[\"(val: number): java_lang_Short\",\"function(val) { var rv = new this(null); rv['java/lang/Short/value'] = val; return rv; }\"]},\"Ljava/lang/Boolean;\":{box:[\"(val: number): java_lang_Boolean\",\"function(val) { var rv = new this(null); rv['java/lang/Boolean/value'] = val; return rv; }\"]},\"Ljava/lang/Void;\":{box:[\"(): java_lang_Void\",\"function() { return new this(null); }\"]}},ClassData=function(){function a(a){this.accessFlags=null,this.state=enums.ClassState.LOADED,this.jco=null,this.superClass=null,this.loader=a}return a.prototype.getExternalName=function(){return util.ext_classname(this.className)},a.prototype.getInternalName=function(){return this.className},a.prototype.getPackageName=function(){var a,b=this.getExternalName();for(a=b.length-1;a>=0&&\".\"!==b[a];a--);return a>=0?b.slice(0,a):\"\"},a.prototype.getLoader=function(){return this.loader},a.prototype.getSuperClass=function(){return this.superClass},a.prototype.getInterfaces=function(){return[]},a.prototype.getInjectedFields=function(){var a={};if(void 0!==injectedFields[this.getInternalName()]){var b=injectedFields[this.getInternalName()];Object.keys(b).forEach(function(c){a[c]=b[c][0]})}return a},a.prototype.getInjectedMethods=function(){var a={},b=this.getInternalName();if(\"[\"===b[0]&&(b=\"[\"),void 0!==injectedMethods[b]){var c=injectedMethods[b];Object.keys(c).forEach(function(b){a[b]=c[b][0]})}return a},a.prototype.getInjectedStaticMethods=function(){var a={},b=this.getInternalName();if(\"[\"===b[0]&&(b=\"[\"),void 0!==injectedStaticMethods[b]){var c=injectedStaticMethods[b];Object.keys(c).forEach(function(b){a[b]=c[b][0]})}return a},a.prototype.getClassObject=function(a){return null===this.jco&&(this.jco=new(a.getBsCl().getResolvedClass(\"Ljava/lang/Class;\").getConstructor(a))(a),this.jco.$cls=this,this.jco[\"java/lang/Class/classLoader\"]=this.getLoader().getLoaderObject()),this.jco},a.prototype.getProtectionDomain=function(){return null},a.prototype.getMethod=function(a){return null},a.prototype.getMethods=function(){return[]},a.prototype.getFields=function(){return[]},a.prototype.setState=function(a){this.state=a},a.prototype.getState=function(){if(this.state===ClassState.RESOLVED&&null===this.getMethod(\"<clinit>()V\")){var a=this.getSuperClass();null!==a&&a.getState()===ClassState.INITIALIZED&&(this.state=ClassState.INITIALIZED)}return this.state},a.prototype.isInitialized=function(a){return this.getState()===ClassState.INITIALIZED},a.prototype.isResolved=function(){return this.getState()!==ClassState.LOADED},a.prototype.isSubinterface=function(a){return!1},a.prototype.isSubclass=function(a){return this===a||null!==this.getSuperClass()&&this.getSuperClass().isSubclass(a)},a.prototype.resolve=function(a,b,c){throw void 0===c&&(c=!0),new Error(\"Unimplemented.\")},a.prototype.initialize=function(a,b,c){throw void 0===c&&(c=!0),new Error(\"Unimplemented.\")},a.prototype.outputInjectedMethods=function(a,b){var c=this.getInternalName();if(\"[\"===c[0]&&(c=\"[\"),void 0!==injectedMethods[c]){var d=injectedMethods[c];Object.keys(d).forEach(function(c){b.write(\"  \"+a+\".prototype.\"+c+\" = \"+d[c][1]+\";\\n\")})}if(void 0!==injectedStaticMethods[c]){var e=injectedStaticMethods[c];Object.keys(e).forEach(function(c){b.write(\"  \"+a+\".\"+c+\" = \"+e[c][1]+\";\\n\")})}},a}();exports.ClassData=ClassData;var PrimitiveClassData=function(a){function b(b,c){a.call(this,c),this.className=b,this.accessFlags=new util.Flags(1041),this.setState(ClassState.INITIALIZED)}return __extends(b,a),b.prototype.isCastable=function(a){return this.className===a.getInternalName()},b.prototype.boxClassName=function(){return util.boxClassName(this.className)},b.prototype.createWrapperObject=function(a,b){var c=this.boxClassName(),d=a.getBsCl().getInitializedClass(a,c),e=d.getConstructor(a),f=new e(a);return\"V\"!==c&&(f[util.descriptor2typestr(c)+\"/value\"]=b),f},b.prototype.tryToResolve=function(){return!0},b.prototype.tryToInitialize=function(){return!0},b.prototype.resolve=function(a,b,c){var d=this;void 0===c&&(c=!0),setImmediate(function(){return b(d)})},b}(ClassData);exports.PrimitiveClassData=PrimitiveClassData;var ArrayClassData=function(a){function b(b,c){a.call(this,c),this._constructor=null,this.className=\"[\"+b,this.accessFlags=new util.Flags(1041),this.componentClassName=b}return __extends(b,a),b.prototype.methodLookup=function(a){return this.superClass.methodLookup(a)},b.prototype.fieldLookup=function(a){return this.superClass.fieldLookup(a)},b.prototype.resolve=function(a,b,c){var d=this;return void 0===c&&(c=!0),this.isResolved()?void setImmediate(function(){return b(d)}):void util.asyncForEach([\"Ljava/lang/Object;\",this.componentClassName],function(b,c){d.loader.resolveClass(a,b,function(a){null!==a?c():c(\"Failed.\")})},function(a){a?b(null):(d.setResolved(d.loader.getResolvedClass(\"Ljava/lang/Object;\"),d.loader.getResolvedClass(d.componentClassName)),b(d))})},b.prototype.getComponentClass=function(){return this.componentClass},b.prototype.setResolved=function(a,b){this.superClass=a,this.componentClass=b,this.setState(ClassState.INITIALIZED)},b.prototype.tryToResolve=function(){var a=this.loader,b=a.getResolvedClass(\"Ljava/lang/Object;\"),c=a.getResolvedClass(this.componentClassName);return null!==b&&null!==c&&(this.setResolved(b,c),!0)},b.prototype.tryToInitialize=function(){return this.tryToResolve()},b.prototype.isCastable=function(a){if(!(a instanceof b)){if(a instanceof PrimitiveClassData)return!1;if(a.accessFlags.isInterface()){var c=a.getInternalName();return\"Ljava/lang/Cloneable;\"===c||\"Ljava/io/Serializable;\"===c}return\"Ljava/lang/Object;\"===a.getInternalName()}return this.getComponentClass().isCastable(a.getComponentClass())},b.prototype.initialize=function(a,b,c){void 0===c&&(c=!0),this.resolve(a,b,c)},b.prototype.getJSArrayConstructor=function(){if(!util.typedArraysSupported)return\"Array\";switch(this.componentClassName){case\"B\":return\"Int8Array\";case\"C\":return\"Uint16Array\";case\"S\":return\"Int16Array\";case\"I\":return\"Int32Array\";case\"F\":return\"Float32Array\";case\"D\":return\"Float64Array\";default:return\"Array\"}},b.prototype.getJSDefaultArrayElement=function(){switch(this.componentClassName[0]){case\"[\":return\"new (cls.getComponentClass().getConstructor())(thread, otherLengths)\";case\"L\":return\"null\";case\"J\":return\"gLongZero\";default:return\"0\"}},b.prototype._getSliceMethod=function(){var a=new StringOutputStream,b=this.getJSArrayConstructor();if(a.write(\"function(start, end) {\\n    var newObj = new this.constructor(null, 0);\\n\"),\"Array\"===b)a.write(\"    newObj.array = this.array.slice(start, end);\\n\");else{var c;switch(b){case\"Int8Array\":c=1;break;case\"Int16Array\":case\"Uint16Array\":c=2;break;case\"Int32Array\":case\"Float32Array\":c=4;break;case\"Float64Array\":c=8}a.write(\"    if (end === undefined) end = this.array.length;\\n      \"+(c>1?\"start *= \"+c+\";\\nend *= \"+c+\";\":\"\")+\"\\n      newObj.array = new \"+b+\"(this.array.buffer.slice(start, end));\\n\")}return a.write(\"    return newObj;\\n  }\"),a.flush()},b.prototype._constructConstructor=function(a){var b=new StringOutputStream,c=util.jvmName2JSName(this.getInternalName());b.write(\"extendClass(\"+c+\", superCls.getConstructor(thread));\\n  function \"+c+\"(thread, lengths) {\\n\"),this.superClass.outputInjectedFields(b),\"[\"!==this.componentClassName[0]?(b.write(\"    this.array = new \"+this.getJSArrayConstructor()+\"(lengths);\\n\"),\"Array\"===this.getJSArrayConstructor()&&b.write(\"    for (var i = 0; i < lengths; i++) {\\n      this.array[i] = \"+this.getJSDefaultArrayElement()+\";\\n    }\\n\")):b.write(\"    if (typeof lengths === 'number') {\\n        this.array = new \"+this.getJSArrayConstructor()+\"(lengths);\\n        for (var i = 0; i < length; i++) {\\n          this.array[i] = null;\\n        }\\n      } else {\\n        var length = lengths[0], otherLengths = lengths.length > 2 ? lengths.slice(1) : lengths[1];\\n        this.array = new \"+this.getJSArrayConstructor()+\"(length);\\n        for (var i = 0; i < length; i++) {\\n          this.array[i] = \"+this.getJSDefaultArrayElement()+\";\\n        }\\n      }\\n\"),b.write(\"  }\\n\\n  \"+c+\".prototype.slice = \"+this._getSliceMethod()+\";\\n  \"+c+\".cls = cls;\\n\"),this.outputInjectedMethods(c,b),b.write(\"\\n  return \"+c+\";\");var d=new Function(\"extendClass\",\"cls\",\"superCls\",\"gLongZero\",\"thread\",\"getRef\",\"util\",b.flush());return d(extendClass,this,this.superClass,gLong.ZERO,a,getRef,util)},b.prototype.getConstructor=function(a){return null===this._constructor&&(this._constructor=this._constructConstructor(a)),this._constructor},b}(ClassData);exports.ArrayClassData=ArrayClassData;var ReferenceClassData=function(a){function b(b,c,d,e){a.call(this,d),this.interfaceClasses=null,this.superClassRef=null,this.initLock=new ClassLock,this._constructor=null,this._fieldLookup={},this._objectFields=[],this._staticFields=[],this._methodLookup={},this._vmTable=[],this._uninheritedDefaultMethods=[],this._protectionDomain=c?c:null;var f=new ByteStream(b),g=0;if(3405691582!==f.getUint32())throw new Error(\"Magic number invalid\");if(this.minorVersion=f.getUint16(),this.majorVersion=f.getUint16(),!(45<=this.majorVersion&&this.majorVersion<=52))throw new Error(\"Major version invalid\");this.constantPool=new ConstantPool.ConstantPool,this.constantPool.parse(f,e),this.accessFlags=new util.Flags(f.getUint16()),this.className=this.constantPool.get(f.getUint16()).name;var h=f.getUint16();0!==h&&(this.superClassRef=this.constantPool.get(h));var i=f.getUint16();for(this.interfaceRefs=new Array(i),g=0;g<i;++g)this.interfaceRefs[g]=this.constantPool.get(f.getUint16());var j=f.getUint16();for(this.fields=new Array(j),g=0;g<j;++g)this.fields[g]=new methods.Field(this,this.constantPool,g,f);var k=f.getUint16();for(this.methods=new Array(k),g=0;g<k;g++){var l=new methods.Method(this,this.constantPool,g,f);this.methods[g]=l}if(this.attrs=attributes.makeAttributes(f,this.constantPool),f.hasBytes())throw\"Leftover bytes in classfile: \"+f}return __extends(b,a),b.prototype.getSuperClassReference=function(){return this.superClassRef},b.prototype.getInterfaceClassReferences=function(){return this.interfaceRefs.slice(0)},b.prototype.getInterfaces=function(){return this.interfaceClasses},b.prototype.getFields=function(){return this.fields},b.prototype.getVMTable=function(){return this._vmTable},b.prototype.getVMIndexForMethod=function(a){return this._vmTable.indexOf(this.methodLookup(a.signature))},b.prototype.getMethodFromVMIndex=function(a){return void 0!==this._vmTable[a]?this._vmTable[a]:null},b.prototype.getVMIndexForField=function(a){return a.accessFlags.isStatic()?this._staticFields.indexOf(a):this._objectFields.indexOf(a)},b.prototype.getStaticFieldFromVMIndex=function(a){var b=this._staticFields[a];return void 0!==b?b:null},b.prototype.getObjectFieldFromVMIndex=function(a){var b=this._objectFields[a];return void 0!==b?b:null},b.prototype.getFieldFromSlot=function(a){return this.fields[a]},b.prototype.getMethodFromSlot=function(a){return this.methods[a]},b.prototype.getMethod=function(a){var b=this._methodLookup[a];return b.cls===this?b:null},b.prototype.getSpecificMethod=function(a,b){if(this.getInternalName()===a)return this.getMethod(b);var c,d=this.interfaceClasses.slice(0);this.superClass&&d.push(this.superClass);for(var e=0;e<d.length;e++)if(null!==(c=d[e].getSpecificMethod(a,b)))return c;return null},b.prototype.getMethods=function(){return this.methods},b.prototype.getUninheritedDefaultMethods=function(){return this._uninheritedDefaultMethods},b.prototype.getProtectionDomain=function(){return this._protectionDomain},b.prototype._resolveMethods=function(){var a=this;null!==this.superClass&&(this._vmTable=this._vmTable.concat(this.superClass._vmTable),Object.keys(this.superClass._methodLookup).forEach(function(b){a._methodLookup[b]=a.superClass._methodLookup[b]})),this.methods.forEach(function(b){var c=a._methodLookup[b.signature];b.accessFlags.isStatic()||\"<init>\"===b.name||(void 0===c?a._vmTable.push(b):a._vmTable[a._vmTable.indexOf(c)]=b),a._methodLookup[b.signature]=b}),this.interfaceClasses.forEach(function(b){Object.keys(b._methodLookup).forEach(function(c){var d=b._methodLookup[c];void 0===a._methodLookup[c]?(d.accessFlags.isStatic()||a._vmTable.push(d),a._methodLookup[c]=d):d.isDefault()&&a._uninheritedDefaultMethods.push(d)})})},b.prototype._resolveFields=function(){var a=this;null!==this.superClass&&(this._objectFields=this._objectFields.concat(this.superClass._objectFields),Object.keys(this.superClass._fieldLookup).forEach(function(b){a._fieldLookup[b]=a.superClass._fieldLookup[b]})),this.interfaceClasses.forEach(function(b){Object.keys(b._fieldLookup).forEach(function(c){var d=b._fieldLookup[c];a._fieldLookup[c]=d})}),this.fields.forEach(function(b){a._fieldLookup[b.name]=b,b.accessFlags.isStatic()?a._staticFields.push(b):a._objectFields.push(b)})},b.prototype.methodLookup=function(a){var b=this._methodLookup[a];return void 0!==b?b:null},b.prototype.signaturePolymorphicAwareMethodLookup=function(a){var b;if(null!==(b=this.methodLookup(a)))return b;if(\"Ljava/lang/invoke/MethodHandle;\"===this.className){var c=a.slice(0,a.indexOf(\"(\"))+\"([Ljava/lang/Object;)Ljava/lang/Object;\",b=this._methodLookup[c];if(void 0!==b&&b.accessFlags.isNative()&&b.accessFlags.isVarArgs()&&b.cls===this)return b}else if(null!==this.superClass)return this.superClass.signaturePolymorphicAwareMethodLookup(a);return null},b.prototype.fieldLookup=function(a){var b=this._fieldLookup[a];return void 0!==b?b:null},b.prototype.getAttribute=function(a){for(var b=this.attrs,c=0;c<b.length;c++){var d=b[c];if(d.getName()===a)return d}return null},b.prototype.getAttributes=function(a){for(var b=this.attrs,c=[],d=0;d<b.length;d++){var e=b[d];e.getName()===a&&c.push(e)}return c},b.prototype.getBootstrapMethod=function(a){var b=this.getAttribute(\"BootstrapMethods\");return b.bootstrapMethods[a]},b.prototype._getInitialStaticFieldValue=function(a,b){var c=this.fieldLookup(b);if(null!==c&&c.accessFlags.isStatic()){var d=c.getAttribute(\"ConstantValue\");if(null===d)return util.initialValue(c.rawDescriptor);switch(d.value.getType()){case enums.ConstantPoolItemType.STRING:var e=d.value;return null===e.value&&(e.value=a.getJVM().internString(e.stringValue)),e.value;default:return d.value.value}}},b.prototype.setResolved=function(a,b){this.superClass=a,this.interfaceClasses=b,this._resolveMethods(),this._resolveFields(),this.setState(ClassState.RESOLVED)},b.prototype.tryToResolve=function(){if(this.getState()===ClassState.LOADED){var a,b,c=this.loader,d=null!==this.superClassRef?this.interfaceRefs.concat(this.superClassRef):this.interfaceRefs,e=[];for(a=0;a<d.length;a++){if(b=d[a],!b.tryResolve(c))return!1;e.push(b.cls)}this.setResolved(null!==this.superClassRef?e.pop():null,e)}return!0},b.prototype.tryToInitialize=function(){if(this.getState()===ClassState.INITIALIZED)return!0;if(this.getState()===ClassState.RESOLVED||this.tryToResolve()){if(null!==this.superClass&&!this.superClass.tryToInitialize())return!1;var a=this.getMethod(\"<clinit>()V\");return null===a&&(this.setState(ClassState.INITIALIZED),!0)}return!1},b.prototype.isCastable=function(a){return a instanceof b&&(this.accessFlags.isInterface()?a.accessFlags.isInterface()?this.isSubinterface(a):a.accessFlags.isInterface()?void 0:\"Ljava/lang/Object;\"===a.getInternalName():a.accessFlags.isInterface()?this.isSubinterface(a):this.isSubclass(a))},b.prototype.isSubinterface=function(a){if(this.className===a.getInternalName())return!0;for(var b=this.getInterfaces(),c=0;c<b.length;c++){var d=b[c];if(d.isSubinterface(a))return!0}return null!=this.getSuperClass()&&this.getSuperClass().isSubinterface(a)},b.prototype.initialize=function(a,b,c){var d=this;void 0===c&&(c=!0),this.isResolved()?this.isInitialized(a)?setImmediate(function(){b(d)}):this.initLock.tryLock(a,b)&&(null!=this.superClass?this.superClass.initialize(a,function(b){null==b?d.initLock.unlock(null):d._initialize(a,function(a){d.initLock.unlock(a)})},c):this._initialize(a,function(a){d.initLock.unlock(a)})):this.resolve(a,function(e){null!==e?d.initialize(a,b,c):b(e)},c)},b.prototype._initialize=function(a,b){var c=this,d=this.getConstructor(a);void 0!==d[\"<clinit>()V\"]?d[\"<clinit>()V\"](a,null,function(d){d?(c.setState(enums.ClassState.RESOLVED),d.getClass().isCastable(a.getBsCl().getResolvedClass(\"Ljava/lang/Error;\"))?(a.throwException(d),b(null)):a.getBsCl().initializeClass(a,\"Ljava/lang/ExceptionInInitializerError;\",function(c){if(null==c)b(null);else{var e=c.getConstructor(a),f=new e(a);f[\"<init>(Ljava/lang/Throwable;)V\"](a,[d],function(c){a.throwException(f),b(null)})}})):(c.setState(enums.ClassState.INITIALIZED),b(c))}):(this.setState(enums.ClassState.INITIALIZED),b(this))},b.prototype.isInitialized=function(a){return this.getState()===ClassState.INITIALIZED||this.initLock.getOwner()===a},b.prototype.resolve=function(a,b,c){var d=this;void 0===c&&(c=!0);var e=this.interfaceRefs.slice(0);null!==this.superClassRef&&e.push(this.superClassRef),e=e.filter(function(a){return!a.isResolved()}),util.asyncForEach(e,function(b,e){b.resolve(a,d.loader,d,function(a){a?e():e(\"Failed.\")},c)},function(a){a?b(null):(d.setResolved(null!==d.superClassRef?d.superClassRef.cls:null,d.interfaceRefs.map(function(a){return a.cls})),b(d))})},b.prototype.getMirandaAndDefaultMethods=function(){var a=this,b=null!==this.superClass?this.superClass.getVMTable():[];return this.getVMTable().slice(b.length).filter(function(b){return b.cls!==a})},b.prototype.outputInjectedFields=function(a){null!==this.superClass&&this.superClass.outputInjectedFields(a);var b=injectedFields[this.getInternalName()];void 0!==b&&Object.keys(b).forEach(function(c){a.write(\"this.\"+c+\" = \"+b[c][1]+\";\\n\")})},b.prototype._constructConstructor=function(a){var b=util.jvmName2JSName(this.getInternalName()),c=new StringOutputStream;c.write(\"if (cls.superClass !== null) {\\n    extendClass(\"+b+\", cls.superClass.getConstructor(thread));\\n  }\\n  function \"+b+\"(thread) {\\n\"),this.outputInjectedFields(c),this._objectFields.forEach(function(a){return a.outputJavaScriptField(b,c)}),c.write(\"  }\\n  \"+b+\".cls = cls;\\n\"),this.outputInjectedMethods(b,c),this._staticFields.forEach(function(a){return a.outputJavaScriptField(b,c)}),this.getMethods().forEach(function(a){return a.outputJavaScriptFunction(b,c)}),this.getMirandaAndDefaultMethods().forEach(function(a){return a.outputJavaScriptFunction(b,c)}),this.getUninheritedDefaultMethods().forEach(function(a){return a.outputJavaScriptFunction(b,c,!0)}),c.write(\"  return \"+b+\";\");var d=c.flush(),e=new Function(\"extendClass\",\"cls\",\"InternalStackFrame\",\"NativeStackFrame\",\"BytecodeStackFrame\",\"gLongZero\",\"ClassLoader\",\"Monitor\",\"thread\",\"getRef\",\"util\",d);return e(extendClass,this,threading_1.InternalStackFrame,threading_1.NativeStackFrame,threading_1.BytecodeStackFrame,gLong.ZERO,__webpack_require__(20),__webpack_require__(25),a,getRef,util)},b.prototype.getConstructor=function(a){return null==this._constructor&&(this._constructor=this._constructConstructor(a)),this._constructor},b}(ClassData);exports.ReferenceClassData=ReferenceClassData;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var gLong=__webpack_require__(8),assert=__webpack_require__(13),ByteStream=function(){function a(a){this.buffer=a,this._index=0}return a.prototype.incIndex=function(a){var b=this._index;return this._index+=a,b},a.prototype.rewind=function(){this._index=0},a.prototype.seek=function(a){this._index=a},a.prototype.pos=function(){return this._index},a.prototype.skip=function(a){this._index+=a},a.prototype.hasBytes=function(){return this._index<this.buffer.length},a.prototype.getFloat=function(){return this.buffer.readFloatBE(this.incIndex(4))},a.prototype.getDouble=function(){return this.buffer.readDoubleBE(this.incIndex(8))},a.prototype.getUint=function(a){switch(a){case 1:return this.getUint8();case 2:return this.getUint16();case 4:return this.getUint32();default:throw new Error(\"Invalid byte count for getUint: \"+a)}},a.prototype.getInt=function(a){switch(a){case 1:return this.getInt8();case 2:return this.getInt16();case 4:return this.getInt32();default:throw new Error(\"Invalid byte count for getUint: \"+a)}},a.prototype.getUint8=function(){return this.buffer.readUInt8(this.incIndex(1))},a.prototype.getUint16=function(){return this.buffer.readUInt16BE(this.incIndex(2))},a.prototype.getUint32=function(){return this.buffer.readUInt32BE(this.incIndex(4))},a.prototype.getInt8=function(){return this.buffer.readInt8(this.incIndex(1))},a.prototype.getInt16=function(){return this.buffer.readInt16BE(this.incIndex(2))},a.prototype.getInt32=function(){return this.buffer.readInt32BE(this.incIndex(4))},a.prototype.getInt64=function(){var a=this.getUint32(),b=this.getUint32();return gLong.fromBits(b,a)},a.prototype.read=function(a){var b=this.buffer.slice(this._index,this._index+a);return this._index+=a,b},a.prototype.peek=function(){return this.buffer.readUInt8(this._index)},a.prototype.size=function(){return this.buffer.length-this._index},a.prototype.slice=function(b){var c=new a(this.buffer.slice(this._index,this._index+b));return this._index+=b,c},a.prototype.getBuffer=function(){return this.buffer},a}();module.exports=ByteStream;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var util=__webpack_require__(7),enums=__webpack_require__(9),assert=__webpack_require__(13),CP_CLASSES={},ConstUTF8=function(){function a(a){this.value=this.bytes2str(a)}return a.prototype.bytes2str=function(a){for(var b,c,d,e,f=0,g=\"\";f<a.length;)d=255&a.readUInt8(f++),d<=127?e=d:d<=223?(b=a.readUInt8(f++),e=((31&d)<<6)+(63&b)):(b=a.readUInt8(f++),c=a.readUInt8(f++),e=((15&d)<<12)+((63&b)<<6)+(63&c)),g+=String.fromCharCode(e);return g},a.prototype.getType=function(){return enums.ConstantPoolItemType.UTF8},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){var c=a.getUint16();return new this(a.read(c))},a.size=1,a.infoByteSize=0,a}();exports.ConstUTF8=ConstUTF8,CP_CLASSES[enums.ConstantPoolItemType.UTF8]=ConstUTF8;var ConstInt32=function(){function a(a){this.value=a}return a.prototype.getType=function(){return enums.ConstantPoolItemType.INTEGER},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){return new this(a.getInt32())},a.size=1,a.infoByteSize=4,a}();exports.ConstInt32=ConstInt32,CP_CLASSES[enums.ConstantPoolItemType.INTEGER]=ConstInt32;var ConstFloat=function(){function a(a){this.value=a}return a.prototype.getType=function(){return enums.ConstantPoolItemType.FLOAT},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){return new this(a.getFloat())},a.size=1,a.infoByteSize=4,a}();exports.ConstFloat=ConstFloat,CP_CLASSES[enums.ConstantPoolItemType.FLOAT]=ConstFloat;var ConstLong=function(){function a(a){this.value=a}return a.prototype.getType=function(){return enums.ConstantPoolItemType.LONG},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){return new this(a.getInt64())},a.size=2,a.infoByteSize=8,a}();exports.ConstLong=ConstLong,CP_CLASSES[enums.ConstantPoolItemType.LONG]=ConstLong;var ConstDouble=function(){function a(a){this.value=a}return a.prototype.getType=function(){return enums.ConstantPoolItemType.DOUBLE},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){return new this(a.getDouble())},a.size=2,a.infoByteSize=8,a}();exports.ConstDouble=ConstDouble,CP_CLASSES[enums.ConstantPoolItemType.DOUBLE]=ConstDouble;var ClassReference=function(){function a(a){this.cls=null,this.clsConstructor=null,this.arrayClass=null,this.arrayClassConstructor=null,this.name=a}return a.prototype.tryResolve=function(a){return null===this.cls&&(this.cls=a.getResolvedClass(this.name)),null!==this.cls},a.prototype.resolve=function(a,b,c,d,e){var f=this;if(void 0===e&&(e=!0),null!==a){var g=a.currentMethod();if(null!==g&&this.name===g.cls.getInternalName())return this.setResolved(a,a.currentMethod().cls),d(!0)}b.resolveClass(a,this.name,function(b){f.setResolved(a,b),d(null!==b)},e)},a.prototype.setResolved=function(a,b){this.cls=b,null!==b&&(this.clsConstructor=b.getConstructor(a))},a.prototype.getType=function(){return enums.ConstantPoolItemType.CLASS},a.prototype.getConstant=function(a){return this.cls.getClassObject(a)},a.prototype.isResolved=function(){return null!==this.cls},a.fromBytes=function(a,b){var c=a.getUint16(),d=b.get(c);return new this(util.typestr2descriptor(d.value))},a.size=1,a.infoByteSize=2,a}();exports.ClassReference=ClassReference,CP_CLASSES[enums.ConstantPoolItemType.CLASS]=ClassReference;var NameAndTypeInfo=function(){function a(a,b){this.name=a,this.descriptor=b}return a.prototype.getType=function(){return enums.ConstantPoolItemType.NAME_AND_TYPE},a.prototype.isResolved=function(){return!0},a.fromBytes=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=b.get(c),f=b.get(d);return new this(e.value,f.value)},a.size=1,a.infoByteSize=4,a}();exports.NameAndTypeInfo=NameAndTypeInfo,CP_CLASSES[enums.ConstantPoolItemType.NAME_AND_TYPE]=NameAndTypeInfo;var ConstString=function(){function a(a){this.value=null,this.stringValue=a}return a.prototype.getType=function(){return enums.ConstantPoolItemType.STRING},a.prototype.resolve=function(a,b,c,d){this.value=a.getJVM().internString(this.stringValue),setImmediate(function(){return d(!0)})},a.prototype.getConstant=function(a){return this.value},a.prototype.isResolved=function(){return null!==this.value},a.fromBytes=function(a,b){var c=a.getUint16(),d=b.get(c);return new this(d.value)},a.size=1,a.infoByteSize=2,a}();exports.ConstString=ConstString,CP_CLASSES[enums.ConstantPoolItemType.STRING]=ConstString;var MethodType=function(){function a(a){this.methodType=null,this.descriptor=a}return a.prototype.resolve=function(a,b,c,d){var e=this;util.createMethodType(a,b,this.descriptor,function(b,c){b?(a.throwException(b),d(!1)):(e.methodType=c,d(!0))})},a.prototype.getConstant=function(a){return this.methodType},a.prototype.getType=function(){return enums.ConstantPoolItemType.METHOD_TYPE},a.prototype.isResolved=function(){return null!==this.methodType},a.fromBytes=function(a,b){var c=a.getUint16(),d=b.get(c);return new this(d.value)},a.size=1,a.infoByteSize=2,a}();exports.MethodType=MethodType,CP_CLASSES[enums.ConstantPoolItemType.METHOD_TYPE]=MethodType;var MethodReference=function(){function a(a,b){this.method=null,this.fullSignature=null,this.paramWordSize=-1,this.memberName=null,this.appendix=null,this.jsConstructor=null,this.classInfo=a,this.nameAndTypeInfo=b,this.signature=this.nameAndTypeInfo.name+this.nameAndTypeInfo.descriptor}return a.prototype.getType=function(){return enums.ConstantPoolItemType.METHODREF},a.prototype.hasAccess=function(a,b,c){var d=this.method,e=b.method.cls;return d.accessFlags.isStatic()!==c?(a.throwNewException(\"Ljava/lang/IncompatibleClassChangeError;\",\"Method \"+d.name+\" from class \"+d.cls.getExternalName()+\" is \"+(c?\"not \":\"\")+\"static.\"),b.returnToThreadLoop=!0,!1):!!util.checkAccess(e,d.cls,d.accessFlags)||(a.throwNewException(\"Ljava/lang/IllegalAccessError;\",e.getExternalName()+\" cannot access \"+d.cls.getExternalName()+\".\"+d.name),b.returnToThreadLoop=!0,!1)},a.prototype.resolveMemberName=function(a,b,c,d,e){var f=this,g=b.getBsCl().getInitializedClass(b,\"Ljava/lang/invoke/MethodHandleNatives;\").getConstructor(b),h=new(b.getBsCl().getInitializedClass(b,\"[Ljava/lang/Object;\").getConstructor(b))(b,1);util.createMethodType(b,c,this.nameAndTypeInfo.descriptor,function(a,c){a?(b.throwException(a),e(!1)):g[\"java/lang/invoke/MethodHandleNatives/linkMethod(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;\"](b,[d.getClassObject(b),enums.MethodHandleReferenceKind.INVOKEVIRTUAL,f.classInfo.cls.getClassObject(b),b.getJVM().internString(f.nameAndTypeInfo.name),c,h],function(a,c){null!==a?(b.throwException(a),e(!1)):(f.appendix=h.array[0],f.memberName=c,e(!0))})})},a.prototype.resolve=function(a,b,c,d,e){var f=this;if(void 0===e&&(e=!0),this.classInfo.isResolved()){var g=this.classInfo.cls,h=g.methodLookup(this.signature);if(null===h&&util.is_reference_type(g.getInternalName())&&(h=g.signaturePolymorphicAwareMethodLookup(this.signature),null!==h&&(\"invoke\"===h.name||\"invokeExact\"===h.name)))return this.resolveMemberName(h,a,b,c,function(b){b===!0?f.setResolved(a,h):a.throwNewException(\"Ljava/lang/NoSuchMethodError;\",\"Method \"+f.signature+\" does not exist in class \"+f.classInfo.cls.getExternalName()+\".\"),d(b)});null!==h?(this.setResolved(a,h),d(!0)):(a.throwNewException(\"Ljava/lang/NoSuchMethodError;\",\"Method \"+this.signature+\" does not exist in class \"+this.classInfo.cls.getExternalName()+\".\"),d(!1))}else this.classInfo.resolve(a,b,c,function(g){g?f.resolve(a,b,c,d,e):d(!1)},e)},a.prototype.setResolved=function(a,b){this.method=b,this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor),this.fullSignature=this.method.fullSignature,this.jsConstructor=this.method.cls.getConstructor(a)},a.prototype.isResolved=function(){return null!==this.method},a.prototype.getParamWordSize=function(){return this.paramWordSize===-1&&(this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor)),this.paramWordSize},a.fromBytes=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=b.get(c),f=b.get(d);return new this(e,f)},a.size=1,a.infoByteSize=4,a}();exports.MethodReference=MethodReference,CP_CLASSES[enums.ConstantPoolItemType.METHODREF]=MethodReference;var InterfaceMethodReference=function(){function a(a,b){this.fullSignature=null,this.method=null,this.paramWordSize=-1,this.jsConstructor=null,this.classInfo=a,this.nameAndTypeInfo=b,this.signature=this.nameAndTypeInfo.name+this.nameAndTypeInfo.descriptor}return a.prototype.getType=function(){return enums.ConstantPoolItemType.INTERFACE_METHODREF},a.prototype.hasAccess=function(a,b,c){var d=this.method,e=b.method.cls;return d.accessFlags.isStatic()!==c?(a.throwNewException(\"Ljava/lang/IncompatibleClassChangeError;\",\"Method \"+d.name+\" from class \"+d.cls.getExternalName()+\" is \"+(c?\"not \":\"\")+\"static.\"),b.returnToThreadLoop=!0,!1):!!util.checkAccess(e,d.cls,d.accessFlags)||(a.throwNewException(\"Ljava/lang/IllegalAccessError;\",e.getExternalName()+\" cannot access \"+d.cls.getExternalName()+\".\"+d.name),b.returnToThreadLoop=!0,!1)},a.prototype.resolve=function(a,b,c,d,e){var f=this;if(void 0===e&&(e=!0),this.classInfo.isResolved()){var g=this.classInfo.cls,h=g.methodLookup(this.signature);this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor),null!==h?(this.setResolved(a,h),d(!0)):(a.throwNewException(\"Ljava/lang/NoSuchMethodError;\",\"Method \"+this.signature+\" does not exist in class \"+this.classInfo.cls.getExternalName()+\".\"),d(!1))}else this.classInfo.resolve(a,b,c,function(g){g?f.resolve(a,b,c,d,e):d(!1)},e)},a.prototype.setResolved=function(a,b){this.method=b,this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor),this.fullSignature=this.method.fullSignature,this.jsConstructor=this.method.cls.getConstructor(a)},a.prototype.getParamWordSize=function(){return this.paramWordSize===-1&&(this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor)),this.paramWordSize},a.prototype.isResolved=function(){return null!==this.method},a.fromBytes=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=b.get(c),f=b.get(d);return new this(e,f)},a.size=1,a.infoByteSize=4,a}();exports.InterfaceMethodReference=InterfaceMethodReference,CP_CLASSES[enums.ConstantPoolItemType.INTERFACE_METHODREF]=InterfaceMethodReference;var FieldReference=function(){function a(a,b){this.field=null,this.fullFieldName=null,this.fieldOwnerConstructor=null,this.classInfo=a,this.nameAndTypeInfo=b}return a.prototype.getType=function(){return enums.ConstantPoolItemType.FIELDREF},a.prototype.hasAccess=function(a,b,c){var d=this.field,e=b.method.cls;return d.accessFlags.isStatic()!==c?(a.throwNewException(\"Ljava/lang/IncompatibleClassChangeError;\",\"Field \"+name+\" from class \"+d.cls.getExternalName()+\" is \"+(c?\"not \":\"\")+\"static.\"),b.returnToThreadLoop=!0,!1):!!util.checkAccess(e,d.cls,d.accessFlags)||(a.throwNewException(\"Ljava/lang/IllegalAccessError;\",e.getExternalName()+\" cannot access \"+d.cls.getExternalName()+\".\"+name),b.returnToThreadLoop=!0,!1)},a.prototype.resolve=function(a,b,c,d,e){var f=this;if(void 0===e&&(e=!0),this.classInfo.isResolved()){var g=this.classInfo.cls,h=g.fieldLookup(this.nameAndTypeInfo.name);null!==h?(this.fullFieldName=util.descriptor2typestr(h.cls.getInternalName())+\"/\"+h.name,this.field=h,d(!0)):(a.throwNewException(\"Ljava/lang/NoSuchFieldError;\",\"Field \"+this.nameAndTypeInfo.name+\" does not exist in class \"+this.classInfo.cls.getExternalName()+\".\"),d(!1))}else this.classInfo.resolve(a,b,c,function(g){g?f.resolve(a,b,c,d,e):d(!1)},e)},a.prototype.isResolved=function(){return null!==this.field},a.fromBytes=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=b.get(c),f=b.get(d);return new this(e,f)},a.size=1,a.infoByteSize=4,a}();exports.FieldReference=FieldReference,CP_CLASSES[enums.ConstantPoolItemType.FIELDREF]=FieldReference;var InvokeDynamic=function(){function a(a,b){this.callSiteObjects={},this.methodType=null,this.bootstrapMethodAttrIndex=a,this.nameAndTypeInfo=b,this.paramWordSize=util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor)}return a.prototype.getType=function(){return enums.ConstantPoolItemType.INVOKE_DYNAMIC},a.prototype.isResolved=function(){return null!==this.methodType},a.prototype.resolve=function(a,b,c,d){var e=this;util.createMethodType(a,b,this.nameAndTypeInfo.descriptor,function(b,c){b?(a.throwException(b),d(!1)):(e.methodType=c,d(!0))})},a.prototype.getCallSiteObject=function(a){var b=this.callSiteObjects[a];return b?b:null},a.prototype.constructCallSiteObject=function(a,b,c,d,e,f){function g(){var c,d,e=i[1],f=new(a.getBsCl().getInitializedClass(a,\"[Ljava/lang/Object;\").getConstructor(a))(a,e.length),g=f.array;for(c=0;c<e.length;c++)switch(d=e[c],d.getType()){case enums.ConstantPoolItemType.CLASS:g[c]=d.cls.getClassObject(a);break;case enums.ConstantPoolItemType.METHOD_HANDLE:g[c]=d.methodHandle;break;case enums.ConstantPoolItemType.METHOD_TYPE:g[c]=d.methodType;break;case enums.ConstantPoolItemType.STRING:g[c]=d.value;break;case enums.ConstantPoolItemType.UTF8:g[c]=a.getJVM().internString(d.value);break;case enums.ConstantPoolItemType.INTEGER:g[c]=b.getInitializedClass(a,\"I\").createWrapperObject(a,d.value);break;case enums.ConstantPoolItemType.LONG:g[c]=b.getInitializedClass(a,\"J\").createWrapperObject(a,d.value);break;case enums.ConstantPoolItemType.FLOAT:g[c]=b.getInitializedClass(a,\"F\").createWrapperObject(a,d.value);break;case enums.ConstantPoolItemType.DOUBLE:g[c]=b.getInitializedClass(a,\"D\").createWrapperObject(a,d.value)}return f}var h=this;void 0===f&&(f=!0);var i=c.getBootstrapMethod(this.bootstrapMethodAttrIndex),j=i[1].concat(i[0],this).filter(function(a){return!a.isResolved()});if(j.length>0)return util.asyncForEach(j,function(d,e){d.resolve(a,b,c,function(a){a?e():e(\"Failed.\")},f)},function(g){g?e(!1):h.constructCallSiteObject(a,b,c,d,e,f)});var k=a.getJVM().internString(this.nameAndTypeInfo.name),l=new(b.getInitializedClass(a,\"[Ljava/lang/Object;\").getConstructor(a))(a,1),m=g(),n=b.getInitializedClass(a,\"Ljava/lang/invoke/MethodHandleNatives;\").getConstructor(a);n[\"java/lang/invoke/MethodHandleNatives/linkCallSite(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;\"](a,[c.getClassObject(a),i[0].methodHandle,k,this.methodType,m,l],function(b,c){b?(a.throwException(b),e(!1)):(h.setResolved(d,[c,l.array[0]]),e(!0))})},a.prototype.setResolved=function(a,b){void 0===this.callSiteObjects[a]&&(this.callSiteObjects[a]=b)},a.fromBytes=function(a,b){var c=a.getUint16(),d=a.getUint16(),e=b.get(d);return new this(c,e)},a.size=1,a.infoByteSize=4,a}();exports.InvokeDynamic=InvokeDynamic,CP_CLASSES[enums.ConstantPoolItemType.INVOKE_DYNAMIC]=InvokeDynamic;var MethodHandle=function(){function a(a,b){this.methodHandle=null,this.reference=a,this.referenceType=b}return a.prototype.getType=function(){return enums.ConstantPoolItemType.METHOD_HANDLE},a.prototype.isResolved=function(){return null!==this.methodHandle},a.prototype.getConstant=function(a){return this.methodHandle},a.prototype.resolve=function(a,b,c,d,e){var f=this;return this.reference.isResolved()?void this.constructMethodHandleType(a,b,function(e){if(null===e)d(!1);else{var g=b.getInitializedClass(a,\"Ljava/lang/invoke/MethodHandleNatives;\").getConstructor(a);g[\"linkMethodHandleConstant(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;\"](a,[c.getClassObject(a),f.referenceType,f.getDefiningClassObj(a),a.getJVM().internString(f.reference.nameAndTypeInfo.name),e],function(b,c){b?(a.throwException(b),d(!1)):(f.methodHandle=c,d(!0))})}}):this.reference.resolve(a,b,c,function(g){g?f.resolve(a,b,c,d,e):d(!1)},e)},a.prototype.getDefiningClassObj=function(a){return this.reference.getType()===enums.ConstantPoolItemType.FIELDREF?this.reference.field.cls.getClassObject(a):this.reference.method.cls.getClassObject(a)},a.prototype.constructMethodHandleType=function(a,b,c){if(this.reference.getType()===enums.ConstantPoolItemType.FIELDREF){var d=this.reference.nameAndTypeInfo.descriptor;b.resolveClass(a,d,function(b){c(null!==b?b.getClassObject(a):null)})}else util.createMethodType(a,b,this.reference.nameAndTypeInfo.descriptor,function(b,d){b?(a.throwException(b),c(null)):c(d)})},a.fromBytes=function(a,b){var c=a.getUint8(),d=a.getUint16(),e=b.get(d);return new this(e,c)},a.size=1,a.infoByteSize=3,a}();exports.MethodHandle=MethodHandle,CP_CLASSES[enums.ConstantPoolItemType.METHOD_HANDLE]=MethodHandle;var CONSTANT_POOL_TIER=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];!function(a){a.forEach(function(a,b){a.forEach(function(a){CONSTANT_POOL_TIER[a]=b})})}([[enums.ConstantPoolItemType.UTF8,enums.ConstantPoolItemType.INTEGER,enums.ConstantPoolItemType.FLOAT,enums.ConstantPoolItemType.LONG,enums.ConstantPoolItemType.DOUBLE],[enums.ConstantPoolItemType.CLASS,enums.ConstantPoolItemType.STRING,enums.ConstantPoolItemType.NAME_AND_TYPE,enums.ConstantPoolItemType.METHOD_TYPE],[enums.ConstantPoolItemType.FIELDREF,enums.ConstantPoolItemType.METHODREF,enums.ConstantPoolItemType.INTERFACE_METHODREF,enums.ConstantPoolItemType.INVOKE_DYNAMIC],[enums.ConstantPoolItemType.METHOD_HANDLE]]);var ConstantPool=function(){function a(){}return a.prototype.parse=function(a,b){var c=this;void 0===b&&(b=null);var d=a.getUint16(),e=[[],[],[]],f=0,g=1,h=0,i=0,j=0;for(this.constantPool=new Array(d);g<d;)i=a.pos(),h=a.getUint8(),j=CONSTANT_POOL_TIER[h],j>0?(e[j-1].push({offset:i,index:g}),a.skip(CP_CLASSES[h].infoByteSize)):this.constantPool[g]=CP_CLASSES[h].fromBytes(a,this),g+=CP_CLASSES[h].size;return f=a.pos(),e.forEach(function(d){d.forEach(function(d){if(a.seek(d.offset),h=a.getUint8(),c.constantPool[d.index]=CP_CLASSES[h].fromBytes(a,c),null!==b&&null!==b.array[d.index]&&void 0!==b.array[d.index]){var e=b.array[d.index];switch(e.getClass().getInternalName()){case\"Ljava/lang/Integer;\":c.constantPool[d.index].value=e[\"java/lang/Integer/value\"];break;case\"Ljava/lang/Long;\":c.constantPool[d.index].value=e[\"java/lang/Long/value\"];break;case\"Ljava/lang/Float;\":c.constantPool[d.index].value=e[\"java/lang/Float/value\"];break;case\"Ljava/lang/Double;\":c.constantPool[d.index].value=e[\"java/lang/Double/value\"];break;case\"Ljava/lang/String;\":c.constantPool[d.index].value=e.toString();break;case\"Ljava/lang/Class;\":c.constantPool[d.index].name=e.$cls.getInternalName(),c.constantPool[d.index].cls=e.$cls;break;default:c.constantPool[d.index].stringValue=\"\",c.constantPool[d.index].value=e}}})}),a.seek(f),a},a.prototype.get=function(a){return this.constantPool[a]},a.prototype.each=function(a){this.constantPool.forEach(function(b,c){void 0!==b&&a(c,b)})},a}();exports.ConstantPool=ConstantPool;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";var ClassLock=function(){function a(){this.queue=[]}return a.prototype.tryLock=function(a,b){return 1===this.queue.push({thread:a,cb:b})},a.prototype.unlock=function(a){var b,c=this.queue.length;for(b=0;b<c;b++)this.queue[b].cb(a);this.queue=[]},a.prototype.getOwner=function(){return this.queue.length>0?this.queue[0].thread:null},a}();module.exports=ClassLock;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var enums=__webpack_require__(9),assert=__webpack_require__(13),Monitor=function(){function a(){this.owner=null,this.count=0,this.blocked={},this.waiting={}}return a.prototype.enter=function(a,b){return this.owner===a?(this.count++,!0):this.contendForLock(a,1,enums.ThreadStatus.BLOCKED,b)},a.prototype.contendForLock=function(a,b,c,d){var e=this.owner;return null===e?(this.owner=a,this.count=b,!0):(this.blocked[a.getRef()]={thread:a,cb:d,count:b},a.setStatus(c,this),!1)},a.prototype.exit=function(a){var b=this.owner;return b===a?0===--this.count&&(this.owner=null,this.appointNewOwner()):a.throwNewException(\"Ljava/lang/IllegalMonitorStateException;\",\"Cannot exit a monitor that you do not own.\"),b===a},a.prototype.appointNewOwner=function(){var a=Object.keys(this.blocked);if(a.length>0){var b=a[Math.floor(Math.random()*a.length)],c=this.blocked[b];this.unblock(c.thread,!1)}},a.prototype.wait=function(a,b,c,d){var e=this;return this.getOwner()===a?(this.waiting[a.getRef()]={thread:a,cb:b,count:this.count,isTimed:null!=c&&0!==c},this.owner=null,this.count=0,null!=c&&0!==c?(this.waiting[a.getRef()].timer=setTimeout(function(){e.unwait(a,!0)},c),a.setStatus(enums.ThreadStatus.TIMED_WAITING,this)):a.setStatus(enums.ThreadStatus.WAITING,this),this.appointNewOwner(),!0):(a.throwNewException(\"Ljava/lang/IllegalMonitorStateException;\",\"Cannot wait on an object that you do not own.\"),!1)},a.prototype.unwait=function(a,b,c,d){void 0===c&&(c=!1),void 0===d&&(d=null);var e=this.waiting[a.getRef()],f=enums.ThreadStatus.UNINTERRUPTABLY_BLOCKED,g=function(){a.setStatus(enums.ThreadStatus.RUNNABLE),c?d():e.cb(b)};if(delete this.waiting[a.getRef()],a.getStatus()===enums.ThreadStatus.TIMED_WAITING&&!b){var h=e.timer;clearTimeout(h)}this.contendForLock(a,e.count,f,g)&&g()},a.prototype.unblock=function(a,b){void 0===b&&(b=!1);var c=this.blocked[a.getRef()];null!=c&&(delete this.blocked[a.getRef()],a.setStatus(enums.ThreadStatus.RUNNABLE),b||(this.owner=a,this.count=c.count,c.cb()))},a.prototype.notify=function(a){if(this.owner===a){var b=Object.keys(this.waiting);b.length>0&&this.unwait(this.waiting[b[Math.floor(Math.random()*b.length)]].thread,!1)}else a.throwNewException(\"Ljava/lang/IllegalMonitorStateException;\",\"Cannot notify on a monitor that you do not own.\")},a.prototype.notifyAll=function(a){if(this.owner===a){var b,c=Object.keys(this.waiting);for(b=0;b<c.length;b++)this.unwait(this.waiting[c[b]].thread,!1)}else a.throwNewException(\"Ljava/lang/IllegalMonitorStateException;\",\"Cannot notifyAll on a monitor that you do not own.\")},a.prototype.getOwner=function(){return this.owner},a.prototype.isWaiting=function(a){return null!=this.waiting[a.getRef()]&&!this.waiting[a.getRef()].isTimed},a.prototype.isTimedWaiting=function(a){return null!=this.waiting[a.getRef()]&&this.waiting[a.getRef()].isTimed},a.prototype.isBlocked=function(a){return null!=this.blocked[a.getRef()]},a}();module.exports=Monitor;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function win2nix(a){return a.replace(/\\\\/g,\"/\")}function parseMetaIndex(a){for(var b=a.split(\"\\n\"),c={},d=null,e=0;e<b.length;e++){var f=b[e];if(f.length>0)switch(f[0]){case\"%\":case\"@\":continue;case\"!\":case\"#\":var g=f.slice(2);c[g]=d={};break;default:\"/\"===f[f.length-1]&&(f=f.slice(0,f.length-1));var h=f.split(\"/\"),i=d,j=void 0;for(j=0;j<h.length-1;j++){var k=h[j],l=i[k];i=l?i[k]:i[k]={}}i[h[j]]=!0}}return c}function ClasspathFactory(a,b,c){var d=new Array(b.length),e=0;fs.readFile(nodePath.join(a,\"lib\",\"meta-index\"),function(f,g){var h={};f||(h=parseMetaIndex(g.toString())),util.asyncForEach(b,function(b,c){var f=nodePath.relative(a+\"/lib\",b);fs.stat(b,function(a,g){var i;i=a?new ClasspathNotFound(b):g.isDirectory()?new ClasspathFolder(b):h[f]?new IndexedClasspathJar(h[f],b):new UnindexedClasspathJar(b),d[e++]=i,i.initialize(c)})},function(a){c(d)})})}var __extends=this&&this.__extends||function(a,b){function c(){this.constructor=a}for(var d in b)b.hasOwnProperty(d)&&(a[d]=b[d]);a.prototype=null===b?Object.create(b):(c.prototype=b.prototype,new c)},enums_1=__webpack_require__(9),assert=__webpack_require__(13),fs=__webpack_require__(27),BrowserFS=__webpack_require__(4),bfsPath=BrowserFS.BFSRequire(\"path\"),nodePath=__webpack_require__(28),util=__webpack_require__(7),BFSFS=BrowserFS.BFSRequire(\"fs\"),ZipFS=BrowserFS.FileSystem.ZipFS,AbstractClasspathJar=function(){function a(a){this._fs=new BFSFS.FS,this._jarRead=enums_1.TriState.INDETERMINATE,this._path=a}return a.prototype.getPath=function(){return this._path},a.prototype.loadJar=function(a){var b=this;this._jarRead!==enums_1.TriState.TRUE?fs.readFile(this._path,function(c,d){if(c)b._jarRead=enums_1.TriState.FALSE,a(c);else try{ZipFS.computeIndex(d,function(c){try{b._fs.initialize(new ZipFS(c,bfsPath.basename(b._path))),b._jarRead=enums_1.TriState.TRUE,a()}catch(e){b._jarRead=enums_1.TriState.FALSE,a(e)}})}catch(e){b._jarRead=enums_1.TriState.FALSE,a(e)}}):setImmediate(function(){return a(b._jarRead===enums_1.TriState.TRUE?null:new Error(\"Failed to load JAR file.\"))})},a.prototype.tryLoadClassSync=function(a){if(this._jarRead!==enums_1.TriState.TRUE)return null;if(this.hasClass(a)===enums_1.TriState.FALSE)return null;try{return this._fs.readFileSync(\"/\"+a+\".class\")}catch(e){return null}},a.prototype._wrapOp=function(a,b){var c=this;switch(this._jarRead){case enums_1.TriState.TRUE:a();break;case enums_1.TriState.FALSE:setImmediate(function(){return b(new Error(\"Unable to load JAR file.\"))});break;default:this.loadJar(function(){c._wrapOp(a,b)})}},a.prototype._wrapSyncOp=function(a){if(this._jarRead!==enums_1.TriState.TRUE)return null;try{return a()}catch(e){return null}},a.prototype.loadClass=function(a,b){var c=this;this._wrapOp(function(){c._fs.readFile(\"/\"+a+\".class\",b)},b)},a.prototype.statResource=function(a,b){var c=this;this._wrapOp(function(){c._fs.stat(a,b)},b)},a.prototype.readdir=function(a,b){var c=this;this._wrapOp(function(){c._fs.readdir(win2nix(a),b)},b)},a.prototype.tryReaddirSync=function(a){var b=this;return this._wrapSyncOp(function(){return b._fs.readdirSync(win2nix(a))})},a.prototype.tryStatSync=function(a){var b=this;return this._wrapSyncOp(function(){return b._fs.statSync(win2nix(a))})},a.prototype.getFS=function(){return this._fs.getRootFS()},a}();exports.AbstractClasspathJar=AbstractClasspathJar;var UnindexedClasspathJar=function(a){function b(b){a.call(this,b),this._classList=null}return __extends(b,a),b.prototype.hasClass=function(a){return this._jarRead===enums_1.TriState.FALSE?enums_1.TriState.FALSE:this._hasClass(a)},b.prototype._hasClass=function(a){return this._classList?this._classList[a]?enums_1.TriState.TRUE:enums_1.TriState.FALSE:enums_1.TriState.INDETERMINATE},b.prototype.initializeWithClasslist=function(a){this._classList={};for(var b=a.length,c=0;c<b;c++)this._classList[a[c]]=!0},b.prototype.initialize=function(a){var b=this;this.loadJar(function(c){if(c)a();else{for(var d=[\"/\"],e=[],f=b._fs;d.length>0;){var g=d.pop();try{var h=f.statSync(g);if(h.isDirectory())for(var i=f.readdirSync(g),j=0;j<i.length;j++)d.push(bfsPath.join(g,i[j]));else\".class\"===bfsPath.extname(g)&&e.push(g.slice(1,g.length-6))}catch(e){}}b.initializeWithClasslist(e),a()}})},b}(AbstractClasspathJar);exports.UnindexedClasspathJar=UnindexedClasspathJar;var IndexedClasspathJar=function(a){function b(b,c){a.call(this,c),this._metaIndex=b,this._metaName=bfsPath.basename(c)}return __extends(b,a),b.prototype.initialize=function(a){setImmediate(function(){return a()})},b.prototype.hasClass=function(a){if(this._jarRead===enums_1.TriState.FALSE)return enums_1.TriState.FALSE;var b=a.split(\"/\"),c=this._metaIndex;b.pop();for(var d=0;d<b.length;d++){var e=c[b[d]];if(!e)return enums_1.TriState.FALSE;if(e===!0)return enums_1.TriState.INDETERMINATE;c=e}return enums_1.TriState.FALSE},b}(AbstractClasspathJar);exports.IndexedClasspathJar=IndexedClasspathJar;var ClasspathFolder=function(){function a(a){this._path=a}return a.prototype.getPath=function(){return this._path},a.prototype.hasClass=function(a){return enums_1.TriState.INDETERMINATE},a.prototype.initialize=function(a){setImmediate(a)},a.prototype.tryLoadClassSync=function(a){try{return fs.readFileSync(nodePath.resolve(this._path,a+\".class\"))}catch(e){return null}},a.prototype.loadClass=function(a,b){fs.readFile(nodePath.resolve(this._path,a+\".class\"),b)},a.prototype.statResource=function(a,b){fs.stat(nodePath.resolve(this._path,a),b)},a.prototype.readdir=function(a,b){fs.readdir(nodePath.resolve(this._path,a),b)},a.prototype.tryReaddirSync=function(a){try{return fs.readdirSync(nodePath.resolve(this._path,a))}catch(e){return null}},a.prototype.tryStatSync=function(a){try{return fs.statSync(nodePath.resolve(this._path,a))}catch(e){return null}},a}();exports.ClasspathFolder=ClasspathFolder;var ClasspathNotFound=function(){function a(a){this._path=a}return a.prototype.getPath=function(){return this._path},a.prototype.hasClass=function(a){return enums_1.TriState.FALSE},a.prototype.initialize=function(a){setImmediate(a)},a.prototype.initializeWithClasslist=function(a){},a.prototype.tryLoadClassSync=function(a){return null},a.prototype._notFoundError=function(a){setImmediate(function(){return a(new Error(\"Class cannot be found.\"))})},a.prototype.loadClass=function(a,b){this._notFoundError(b)},a.prototype.statResource=function(a,b){this._notFoundError(b)},a.prototype.readdir=function(a,b){this._notFoundError(b)},a.prototype.tryReaddirSync=function(a){return null},a.prototype.tryStatSync=function(a){return null},a}();exports.ClasspathNotFound=ClasspathNotFound,exports.ClasspathFactory=ClasspathFactory;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BrowserFS = __webpack_require__(4);module.exports=BrowserFS.BFSRequire('fs');\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BrowserFS = __webpack_require__(4);module.exports=BrowserFS.BFSRequire('path');\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar BrowserFS = __webpack_require__(4);module.exports=BrowserFS.BFSRequire('buffer');\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {\"use strict\";var Heap=function(){function a(b){this.size=b,this._sizeMap={},this._buffer=new Buffer(b),this._remaining=b,this._offset=0,this._freeLists=new Array(a._numSizeClasses);for(var c=0;c<a._numSizeClasses;c++)this._freeLists[c]=[]}return a.prototype.malloc=function(b){if(b<=4&&(b=4),this._remaining<b)throw\"out of memory\";var c,d;return d=a.size_to_class(b),c=this._freeLists[d].pop(),void 0===c&&(c=this.refill(d)),c},a.prototype.free=function(b){var c=b&~(a._chunkSize-1),d=this._sizeMap[c];this._freeLists[d].push(b)},a.prototype.store_word=function(a,b){this._buffer.writeInt32LE(b,a)},a.prototype.get_byte=function(a){return this._buffer.readUInt8(a)},a.prototype.get_word=function(a){return this._buffer.readInt32LE(a)},a.prototype.get_buffer=function(a,b){return this._buffer.slice(a,a+b)},a.prototype.get_signed_byte=function(a){return this._buffer.readInt8(a)},a.prototype.set_byte=function(a,b){this._buffer.writeUInt8(b,a)},a.prototype.set_signed_byte=function(a,b){this._buffer.writeInt8(b,a)},a.prototype.memcpy=function(a,b,c){this._buffer.copy(this._buffer,b,a,a+c)},a.prototype.refill=function(b){var c=this.cl_to_size(b),d=Math.floor(a._chunkSize/c);d<1&&(d=1);var e=this._offset;this._sizeMap[e]=b;for(var f=0;f<d;f++)this._remaining-=c,e=this._offset,this._freeLists[b].push(e),this._offset+=c;return e},a.ilog2=function(a){for(var b=0,c=1;c<a;)c<<=1,b++;return b},a.size_to_class=function(b){return a.ilog2(b)},a.prototype.cl_to_size=function(a){return 1<<a},a._numSizeClasses=64,a._chunkSize=4096,a}();module.exports=Heap;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var enums_1=__webpack_require__(9),assert=__webpack_require__(13),Parker=function(){function a(){this._parkCounts={},this._parkCallbacks={}}return a.prototype.park=function(a,b){var c=a.getRef();this._parkCallbacks[c]=b,this._mutateParkCount(a,1),this.isParked(a)&&a.setStatus(enums_1.ThreadStatus.PARKED)},a.prototype.unpark=function(a){this._mutateParkCount(a,-1)},a.prototype.completelyUnpark=function(a){var b=a.getRef(),c=this._parkCounts[b];c&&this._mutateParkCount(a,-c)},a.prototype._mutateParkCount=function(a,b){var c,d=a.getRef();this._parkCounts[d]||(this._parkCounts[d]=0),0===(this._parkCounts[d]+=b)&&(c=this._parkCallbacks[d],delete this._parkCounts[d],delete this._parkCallbacks[d],a.getStatus()===enums_1.ThreadStatus.PARKED&&(a.setStatus(enums_1.ThreadStatus.ASYNC_WAITING),c()))},a.prototype.isParked=function(a){return!!this._parkCounts[a.getRef()]},a}();module.exports=Parker;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function isRunnable(a){return a===enums_1.ThreadStatus.RUNNABLE}var enums_1=__webpack_require__(9),assert=__webpack_require__(13),WeightedRoundRobinScheduler=function(){function a(){this._count=0,this._queue=[],this._threadScheduled=!1}return a.prototype.scheduleThread=function(a){this._queue.push(a),1===this._queue.length&&this.runThread()},a.prototype.runThread=function(){var a=this;this._threadScheduled||(this._threadScheduled=!0,setImmediate(function(){var b=a._queue;if(a._threadScheduled=!1,b.length>0){var c=a._queue[0];c.run()}}))},a.prototype.unscheduleThread=function(a){var b=this._queue,c=b[0]===a;c?(b.shift(),this._count=0,this.runThread()):b.splice(b.indexOf(a),1)},a.prototype.getRunningThread=function(){var a=this._queue;return a.length>0?a[0]:null},a.prototype.priorityChange=function(a){},a.prototype.quantumOver=function(a){this._count++,(this._count>=a.getPriority()||a.getStatus()!==enums_1.ThreadStatus.RUNNABLE)&&(this._count=0,this._queue.push(this._queue.shift())),this.runThread()},a}(),ThreadPool=function(){function a(a){this.threads=[],this.scheduler=new WeightedRoundRobinScheduler,this.emptyCallback=a}return a.prototype.getThreads=function(){return this.threads.slice(0)},a.prototype.anyNonDaemonicThreads=function(){for(var a=0;a<this.threads.length;a++){var b=this.threads[a];if(!b.isDaemon()){var c=b.getStatus();if(c!==enums_1.ThreadStatus.NEW&&c!==enums_1.ThreadStatus.TERMINATED)return!0}}return!1},a.prototype.threadTerminated=function(a){var b=this.threads.indexOf(a);if(this.threads.splice(b,1),!this.anyNonDaemonicThreads()){var c=this.emptyCallback();c&&(this.emptyCallback=null)}},a.prototype.statusChange=function(a,b,c){var d=isRunnable(b),e=isRunnable(c);b!==enums_1.ThreadStatus.NEW&&b!==enums_1.ThreadStatus.TERMINATED||this.threads.indexOf(a)===-1&&this.threads.push(a),d!==e&&(d?this.scheduler.unscheduleThread(a):this.scheduler.scheduleThread(a)),c===enums_1.ThreadStatus.TERMINATED&&this.threadTerminated(a)},a.prototype.priorityChange=function(a){this.scheduler.priorityChange(a)},a.prototype.quantumOver=function(a){this.scheduler.quantumOver(a)},a}();exports.__esModule=!0,exports[\"default\"]=ThreadPool;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"url\": \"https://github.com/plasma-umass/doppio_jcl/releases/download/v3.2/java_home.tar.gz\",\n\t\t\"classpath\": [\n\t\t\t\"lib/rt.jar\",\n\t\t\t\"lib/charsets.jar\",\n\t\t\t\"lib/doppio.jar\",\n\t\t\t\"lib/dt.jar\",\n\t\t\t\"lib/jce.jar\",\n\t\t\t\"lib/jconsole.jar\",\n\t\t\t\"lib/jsse.jar\",\n\t\t\t\"lib/management-agent.jar\",\n\t\t\t\"lib/resources.jar\",\n\t\t\t\"lib/sa-jdi.jar\",\n\t\t\t\"lib/tools.jar\"\n\t\t]\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\"use strict\";function getGlobalRequire(){var reqVar=eval('typeof(require)!==\"undefined\"?require:null');return reqVar?reqVar:function(a){throw new Error(\"Cannot find module \"+a)}}exports.__esModule=!0,exports[\"default\"]=getGlobalRequire;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils   = __webpack_require__(36);\n\tvar trees   = __webpack_require__(37);\n\tvar adler32 = __webpack_require__(38);\n\tvar crc32   = __webpack_require__(39);\n\tvar msg     = __webpack_require__(40);\n\t\n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n\t\n\t\n\t/* Allowed flush values; see deflate() and inflate() below for details */\n\tvar Z_NO_FLUSH      = 0;\n\tvar Z_PARTIAL_FLUSH = 1;\n\t//var Z_SYNC_FLUSH    = 2;\n\tvar Z_FULL_FLUSH    = 3;\n\tvar Z_FINISH        = 4;\n\tvar Z_BLOCK         = 5;\n\t//var Z_TREES         = 6;\n\t\n\t\n\t/* Return codes for the compression/decompression functions. Negative values\n\t * are errors, positive values are used for special but normal events.\n\t */\n\tvar Z_OK            = 0;\n\tvar Z_STREAM_END    = 1;\n\t//var Z_NEED_DICT     = 2;\n\t//var Z_ERRNO         = -1;\n\tvar Z_STREAM_ERROR  = -2;\n\tvar Z_DATA_ERROR    = -3;\n\t//var Z_MEM_ERROR     = -4;\n\tvar Z_BUF_ERROR     = -5;\n\t//var Z_VERSION_ERROR = -6;\n\t\n\t\n\t/* compression levels */\n\t//var Z_NO_COMPRESSION      = 0;\n\t//var Z_BEST_SPEED          = 1;\n\t//var Z_BEST_COMPRESSION    = 9;\n\tvar Z_DEFAULT_COMPRESSION = -1;\n\t\n\t\n\tvar Z_FILTERED            = 1;\n\tvar Z_HUFFMAN_ONLY        = 2;\n\tvar Z_RLE                 = 3;\n\tvar Z_FIXED               = 4;\n\tvar Z_DEFAULT_STRATEGY    = 0;\n\t\n\t/* Possible values of the data_type field (though see inflate()) */\n\t//var Z_BINARY              = 0;\n\t//var Z_TEXT                = 1;\n\t//var Z_ASCII               = 1; // = Z_TEXT\n\tvar Z_UNKNOWN             = 2;\n\t\n\t\n\t/* The deflate compression method */\n\tvar Z_DEFLATED  = 8;\n\t\n\t/*============================================================================*/\n\t\n\t\n\tvar MAX_MEM_LEVEL = 9;\n\t/* Maximum value for memLevel in deflateInit2 */\n\tvar MAX_WBITS = 15;\n\t/* 32K LZ77 window */\n\tvar DEF_MEM_LEVEL = 8;\n\t\n\t\n\tvar LENGTH_CODES  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n\tvar LITERALS      = 256;\n\t/* number of literal bytes 0..255 */\n\tvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n\tvar D_CODES       = 30;\n\t/* number of distance codes */\n\tvar BL_CODES      = 19;\n\t/* number of codes used to transfer the bit lengths */\n\tvar HEAP_SIZE     = 2 * L_CODES + 1;\n\t/* maximum heap size */\n\tvar MAX_BITS  = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n\t\n\tvar MIN_MATCH = 3;\n\tvar MAX_MATCH = 258;\n\tvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\t\n\tvar PRESET_DICT = 0x20;\n\t\n\tvar INIT_STATE = 42;\n\tvar EXTRA_STATE = 69;\n\tvar NAME_STATE = 73;\n\tvar COMMENT_STATE = 91;\n\tvar HCRC_STATE = 103;\n\tvar BUSY_STATE = 113;\n\tvar FINISH_STATE = 666;\n\t\n\tvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n\tvar BS_BLOCK_DONE     = 2; /* block flush performed */\n\tvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n\tvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\t\n\tvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\t\n\tfunction err(strm, errorCode) {\n\t  strm.msg = msg[errorCode];\n\t  return errorCode;\n\t}\n\t\n\tfunction rank(f) {\n\t  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n\t}\n\t\n\tfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\t\n\t\n\t/* =========================================================================\n\t * Flush as much pending output as possible. All deflate() output goes\n\t * through this function so some applications may wish to modify it\n\t * to avoid allocating a large strm->output buffer and copying into it.\n\t * (See also read_buf()).\n\t */\n\tfunction flush_pending(strm) {\n\t  var s = strm.state;\n\t\n\t  //_tr_flush_bits(s);\n\t  var len = s.pending;\n\t  if (len > strm.avail_out) {\n\t    len = strm.avail_out;\n\t  }\n\t  if (len === 0) { return; }\n\t\n\t  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n\t  strm.next_out += len;\n\t  s.pending_out += len;\n\t  strm.total_out += len;\n\t  strm.avail_out -= len;\n\t  s.pending -= len;\n\t  if (s.pending === 0) {\n\t    s.pending_out = 0;\n\t  }\n\t}\n\t\n\t\n\tfunction flush_block_only(s, last) {\n\t  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n\t  s.block_start = s.strstart;\n\t  flush_pending(s.strm);\n\t}\n\t\n\t\n\tfunction put_byte(s, b) {\n\t  s.pending_buf[s.pending++] = b;\n\t}\n\t\n\t\n\t/* =========================================================================\n\t * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n\t * IN assertion: the stream state is correct and there is enough room in\n\t * pending_buf.\n\t */\n\tfunction putShortMSB(s, b) {\n\t//  put_byte(s, (Byte)(b >> 8));\n\t//  put_byte(s, (Byte)(b & 0xff));\n\t  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n\t  s.pending_buf[s.pending++] = b & 0xff;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Read a new buffer from the current input stream, update the adler32\n\t * and total number of bytes read.  All deflate() input goes through\n\t * this function so some applications may wish to modify it to avoid\n\t * allocating a large strm->input buffer and copying from it.\n\t * (See also flush_pending()).\n\t */\n\tfunction read_buf(strm, buf, start, size) {\n\t  var len = strm.avail_in;\n\t\n\t  if (len > size) { len = size; }\n\t  if (len === 0) { return 0; }\n\t\n\t  strm.avail_in -= len;\n\t\n\t  // zmemcpy(buf, strm->next_in, len);\n\t  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n\t  if (strm.state.wrap === 1) {\n\t    strm.adler = adler32(strm.adler, buf, len, start);\n\t  }\n\t\n\t  else if (strm.state.wrap === 2) {\n\t    strm.adler = crc32(strm.adler, buf, len, start);\n\t  }\n\t\n\t  strm.next_in += len;\n\t  strm.total_in += len;\n\t\n\t  return len;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Set match_start to the longest match starting at the given string and\n\t * return its length. Matches shorter or equal to prev_length are discarded,\n\t * in which case the result is equal to prev_length and match_start is\n\t * garbage.\n\t * IN assertions: cur_match is the head of the hash chain for the current\n\t *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n\t * OUT assertion: the match length is not greater than s->lookahead.\n\t */\n\tfunction longest_match(s, cur_match) {\n\t  var chain_length = s.max_chain_length;      /* max hash chain length */\n\t  var scan = s.strstart; /* current string */\n\t  var match;                       /* matched string */\n\t  var len;                           /* length of current match */\n\t  var best_len = s.prev_length;              /* best match length so far */\n\t  var nice_match = s.nice_match;             /* stop if match long enough */\n\t  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n\t      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\t\n\t  var _win = s.window; // shortcut\n\t\n\t  var wmask = s.w_mask;\n\t  var prev  = s.prev;\n\t\n\t  /* Stop when cur_match becomes <= limit. To simplify the code,\n\t   * we prevent matches with the string of window index 0.\n\t   */\n\t\n\t  var strend = s.strstart + MAX_MATCH;\n\t  var scan_end1  = _win[scan + best_len - 1];\n\t  var scan_end   = _win[scan + best_len];\n\t\n\t  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n\t   * It is easy to get rid of this optimization if necessary.\n\t   */\n\t  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\t\n\t  /* Do not waste too much time if we already have a good match: */\n\t  if (s.prev_length >= s.good_match) {\n\t    chain_length >>= 2;\n\t  }\n\t  /* Do not look for matches beyond the end of the input. This is necessary\n\t   * to make deflate deterministic.\n\t   */\n\t  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\t\n\t  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\t\n\t  do {\n\t    // Assert(cur_match < s->strstart, \"no future\");\n\t    match = cur_match;\n\t\n\t    /* Skip to next match if the match length cannot increase\n\t     * or if the match length is less than 2.  Note that the checks below\n\t     * for insufficient lookahead only occur occasionally for performance\n\t     * reasons.  Therefore uninitialized memory will be accessed, and\n\t     * conditional jumps will be made that depend on those values.\n\t     * However the length of the match is limited to the lookahead, so\n\t     * the output of deflate is not affected by the uninitialized values.\n\t     */\n\t\n\t    if (_win[match + best_len]     !== scan_end  ||\n\t        _win[match + best_len - 1] !== scan_end1 ||\n\t        _win[match]                !== _win[scan] ||\n\t        _win[++match]              !== _win[scan + 1]) {\n\t      continue;\n\t    }\n\t\n\t    /* The check at best_len-1 can be removed because it will be made\n\t     * again later. (This heuristic is not always a win.)\n\t     * It is not necessary to compare scan[2] and match[2] since they\n\t     * are always equal when the other bytes match, given that\n\t     * the hash keys are equal and that HASH_BITS >= 8.\n\t     */\n\t    scan += 2;\n\t    match++;\n\t    // Assert(*scan == *match, \"match[2]?\");\n\t\n\t    /* We check for insufficient lookahead only every 8th comparison;\n\t     * the 256th check will be made at strstart+258.\n\t     */\n\t    do {\n\t      /*jshint noempty:false*/\n\t    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t             scan < strend);\n\t\n\t    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\t\n\t    len = MAX_MATCH - (strend - scan);\n\t    scan = strend - MAX_MATCH;\n\t\n\t    if (len > best_len) {\n\t      s.match_start = cur_match;\n\t      best_len = len;\n\t      if (len >= nice_match) {\n\t        break;\n\t      }\n\t      scan_end1  = _win[scan + best_len - 1];\n\t      scan_end   = _win[scan + best_len];\n\t    }\n\t  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\t\n\t  if (best_len <= s.lookahead) {\n\t    return best_len;\n\t  }\n\t  return s.lookahead;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Fill the window when the lookahead becomes insufficient.\n\t * Updates strstart and lookahead.\n\t *\n\t * IN assertion: lookahead < MIN_LOOKAHEAD\n\t * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t *    At least one byte has been read, or avail_in == 0; reads are\n\t *    performed for at least two bytes (required for the zip translate_eol\n\t *    option -- not supported here).\n\t */\n\tfunction fill_window(s) {\n\t  var _w_size = s.w_size;\n\t  var p, n, m, more, str;\n\t\n\t  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\t\n\t  do {\n\t    more = s.window_size - s.lookahead - s.strstart;\n\t\n\t    // JS ints have 32 bit, block below not needed\n\t    /* Deal with !@#$% 64K limit: */\n\t    //if (sizeof(int) <= 2) {\n\t    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n\t    //        more = wsize;\n\t    //\n\t    //  } else if (more == (unsigned)(-1)) {\n\t    //        /* Very unlikely, but possible on 16 bit machine if\n\t    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n\t    //         */\n\t    //        more--;\n\t    //    }\n\t    //}\n\t\n\t\n\t    /* If the window is almost full and there is insufficient lookahead,\n\t     * move the upper half to the lower one to make room in the upper half.\n\t     */\n\t    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\t\n\t      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n\t      s.match_start -= _w_size;\n\t      s.strstart -= _w_size;\n\t      /* we now have strstart >= MAX_DIST */\n\t      s.block_start -= _w_size;\n\t\n\t      /* Slide the hash table (could be avoided with 32 bit values\n\t       at the expense of memory usage). We slide even when level == 0\n\t       to keep the hash table consistent if we switch back to level > 0\n\t       later. (Using level 0 permanently is not an optimal usage of\n\t       zlib, so we don't care about this pathological case.)\n\t       */\n\t\n\t      n = s.hash_size;\n\t      p = n;\n\t      do {\n\t        m = s.head[--p];\n\t        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n\t      } while (--n);\n\t\n\t      n = _w_size;\n\t      p = n;\n\t      do {\n\t        m = s.prev[--p];\n\t        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n\t        /* If n is not on any hash chain, prev[n] is garbage but\n\t         * its value will never be used.\n\t         */\n\t      } while (--n);\n\t\n\t      more += _w_size;\n\t    }\n\t    if (s.strm.avail_in === 0) {\n\t      break;\n\t    }\n\t\n\t    /* If there was no sliding:\n\t     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t     *    more == window_size - lookahead - strstart\n\t     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t     * => more >= window_size - 2*WSIZE + 2\n\t     * In the BIG_MEM or MMAP case (not yet supported),\n\t     *   window_size == input_size + MIN_LOOKAHEAD  &&\n\t     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t     * Otherwise, window_size == 2*WSIZE so more >= 2.\n\t     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\t     */\n\t    //Assert(more >= 2, \"more < 2\");\n\t    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n\t    s.lookahead += n;\n\t\n\t    /* Initialize the hash value now that we have some input: */\n\t    if (s.lookahead + s.insert >= MIN_MATCH) {\n\t      str = s.strstart - s.insert;\n\t      s.ins_h = s.window[str];\n\t\n\t      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\t      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n\t//#if MIN_MATCH != 3\n\t//        Call update_hash() MIN_MATCH-3 more times\n\t//#endif\n\t      while (s.insert) {\n\t        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\t\n\t        s.prev[str & s.w_mask] = s.head[s.ins_h];\n\t        s.head[s.ins_h] = str;\n\t        str++;\n\t        s.insert--;\n\t        if (s.lookahead + s.insert < MIN_MATCH) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n\t     * but this is not important since only literal bytes will be emitted.\n\t     */\n\t\n\t  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\t\n\t  /* If the WIN_INIT bytes after the end of the current data have never been\n\t   * written, then zero those bytes in order to avoid memory check reports of\n\t   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n\t   * the longest match routines.  Update the high water mark for the next\n\t   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n\t   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n\t   */\n\t//  if (s.high_water < s.window_size) {\n\t//    var curr = s.strstart + s.lookahead;\n\t//    var init = 0;\n\t//\n\t//    if (s.high_water < curr) {\n\t//      /* Previous high water mark below current data -- zero WIN_INIT\n\t//       * bytes or up to end of window, whichever is less.\n\t//       */\n\t//      init = s.window_size - curr;\n\t//      if (init > WIN_INIT)\n\t//        init = WIN_INIT;\n\t//      zmemzero(s->window + curr, (unsigned)init);\n\t//      s->high_water = curr + init;\n\t//    }\n\t//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n\t//      /* High water mark at or above current data, but below current data\n\t//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n\t//       * to end of window, whichever is less.\n\t//       */\n\t//      init = (ulg)curr + WIN_INIT - s->high_water;\n\t//      if (init > s->window_size - s->high_water)\n\t//        init = s->window_size - s->high_water;\n\t//      zmemzero(s->window + s->high_water, (unsigned)init);\n\t//      s->high_water += init;\n\t//    }\n\t//  }\n\t//\n\t//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n\t//    \"not enough room for search\");\n\t}\n\t\n\t/* ===========================================================================\n\t * Copy without compression as much as possible from the input stream, return\n\t * the current block state.\n\t * This function does not insert new strings in the dictionary since\n\t * uncompressible data is probably not useful. This function is used\n\t * only for the level=0 compression option.\n\t * NOTE: this function should be optimized to avoid extra copying from\n\t * window to pending_buf.\n\t */\n\tfunction deflate_stored(s, flush) {\n\t  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t   * to pending_buf_size, and each stored block has a 5 byte header:\n\t   */\n\t  var max_block_size = 0xffff;\n\t\n\t  if (max_block_size > s.pending_buf_size - 5) {\n\t    max_block_size = s.pending_buf_size - 5;\n\t  }\n\t\n\t  /* Copy as much as possible from input to output: */\n\t  for (;;) {\n\t    /* Fill the window as much as possible: */\n\t    if (s.lookahead <= 1) {\n\t\n\t      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n\t      //  s->block_start >= (long)s->w_size, \"slide too late\");\n\t//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n\t//        s.block_start >= s.w_size)) {\n\t//        throw  new Error(\"slide too late\");\n\t//      }\n\t\n\t      fill_window(s);\n\t      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n\t        return BS_NEED_MORE;\n\t      }\n\t\n\t      if (s.lookahead === 0) {\n\t        break;\n\t      }\n\t      /* flush the current block */\n\t    }\n\t    //Assert(s->block_start >= 0L, \"block gone\");\n\t//    if (s.block_start < 0) throw new Error(\"block gone\");\n\t\n\t    s.strstart += s.lookahead;\n\t    s.lookahead = 0;\n\t\n\t    /* Emit a stored block if pending_buf will be full: */\n\t    var max_start = s.block_start + max_block_size;\n\t\n\t    if (s.strstart === 0 || s.strstart >= max_start) {\n\t      /* strstart == 0 is possible when wraparound on 16-bit machine */\n\t      s.lookahead = s.strstart - max_start;\n\t      s.strstart = max_start;\n\t      /*** FLUSH_BLOCK(s, 0); ***/\n\t      flush_block_only(s, false);\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      /***/\n\t\n\t\n\t    }\n\t    /* Flush if we may have to slide, otherwise block_start may become\n\t     * negative and the data will be gone:\n\t     */\n\t    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n\t      /*** FLUSH_BLOCK(s, 0); ***/\n\t      flush_block_only(s, false);\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      /***/\n\t    }\n\t  }\n\t\n\t  s.insert = 0;\n\t\n\t  if (flush === Z_FINISH) {\n\t    /*** FLUSH_BLOCK(s, 1); ***/\n\t    flush_block_only(s, true);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_FINISH_STARTED;\n\t    }\n\t    /***/\n\t    return BS_FINISH_DONE;\n\t  }\n\t\n\t  if (s.strstart > s.block_start) {\n\t    /*** FLUSH_BLOCK(s, 0); ***/\n\t    flush_block_only(s, false);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_NEED_MORE;\n\t    }\n\t    /***/\n\t  }\n\t\n\t  return BS_NEED_MORE;\n\t}\n\t\n\t/* ===========================================================================\n\t * Compress as much as possible from the input stream, return the current\n\t * block state.\n\t * This function does not perform lazy evaluation of matches and inserts\n\t * new strings in the dictionary only for unmatched strings or for short\n\t * matches. It is used only for the fast compression options.\n\t */\n\tfunction deflate_fast(s, flush) {\n\t  var hash_head;        /* head of the hash chain */\n\t  var bflush;           /* set if current block must be flushed */\n\t\n\t  for (;;) {\n\t    /* Make sure that we always have enough lookahead, except\n\t     * at the end of the input file. We need MAX_MATCH bytes\n\t     * for the next match, plus MIN_MATCH bytes to insert the\n\t     * string following the next match.\n\t     */\n\t    if (s.lookahead < MIN_LOOKAHEAD) {\n\t      fill_window(s);\n\t      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      if (s.lookahead === 0) {\n\t        break; /* flush the current block */\n\t      }\n\t    }\n\t\n\t    /* Insert the string window[strstart .. strstart+2] in the\n\t     * dictionary, and set hash_head to the head of the hash chain:\n\t     */\n\t    hash_head = 0/*NIL*/;\n\t    if (s.lookahead >= MIN_MATCH) {\n\t      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t      s.head[s.ins_h] = s.strstart;\n\t      /***/\n\t    }\n\t\n\t    /* Find the longest match, discarding those <= prev_length.\n\t     * At this point we have always match_length < MIN_MATCH\n\t     */\n\t    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n\t      /* To simplify the code, we prevent matches with the string\n\t       * of window index 0 (in particular we have to avoid a match\n\t       * of the string with itself at the start of the input file).\n\t       */\n\t      s.match_length = longest_match(s, hash_head);\n\t      /* longest_match() sets match_start */\n\t    }\n\t    if (s.match_length >= MIN_MATCH) {\n\t      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\t\n\t      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n\t                     s.match_length - MIN_MATCH, bflush); ***/\n\t      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\t\n\t      s.lookahead -= s.match_length;\n\t\n\t      /* Insert new strings in the hash table only if the match length\n\t       * is not too large. This saves time but degrades compression.\n\t       */\n\t      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n\t        s.match_length--; /* string at strstart already in table */\n\t        do {\n\t          s.strstart++;\n\t          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t          s.head[s.ins_h] = s.strstart;\n\t          /***/\n\t          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t           * always MIN_MATCH bytes ahead.\n\t           */\n\t        } while (--s.match_length !== 0);\n\t        s.strstart++;\n\t      } else\n\t      {\n\t        s.strstart += s.match_length;\n\t        s.match_length = 0;\n\t        s.ins_h = s.window[s.strstart];\n\t        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\t        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\t\n\t//#if MIN_MATCH != 3\n\t//                Call UPDATE_HASH() MIN_MATCH-3 more times\n\t//#endif\n\t        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n\t         * matter since it will be recomputed at next deflate call.\n\t         */\n\t      }\n\t    } else {\n\t      /* No match, output a literal byte */\n\t      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\t      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t\n\t      s.lookahead--;\n\t      s.strstart++;\n\t    }\n\t    if (bflush) {\n\t      /*** FLUSH_BLOCK(s, 0); ***/\n\t      flush_block_only(s, false);\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      /***/\n\t    }\n\t  }\n\t  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n\t  if (flush === Z_FINISH) {\n\t    /*** FLUSH_BLOCK(s, 1); ***/\n\t    flush_block_only(s, true);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_FINISH_STARTED;\n\t    }\n\t    /***/\n\t    return BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t    /*** FLUSH_BLOCK(s, 0); ***/\n\t    flush_block_only(s, false);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_NEED_MORE;\n\t    }\n\t    /***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t}\n\t\n\t/* ===========================================================================\n\t * Same as above, but achieves better compression. We use a lazy\n\t * evaluation for matches: a match is finally adopted only if there is\n\t * no better match at the next window position.\n\t */\n\tfunction deflate_slow(s, flush) {\n\t  var hash_head;          /* head of hash chain */\n\t  var bflush;              /* set if current block must be flushed */\n\t\n\t  var max_insert;\n\t\n\t  /* Process the input block. */\n\t  for (;;) {\n\t    /* Make sure that we always have enough lookahead, except\n\t     * at the end of the input file. We need MAX_MATCH bytes\n\t     * for the next match, plus MIN_MATCH bytes to insert the\n\t     * string following the next match.\n\t     */\n\t    if (s.lookahead < MIN_LOOKAHEAD) {\n\t      fill_window(s);\n\t      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      if (s.lookahead === 0) { break; } /* flush the current block */\n\t    }\n\t\n\t    /* Insert the string window[strstart .. strstart+2] in the\n\t     * dictionary, and set hash_head to the head of the hash chain:\n\t     */\n\t    hash_head = 0/*NIL*/;\n\t    if (s.lookahead >= MIN_MATCH) {\n\t      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t      s.head[s.ins_h] = s.strstart;\n\t      /***/\n\t    }\n\t\n\t    /* Find the longest match, discarding those <= prev_length.\n\t     */\n\t    s.prev_length = s.match_length;\n\t    s.prev_match = s.match_start;\n\t    s.match_length = MIN_MATCH - 1;\n\t\n\t    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n\t        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n\t      /* To simplify the code, we prevent matches with the string\n\t       * of window index 0 (in particular we have to avoid a match\n\t       * of the string with itself at the start of the input file).\n\t       */\n\t      s.match_length = longest_match(s, hash_head);\n\t      /* longest_match() sets match_start */\n\t\n\t      if (s.match_length <= 5 &&\n\t         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\t\n\t        /* If prev_match is also MIN_MATCH, match_start is garbage\n\t         * but we will ignore the current match anyway.\n\t         */\n\t        s.match_length = MIN_MATCH - 1;\n\t      }\n\t    }\n\t    /* If there was a match at the previous step and the current\n\t     * match is not better, output the previous match:\n\t     */\n\t    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n\t      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n\t      /* Do not insert strings in hash table beyond this. */\n\t\n\t      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\t\n\t      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n\t                     s.prev_length - MIN_MATCH, bflush);***/\n\t      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n\t      /* Insert in hash table all strings up to the end of the match.\n\t       * strstart-1 and strstart are already inserted. If there is not\n\t       * enough lookahead, the last two strings are not inserted in\n\t       * the hash table.\n\t       */\n\t      s.lookahead -= s.prev_length - 1;\n\t      s.prev_length -= 2;\n\t      do {\n\t        if (++s.strstart <= max_insert) {\n\t          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t          s.head[s.ins_h] = s.strstart;\n\t          /***/\n\t        }\n\t      } while (--s.prev_length !== 0);\n\t      s.match_available = 0;\n\t      s.match_length = MIN_MATCH - 1;\n\t      s.strstart++;\n\t\n\t      if (bflush) {\n\t        /*** FLUSH_BLOCK(s, 0); ***/\n\t        flush_block_only(s, false);\n\t        if (s.strm.avail_out === 0) {\n\t          return BS_NEED_MORE;\n\t        }\n\t        /***/\n\t      }\n\t\n\t    } else if (s.match_available) {\n\t      /* If there was no match at the previous position, output a\n\t       * single literal. If there was a match but the current match\n\t       * is longer, truncate the previous match to a single literal.\n\t       */\n\t      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t\n\t      if (bflush) {\n\t        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n\t        flush_block_only(s, false);\n\t        /***/\n\t      }\n\t      s.strstart++;\n\t      s.lookahead--;\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t    } else {\n\t      /* There is no previous match to compare with, wait for\n\t       * the next step to decide.\n\t       */\n\t      s.match_available = 1;\n\t      s.strstart++;\n\t      s.lookahead--;\n\t    }\n\t  }\n\t  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\t  if (s.match_available) {\n\t    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t\n\t    s.match_available = 0;\n\t  }\n\t  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t  if (flush === Z_FINISH) {\n\t    /*** FLUSH_BLOCK(s, 1); ***/\n\t    flush_block_only(s, true);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_FINISH_STARTED;\n\t    }\n\t    /***/\n\t    return BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t    /*** FLUSH_BLOCK(s, 0); ***/\n\t    flush_block_only(s, false);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_NEED_MORE;\n\t    }\n\t    /***/\n\t  }\n\t\n\t  return BS_BLOCK_DONE;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n\t * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n\t * deflate switches away from Z_RLE.)\n\t */\n\tfunction deflate_rle(s, flush) {\n\t  var bflush;            /* set if current block must be flushed */\n\t  var prev;              /* byte at distance one to match */\n\t  var scan, strend;      /* scan goes up to strend for length of run */\n\t\n\t  var _win = s.window;\n\t\n\t  for (;;) {\n\t    /* Make sure that we always have enough lookahead, except\n\t     * at the end of the input file. We need MAX_MATCH bytes\n\t     * for the longest run, plus one for the unrolled loop.\n\t     */\n\t    if (s.lookahead <= MAX_MATCH) {\n\t      fill_window(s);\n\t      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      if (s.lookahead === 0) { break; } /* flush the current block */\n\t    }\n\t\n\t    /* See how many times the previous byte repeats */\n\t    s.match_length = 0;\n\t    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n\t      scan = s.strstart - 1;\n\t      prev = _win[scan];\n\t      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n\t        strend = s.strstart + MAX_MATCH;\n\t        do {\n\t          /*jshint noempty:false*/\n\t        } while (prev === _win[++scan] && prev === _win[++scan] &&\n\t                 prev === _win[++scan] && prev === _win[++scan] &&\n\t                 prev === _win[++scan] && prev === _win[++scan] &&\n\t                 prev === _win[++scan] && prev === _win[++scan] &&\n\t                 scan < strend);\n\t        s.match_length = MAX_MATCH - (strend - scan);\n\t        if (s.match_length > s.lookahead) {\n\t          s.match_length = s.lookahead;\n\t        }\n\t      }\n\t      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\t    }\n\t\n\t    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\t    if (s.match_length >= MIN_MATCH) {\n\t      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\t\n\t      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n\t      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\t\n\t      s.lookahead -= s.match_length;\n\t      s.strstart += s.match_length;\n\t      s.match_length = 0;\n\t    } else {\n\t      /* No match, output a literal byte */\n\t      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t\n\t      s.lookahead--;\n\t      s.strstart++;\n\t    }\n\t    if (bflush) {\n\t      /*** FLUSH_BLOCK(s, 0); ***/\n\t      flush_block_only(s, false);\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      /***/\n\t    }\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH) {\n\t    /*** FLUSH_BLOCK(s, 1); ***/\n\t    flush_block_only(s, true);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_FINISH_STARTED;\n\t    }\n\t    /***/\n\t    return BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t    /*** FLUSH_BLOCK(s, 0); ***/\n\t    flush_block_only(s, false);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_NEED_MORE;\n\t    }\n\t    /***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t}\n\t\n\t/* ===========================================================================\n\t * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n\t * (It will be regenerated if this run of deflate switches away from Huffman.)\n\t */\n\tfunction deflate_huff(s, flush) {\n\t  var bflush;             /* set if current block must be flushed */\n\t\n\t  for (;;) {\n\t    /* Make sure that we have a literal to write. */\n\t    if (s.lookahead === 0) {\n\t      fill_window(s);\n\t      if (s.lookahead === 0) {\n\t        if (flush === Z_NO_FLUSH) {\n\t          return BS_NEED_MORE;\n\t        }\n\t        break;      /* flush the current block */\n\t      }\n\t    }\n\t\n\t    /* Output a literal byte */\n\t    s.match_length = 0;\n\t    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t    s.lookahead--;\n\t    s.strstart++;\n\t    if (bflush) {\n\t      /*** FLUSH_BLOCK(s, 0); ***/\n\t      flush_block_only(s, false);\n\t      if (s.strm.avail_out === 0) {\n\t        return BS_NEED_MORE;\n\t      }\n\t      /***/\n\t    }\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH) {\n\t    /*** FLUSH_BLOCK(s, 1); ***/\n\t    flush_block_only(s, true);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_FINISH_STARTED;\n\t    }\n\t    /***/\n\t    return BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t    /*** FLUSH_BLOCK(s, 0); ***/\n\t    flush_block_only(s, false);\n\t    if (s.strm.avail_out === 0) {\n\t      return BS_NEED_MORE;\n\t    }\n\t    /***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t}\n\t\n\t/* Values for max_lazy_match, good_match and max_chain_length, depending on\n\t * the desired pack level (0..9). The values given below have been tuned to\n\t * exclude worst case performance for pathological files. Better values may be\n\t * found for specific files.\n\t */\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\t  this.good_length = good_length;\n\t  this.max_lazy = max_lazy;\n\t  this.nice_length = nice_length;\n\t  this.max_chain = max_chain;\n\t  this.func = func;\n\t}\n\t\n\tvar configuration_table;\n\t\n\tconfiguration_table = [\n\t  /*      good lazy nice chain */\n\t  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n\t  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n\t  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n\t  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\t\n\t  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n\t  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n\t  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n\t  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n\t  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n\t  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n\t];\n\t\n\t\n\t/* ===========================================================================\n\t * Initialize the \"longest match\" routines for a new zlib stream\n\t */\n\tfunction lm_init(s) {\n\t  s.window_size = 2 * s.w_size;\n\t\n\t  /*** CLEAR_HASH(s); ***/\n\t  zero(s.head); // Fill with NIL (= 0);\n\t\n\t  /* Set the default configuration parameters:\n\t   */\n\t  s.max_lazy_match = configuration_table[s.level].max_lazy;\n\t  s.good_match = configuration_table[s.level].good_length;\n\t  s.nice_match = configuration_table[s.level].nice_length;\n\t  s.max_chain_length = configuration_table[s.level].max_chain;\n\t\n\t  s.strstart = 0;\n\t  s.block_start = 0;\n\t  s.lookahead = 0;\n\t  s.insert = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  s.ins_h = 0;\n\t}\n\t\n\t\n\tfunction DeflateState() {\n\t  this.strm = null;            /* pointer back to this zlib stream */\n\t  this.status = 0;            /* as the name implies */\n\t  this.pending_buf = null;      /* output still pending */\n\t  this.pending_buf_size = 0;  /* size of pending_buf */\n\t  this.pending_out = 0;       /* next pending byte to output to the stream */\n\t  this.pending = 0;           /* nb of bytes in the pending buffer */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.gzhead = null;         /* gzip header information to write */\n\t  this.gzindex = 0;           /* where in extra, name, or comment */\n\t  this.method = Z_DEFLATED; /* can only be DEFLATED */\n\t  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\t\n\t  this.w_size = 0;  /* LZ77 window size (32K by default) */\n\t  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n\t  this.w_mask = 0;  /* w_size - 1 */\n\t\n\t  this.window = null;\n\t  /* Sliding window. Input bytes are read into the second half of the window,\n\t   * and move to the first half later to keep a dictionary of at least wSize\n\t   * bytes. With this organization, matches are limited to a distance of\n\t   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t   * performed with a length multiple of the block size.\n\t   */\n\t\n\t  this.window_size = 0;\n\t  /* Actual size of window: 2*wSize, except when the user input buffer\n\t   * is directly used as sliding window.\n\t   */\n\t\n\t  this.prev = null;\n\t  /* Link to older string with same hash index. To limit the size of this\n\t   * array to 64K, this link is maintained only for the last 32K strings.\n\t   * An index in this array is thus a window index modulo 32K.\n\t   */\n\t\n\t  this.head = null;   /* Heads of the hash chains or NIL. */\n\t\n\t  this.ins_h = 0;       /* hash index of string to be inserted */\n\t  this.hash_size = 0;   /* number of elements in hash table */\n\t  this.hash_bits = 0;   /* log2(hash_size) */\n\t  this.hash_mask = 0;   /* hash_size-1 */\n\t\n\t  this.hash_shift = 0;\n\t  /* Number of bits by which ins_h must be shifted at each input\n\t   * step. It must be such that after MIN_MATCH steps, the oldest\n\t   * byte no longer takes part in the hash key, that is:\n\t   *   hash_shift * MIN_MATCH >= hash_bits\n\t   */\n\t\n\t  this.block_start = 0;\n\t  /* Window position at the beginning of the current output block. Gets\n\t   * negative when the window is moved backwards.\n\t   */\n\t\n\t  this.match_length = 0;      /* length of best match */\n\t  this.prev_match = 0;        /* previous match */\n\t  this.match_available = 0;   /* set if previous match exists */\n\t  this.strstart = 0;          /* start of string to insert */\n\t  this.match_start = 0;       /* start of matching string */\n\t  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\t\n\t  this.prev_length = 0;\n\t  /* Length of the best match at previous step. Matches not greater than this\n\t   * are discarded. This is used in the lazy match evaluation.\n\t   */\n\t\n\t  this.max_chain_length = 0;\n\t  /* To speed up deflation, hash chains are never searched beyond this\n\t   * length.  A higher limit improves compression ratio but degrades the\n\t   * speed.\n\t   */\n\t\n\t  this.max_lazy_match = 0;\n\t  /* Attempt to find a better match only when the current match is strictly\n\t   * smaller than this value. This mechanism is used only for compression\n\t   * levels >= 4.\n\t   */\n\t  // That's alias to max_lazy_match, don't use directly\n\t  //this.max_insert_length = 0;\n\t  /* Insert new strings in the hash table only if the match length is not\n\t   * greater than this length. This saves time but degrades compression.\n\t   * max_insert_length is used only for compression levels <= 3.\n\t   */\n\t\n\t  this.level = 0;     /* compression level (1..9) */\n\t  this.strategy = 0;  /* favor or force Huffman coding*/\n\t\n\t  this.good_match = 0;\n\t  /* Use a faster search when the previous match is longer than this */\n\t\n\t  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\t\n\t              /* used by trees.c: */\n\t\n\t  /* Didn't use ct_data typedef below to suppress compiler warning */\n\t\n\t  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n\t  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n\t  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\t\n\t  // Use flat array of DOUBLE size, with interleaved fata,\n\t  // because JS does not support effective\n\t  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n\t  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n\t  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n\t  zero(this.dyn_ltree);\n\t  zero(this.dyn_dtree);\n\t  zero(this.bl_tree);\n\t\n\t  this.l_desc   = null;         /* desc. for literal tree */\n\t  this.d_desc   = null;         /* desc. for distance tree */\n\t  this.bl_desc  = null;         /* desc. for bit length tree */\n\t\n\t  //ush bl_count[MAX_BITS+1];\n\t  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n\t\n\t  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\t  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n\t  zero(this.heap);\n\t\n\t  this.heap_len = 0;               /* number of elements in the heap */\n\t  this.heap_max = 0;               /* element of largest frequency */\n\t  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t   * The same heap array is used to build all trees.\n\t   */\n\t\n\t  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\t  zero(this.depth);\n\t  /* Depth of each subtree used as tie breaker for trees of equal frequency\n\t   */\n\t\n\t  this.l_buf = 0;          /* buffer index for literals or lengths */\n\t\n\t  this.lit_bufsize = 0;\n\t  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n\t   * limiting lit_bufsize to 64K:\n\t   *   - frequencies can be kept in 16 bit counters\n\t   *   - if compression is not successful for the first block, all input\n\t   *     data is still in the window so we can still emit a stored block even\n\t   *     when input comes from standard input.  (This can also be done for\n\t   *     all blocks if lit_bufsize is not greater than 32K.)\n\t   *   - if compression is not successful for a file smaller than 64K, we can\n\t   *     even emit a stored file instead of a stored block (saving 5 bytes).\n\t   *     This is applicable only for zip (not gzip or zlib).\n\t   *   - creating new Huffman trees less frequently may not provide fast\n\t   *     adaptation to changes in the input data statistics. (Take for\n\t   *     example a binary file with poorly compressible code followed by\n\t   *     a highly compressible string table.) Smaller buffer sizes give\n\t   *     fast adaptation but have of course the overhead of transmitting\n\t   *     trees more frequently.\n\t   *   - I can't count above 4\n\t   */\n\t\n\t  this.last_lit = 0;      /* running index in l_buf */\n\t\n\t  this.d_buf = 0;\n\t  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n\t   * the same number of elements. To use different lengths, an extra flag\n\t   * array would be necessary.\n\t   */\n\t\n\t  this.opt_len = 0;       /* bit length of current block with optimal trees */\n\t  this.static_len = 0;    /* bit length of current block with static trees */\n\t  this.matches = 0;       /* number of string matches in current block */\n\t  this.insert = 0;        /* bytes at end of window left to insert */\n\t\n\t\n\t  this.bi_buf = 0;\n\t  /* Output buffer. bits are inserted starting at the bottom (least\n\t   * significant bits).\n\t   */\n\t  this.bi_valid = 0;\n\t  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n\t   * are always zero.\n\t   */\n\t\n\t  // Used for window memory init. We safely ignore it for JS. That makes\n\t  // sense only for pointers and memory check tools.\n\t  //this.high_water = 0;\n\t  /* High water mark offset in window for initialized bytes -- bytes above\n\t   * this are set to zero in order to avoid memory check warnings when\n\t   * longest match routines access bytes past the input.  This is then\n\t   * updated to the new high water mark.\n\t   */\n\t}\n\t\n\t\n\tfunction deflateResetKeep(strm) {\n\t  var s;\n\t\n\t  if (!strm || !strm.state) {\n\t    return err(strm, Z_STREAM_ERROR);\n\t  }\n\t\n\t  strm.total_in = strm.total_out = 0;\n\t  strm.data_type = Z_UNKNOWN;\n\t\n\t  s = strm.state;\n\t  s.pending = 0;\n\t  s.pending_out = 0;\n\t\n\t  if (s.wrap < 0) {\n\t    s.wrap = -s.wrap;\n\t    /* was made negative by deflate(..., Z_FINISH); */\n\t  }\n\t  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n\t  strm.adler = (s.wrap === 2) ?\n\t    0  // crc32(0, Z_NULL, 0)\n\t  :\n\t    1; // adler32(0, Z_NULL, 0)\n\t  s.last_flush = Z_NO_FLUSH;\n\t  trees._tr_init(s);\n\t  return Z_OK;\n\t}\n\t\n\t\n\tfunction deflateReset(strm) {\n\t  var ret = deflateResetKeep(strm);\n\t  if (ret === Z_OK) {\n\t    lm_init(strm.state);\n\t  }\n\t  return ret;\n\t}\n\t\n\t\n\tfunction deflateSetHeader(strm, head) {\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n\t  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n\t  strm.state.gzhead = head;\n\t  return Z_OK;\n\t}\n\t\n\t\n\tfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n\t  if (!strm) { // === Z_NULL\n\t    return Z_STREAM_ERROR;\n\t  }\n\t  var wrap = 1;\n\t\n\t  if (level === Z_DEFAULT_COMPRESSION) {\n\t    level = 6;\n\t  }\n\t\n\t  if (windowBits < 0) { /* suppress zlib wrapper */\n\t    wrap = 0;\n\t    windowBits = -windowBits;\n\t  }\n\t\n\t  else if (windowBits > 15) {\n\t    wrap = 2;           /* write gzip wrapper instead */\n\t    windowBits -= 16;\n\t  }\n\t\n\t\n\t  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n\t    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n\t    strategy < 0 || strategy > Z_FIXED) {\n\t    return err(strm, Z_STREAM_ERROR);\n\t  }\n\t\n\t\n\t  if (windowBits === 8) {\n\t    windowBits = 9;\n\t  }\n\t  /* until 256-byte window bug fixed */\n\t\n\t  var s = new DeflateState();\n\t\n\t  strm.state = s;\n\t  s.strm = strm;\n\t\n\t  s.wrap = wrap;\n\t  s.gzhead = null;\n\t  s.w_bits = windowBits;\n\t  s.w_size = 1 << s.w_bits;\n\t  s.w_mask = s.w_size - 1;\n\t\n\t  s.hash_bits = memLevel + 7;\n\t  s.hash_size = 1 << s.hash_bits;\n\t  s.hash_mask = s.hash_size - 1;\n\t  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\t\n\t  s.window = new utils.Buf8(s.w_size * 2);\n\t  s.head = new utils.Buf16(s.hash_size);\n\t  s.prev = new utils.Buf16(s.w_size);\n\t\n\t  // Don't need mem init magic for JS.\n\t  //s.high_water = 0;  /* nothing written to s->window yet */\n\t\n\t  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\t\n\t  s.pending_buf_size = s.lit_bufsize * 4;\n\t\n\t  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n\t  //s->pending_buf = (uchf *) overlay;\n\t  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\t\n\t  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n\t  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\t  s.d_buf = 1 * s.lit_bufsize;\n\t\n\t  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\t  s.l_buf = (1 + 2) * s.lit_bufsize;\n\t\n\t  s.level = level;\n\t  s.strategy = strategy;\n\t  s.method = method;\n\t\n\t  return deflateReset(strm);\n\t}\n\t\n\tfunction deflateInit(strm, level) {\n\t  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\t}\n\t\n\t\n\tfunction deflate(strm, flush) {\n\t  var old_flush, s;\n\t  var beg, val; // for gzip header write only\n\t\n\t  if (!strm || !strm.state ||\n\t    flush > Z_BLOCK || flush < 0) {\n\t    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n\t  }\n\t\n\t  s = strm.state;\n\t\n\t  if (!strm.output ||\n\t      (!strm.input && strm.avail_in !== 0) ||\n\t      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n\t    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n\t  }\n\t\n\t  s.strm = strm; /* just in case */\n\t  old_flush = s.last_flush;\n\t  s.last_flush = flush;\n\t\n\t  /* Write the header */\n\t  if (s.status === INIT_STATE) {\n\t\n\t    if (s.wrap === 2) { // GZIP header\n\t      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n\t      put_byte(s, 31);\n\t      put_byte(s, 139);\n\t      put_byte(s, 8);\n\t      if (!s.gzhead) { // s->gzhead == Z_NULL\n\t        put_byte(s, 0);\n\t        put_byte(s, 0);\n\t        put_byte(s, 0);\n\t        put_byte(s, 0);\n\t        put_byte(s, 0);\n\t        put_byte(s, s.level === 9 ? 2 :\n\t                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t                     4 : 0));\n\t        put_byte(s, OS_CODE);\n\t        s.status = BUSY_STATE;\n\t      }\n\t      else {\n\t        put_byte(s, (s.gzhead.text ? 1 : 0) +\n\t                    (s.gzhead.hcrc ? 2 : 0) +\n\t                    (!s.gzhead.extra ? 0 : 4) +\n\t                    (!s.gzhead.name ? 0 : 8) +\n\t                    (!s.gzhead.comment ? 0 : 16)\n\t                );\n\t        put_byte(s, s.gzhead.time & 0xff);\n\t        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n\t        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n\t        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n\t        put_byte(s, s.level === 9 ? 2 :\n\t                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t                     4 : 0));\n\t        put_byte(s, s.gzhead.os & 0xff);\n\t        if (s.gzhead.extra && s.gzhead.extra.length) {\n\t          put_byte(s, s.gzhead.extra.length & 0xff);\n\t          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n\t        }\n\t        if (s.gzhead.hcrc) {\n\t          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n\t        }\n\t        s.gzindex = 0;\n\t        s.status = EXTRA_STATE;\n\t      }\n\t    }\n\t    else // DEFLATE header\n\t    {\n\t      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n\t      var level_flags = -1;\n\t\n\t      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n\t        level_flags = 0;\n\t      } else if (s.level < 6) {\n\t        level_flags = 1;\n\t      } else if (s.level === 6) {\n\t        level_flags = 2;\n\t      } else {\n\t        level_flags = 3;\n\t      }\n\t      header |= (level_flags << 6);\n\t      if (s.strstart !== 0) { header |= PRESET_DICT; }\n\t      header += 31 - (header % 31);\n\t\n\t      s.status = BUSY_STATE;\n\t      putShortMSB(s, header);\n\t\n\t      /* Save the adler32 of the preset dictionary: */\n\t      if (s.strstart !== 0) {\n\t        putShortMSB(s, strm.adler >>> 16);\n\t        putShortMSB(s, strm.adler & 0xffff);\n\t      }\n\t      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n\t    }\n\t  }\n\t\n\t//#ifdef GZIP\n\t  if (s.status === EXTRA_STATE) {\n\t    if (s.gzhead.extra/* != Z_NULL*/) {\n\t      beg = s.pending;  /* start of bytes to update crc */\n\t\n\t      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n\t        if (s.pending === s.pending_buf_size) {\n\t          if (s.gzhead.hcrc && s.pending > beg) {\n\t            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t          }\n\t          flush_pending(strm);\n\t          beg = s.pending;\n\t          if (s.pending === s.pending_buf_size) {\n\t            break;\n\t          }\n\t        }\n\t        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n\t        s.gzindex++;\n\t      }\n\t      if (s.gzhead.hcrc && s.pending > beg) {\n\t        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t      }\n\t      if (s.gzindex === s.gzhead.extra.length) {\n\t        s.gzindex = 0;\n\t        s.status = NAME_STATE;\n\t      }\n\t    }\n\t    else {\n\t      s.status = NAME_STATE;\n\t    }\n\t  }\n\t  if (s.status === NAME_STATE) {\n\t    if (s.gzhead.name/* != Z_NULL*/) {\n\t      beg = s.pending;  /* start of bytes to update crc */\n\t      //int val;\n\t\n\t      do {\n\t        if (s.pending === s.pending_buf_size) {\n\t          if (s.gzhead.hcrc && s.pending > beg) {\n\t            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t          }\n\t          flush_pending(strm);\n\t          beg = s.pending;\n\t          if (s.pending === s.pending_buf_size) {\n\t            val = 1;\n\t            break;\n\t          }\n\t        }\n\t        // JS specific: little magic to add zero terminator to end of string\n\t        if (s.gzindex < s.gzhead.name.length) {\n\t          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n\t        } else {\n\t          val = 0;\n\t        }\n\t        put_byte(s, val);\n\t      } while (val !== 0);\n\t\n\t      if (s.gzhead.hcrc && s.pending > beg) {\n\t        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t      }\n\t      if (val === 0) {\n\t        s.gzindex = 0;\n\t        s.status = COMMENT_STATE;\n\t      }\n\t    }\n\t    else {\n\t      s.status = COMMENT_STATE;\n\t    }\n\t  }\n\t  if (s.status === COMMENT_STATE) {\n\t    if (s.gzhead.comment/* != Z_NULL*/) {\n\t      beg = s.pending;  /* start of bytes to update crc */\n\t      //int val;\n\t\n\t      do {\n\t        if (s.pending === s.pending_buf_size) {\n\t          if (s.gzhead.hcrc && s.pending > beg) {\n\t            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t          }\n\t          flush_pending(strm);\n\t          beg = s.pending;\n\t          if (s.pending === s.pending_buf_size) {\n\t            val = 1;\n\t            break;\n\t          }\n\t        }\n\t        // JS specific: little magic to add zero terminator to end of string\n\t        if (s.gzindex < s.gzhead.comment.length) {\n\t          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n\t        } else {\n\t          val = 0;\n\t        }\n\t        put_byte(s, val);\n\t      } while (val !== 0);\n\t\n\t      if (s.gzhead.hcrc && s.pending > beg) {\n\t        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t      }\n\t      if (val === 0) {\n\t        s.status = HCRC_STATE;\n\t      }\n\t    }\n\t    else {\n\t      s.status = HCRC_STATE;\n\t    }\n\t  }\n\t  if (s.status === HCRC_STATE) {\n\t    if (s.gzhead.hcrc) {\n\t      if (s.pending + 2 > s.pending_buf_size) {\n\t        flush_pending(strm);\n\t      }\n\t      if (s.pending + 2 <= s.pending_buf_size) {\n\t        put_byte(s, strm.adler & 0xff);\n\t        put_byte(s, (strm.adler >> 8) & 0xff);\n\t        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\t        s.status = BUSY_STATE;\n\t      }\n\t    }\n\t    else {\n\t      s.status = BUSY_STATE;\n\t    }\n\t  }\n\t//#endif\n\t\n\t  /* Flush as much pending output as possible */\n\t  if (s.pending !== 0) {\n\t    flush_pending(strm);\n\t    if (strm.avail_out === 0) {\n\t      /* Since avail_out is 0, deflate will be called again with\n\t       * more output space, but possibly with both pending and\n\t       * avail_in equal to zero. There won't be anything to do,\n\t       * but this is not an error situation so make sure we\n\t       * return OK instead of BUF_ERROR at next call of deflate:\n\t       */\n\t      s.last_flush = -1;\n\t      return Z_OK;\n\t    }\n\t\n\t    /* Make sure there is something to do and avoid duplicate consecutive\n\t     * flushes. For repeated and useless calls with Z_FINISH, we keep\n\t     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n\t     */\n\t  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n\t    flush !== Z_FINISH) {\n\t    return err(strm, Z_BUF_ERROR);\n\t  }\n\t\n\t  /* User must not provide more input after the first FINISH: */\n\t  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n\t    return err(strm, Z_BUF_ERROR);\n\t  }\n\t\n\t  /* Start a new block or continue the current one.\n\t   */\n\t  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n\t    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n\t    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n\t      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n\t        configuration_table[s.level].func(s, flush));\n\t\n\t    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n\t      s.status = FINISH_STATE;\n\t    }\n\t    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n\t      if (strm.avail_out === 0) {\n\t        s.last_flush = -1;\n\t        /* avoid BUF_ERROR next call, see above */\n\t      }\n\t      return Z_OK;\n\t      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n\t       * of deflate should use the same flush parameter to make sure\n\t       * that the flush is complete. So we don't have to output an\n\t       * empty block here, this will be done at next call. This also\n\t       * ensures that for a very small output buffer, we emit at most\n\t       * one empty block.\n\t       */\n\t    }\n\t    if (bstate === BS_BLOCK_DONE) {\n\t      if (flush === Z_PARTIAL_FLUSH) {\n\t        trees._tr_align(s);\n\t      }\n\t      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\t\n\t        trees._tr_stored_block(s, 0, 0, false);\n\t        /* For a full flush, this empty block will be recognized\n\t         * as a special marker by inflate_sync().\n\t         */\n\t        if (flush === Z_FULL_FLUSH) {\n\t          /*** CLEAR_HASH(s); ***/             /* forget history */\n\t          zero(s.head); // Fill with NIL (= 0);\n\t\n\t          if (s.lookahead === 0) {\n\t            s.strstart = 0;\n\t            s.block_start = 0;\n\t            s.insert = 0;\n\t          }\n\t        }\n\t      }\n\t      flush_pending(strm);\n\t      if (strm.avail_out === 0) {\n\t        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n\t        return Z_OK;\n\t      }\n\t    }\n\t  }\n\t  //Assert(strm->avail_out > 0, \"bug2\");\n\t  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\t\n\t  if (flush !== Z_FINISH) { return Z_OK; }\n\t  if (s.wrap <= 0) { return Z_STREAM_END; }\n\t\n\t  /* Write the trailer */\n\t  if (s.wrap === 2) {\n\t    put_byte(s, strm.adler & 0xff);\n\t    put_byte(s, (strm.adler >> 8) & 0xff);\n\t    put_byte(s, (strm.adler >> 16) & 0xff);\n\t    put_byte(s, (strm.adler >> 24) & 0xff);\n\t    put_byte(s, strm.total_in & 0xff);\n\t    put_byte(s, (strm.total_in >> 8) & 0xff);\n\t    put_byte(s, (strm.total_in >> 16) & 0xff);\n\t    put_byte(s, (strm.total_in >> 24) & 0xff);\n\t  }\n\t  else\n\t  {\n\t    putShortMSB(s, strm.adler >>> 16);\n\t    putShortMSB(s, strm.adler & 0xffff);\n\t  }\n\t\n\t  flush_pending(strm);\n\t  /* If avail_out is zero, the application will call deflate again\n\t   * to flush the rest.\n\t   */\n\t  if (s.wrap > 0) { s.wrap = -s.wrap; }\n\t  /* write the trailer only once! */\n\t  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n\t}\n\t\n\tfunction deflateEnd(strm) {\n\t  var status;\n\t\n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  status = strm.state.status;\n\t  if (status !== INIT_STATE &&\n\t    status !== EXTRA_STATE &&\n\t    status !== NAME_STATE &&\n\t    status !== COMMENT_STATE &&\n\t    status !== HCRC_STATE &&\n\t    status !== BUSY_STATE &&\n\t    status !== FINISH_STATE\n\t  ) {\n\t    return err(strm, Z_STREAM_ERROR);\n\t  }\n\t\n\t  strm.state = null;\n\t\n\t  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n\t}\n\t\n\t\n\t/* =========================================================================\n\t * Initializes the compression dictionary from the given byte\n\t * sequence without producing any compressed output.\n\t */\n\tfunction deflateSetDictionary(strm, dictionary) {\n\t  var dictLength = dictionary.length;\n\t\n\t  var s;\n\t  var str, n;\n\t  var wrap;\n\t  var avail;\n\t  var next;\n\t  var input;\n\t  var tmpDict;\n\t\n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  s = strm.state;\n\t  wrap = s.wrap;\n\t\n\t  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\t  if (wrap === 1) {\n\t    /* adler32(strm->adler, dictionary, dictLength); */\n\t    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n\t  }\n\t\n\t  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\t\n\t  /* if dictionary would fill window, just replace the history */\n\t  if (dictLength >= s.w_size) {\n\t    if (wrap === 0) {            /* already empty otherwise */\n\t      /*** CLEAR_HASH(s); ***/\n\t      zero(s.head); // Fill with NIL (= 0);\n\t      s.strstart = 0;\n\t      s.block_start = 0;\n\t      s.insert = 0;\n\t    }\n\t    /* use the tail */\n\t    // dictionary = dictionary.slice(dictLength - s.w_size);\n\t    tmpDict = new utils.Buf8(s.w_size);\n\t    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n\t    dictionary = tmpDict;\n\t    dictLength = s.w_size;\n\t  }\n\t  /* insert dictionary into window and hash */\n\t  avail = strm.avail_in;\n\t  next = strm.next_in;\n\t  input = strm.input;\n\t  strm.avail_in = dictLength;\n\t  strm.next_in = 0;\n\t  strm.input = dictionary;\n\t  fill_window(s);\n\t  while (s.lookahead >= MIN_MATCH) {\n\t    str = s.strstart;\n\t    n = s.lookahead - (MIN_MATCH - 1);\n\t    do {\n\t      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\t\n\t      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\t\n\t      s.head[s.ins_h] = str;\n\t      str++;\n\t    } while (--n);\n\t    s.strstart = str;\n\t    s.lookahead = MIN_MATCH - 1;\n\t    fill_window(s);\n\t  }\n\t  s.strstart += s.lookahead;\n\t  s.block_start = s.strstart;\n\t  s.insert = s.lookahead;\n\t  s.lookahead = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  strm.next_in = next;\n\t  strm.input = input;\n\t  strm.avail_in = avail;\n\t  s.wrap = wrap;\n\t  return Z_OK;\n\t}\n\t\n\t\n\texports.deflateInit = deflateInit;\n\texports.deflateInit2 = deflateInit2;\n\texports.deflateReset = deflateReset;\n\texports.deflateResetKeep = deflateResetKeep;\n\texports.deflateSetHeader = deflateSetHeader;\n\texports.deflate = deflate;\n\texports.deflateEnd = deflateEnd;\n\texports.deflateSetDictionary = deflateSetDictionary;\n\texports.deflateInfo = 'pako deflate (from Nodeca project)';\n\t\n\t/* Not implemented\n\texports.deflateBound = deflateBound;\n\texports.deflateCopy = deflateCopy;\n\texports.deflateParams = deflateParams;\n\texports.deflatePending = deflatePending;\n\texports.deflatePrime = deflatePrime;\n\texports.deflateTune = deflateTune;\n\t*/\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n\t                (typeof Uint16Array !== 'undefined') &&\n\t                (typeof Int32Array !== 'undefined');\n\t\n\t\n\texports.assign = function (obj /*from1, from2, from3, ...*/) {\n\t  var sources = Array.prototype.slice.call(arguments, 1);\n\t  while (sources.length) {\n\t    var source = sources.shift();\n\t    if (!source) { continue; }\n\t\n\t    if (typeof source !== 'object') {\n\t      throw new TypeError(source + 'must be non-object');\n\t    }\n\t\n\t    for (var p in source) {\n\t      if (source.hasOwnProperty(p)) {\n\t        obj[p] = source[p];\n\t      }\n\t    }\n\t  }\n\t\n\t  return obj;\n\t};\n\t\n\t\n\t// reduce buffer size, avoiding mem copy\n\texports.shrinkBuf = function (buf, size) {\n\t  if (buf.length === size) { return buf; }\n\t  if (buf.subarray) { return buf.subarray(0, size); }\n\t  buf.length = size;\n\t  return buf;\n\t};\n\t\n\t\n\tvar fnTyped = {\n\t  arraySet: function (dest, src, src_offs, len, dest_offs) {\n\t    if (src.subarray && dest.subarray) {\n\t      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n\t      return;\n\t    }\n\t    // Fallback to ordinary array\n\t    for (var i = 0; i < len; i++) {\n\t      dest[dest_offs + i] = src[src_offs + i];\n\t    }\n\t  },\n\t  // Join array of chunks to single array.\n\t  flattenChunks: function (chunks) {\n\t    var i, l, len, pos, chunk, result;\n\t\n\t    // calculate data length\n\t    len = 0;\n\t    for (i = 0, l = chunks.length; i < l; i++) {\n\t      len += chunks[i].length;\n\t    }\n\t\n\t    // join chunks\n\t    result = new Uint8Array(len);\n\t    pos = 0;\n\t    for (i = 0, l = chunks.length; i < l; i++) {\n\t      chunk = chunks[i];\n\t      result.set(chunk, pos);\n\t      pos += chunk.length;\n\t    }\n\t\n\t    return result;\n\t  }\n\t};\n\t\n\tvar fnUntyped = {\n\t  arraySet: function (dest, src, src_offs, len, dest_offs) {\n\t    for (var i = 0; i < len; i++) {\n\t      dest[dest_offs + i] = src[src_offs + i];\n\t    }\n\t  },\n\t  // Join array of chunks to single array.\n\t  flattenChunks: function (chunks) {\n\t    return [].concat.apply([], chunks);\n\t  }\n\t};\n\t\n\t\n\t// Enable/Disable typed arrays use, for testing\n\t//\n\texports.setTyped = function (on) {\n\t  if (on) {\n\t    exports.Buf8  = Uint8Array;\n\t    exports.Buf16 = Uint16Array;\n\t    exports.Buf32 = Int32Array;\n\t    exports.assign(exports, fnTyped);\n\t  } else {\n\t    exports.Buf8  = Array;\n\t    exports.Buf16 = Array;\n\t    exports.Buf32 = Array;\n\t    exports.assign(exports, fnUntyped);\n\t  }\n\t};\n\t\n\texports.setTyped(TYPED_OK);\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar utils = __webpack_require__(36);\n\t\n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n\t\n\t\n\t//var Z_FILTERED          = 1;\n\t//var Z_HUFFMAN_ONLY      = 2;\n\t//var Z_RLE               = 3;\n\tvar Z_FIXED               = 4;\n\t//var Z_DEFAULT_STRATEGY  = 0;\n\t\n\t/* Possible values of the data_type field (though see inflate()) */\n\tvar Z_BINARY              = 0;\n\tvar Z_TEXT                = 1;\n\t//var Z_ASCII             = 1; // = Z_TEXT\n\tvar Z_UNKNOWN             = 2;\n\t\n\t/*============================================================================*/\n\t\n\t\n\tfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\t\n\t// From zutil.h\n\t\n\tvar STORED_BLOCK = 0;\n\tvar STATIC_TREES = 1;\n\tvar DYN_TREES    = 2;\n\t/* The three kinds of block type */\n\t\n\tvar MIN_MATCH    = 3;\n\tvar MAX_MATCH    = 258;\n\t/* The minimum and maximum match lengths */\n\t\n\t// From deflate.h\n\t/* ===========================================================================\n\t * Internal compression state.\n\t */\n\t\n\tvar LENGTH_CODES  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n\t\n\tvar LITERALS      = 256;\n\t/* number of literal bytes 0..255 */\n\t\n\tvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n\t\n\tvar D_CODES       = 30;\n\t/* number of distance codes */\n\t\n\tvar BL_CODES      = 19;\n\t/* number of codes used to transfer the bit lengths */\n\t\n\tvar HEAP_SIZE     = 2 * L_CODES + 1;\n\t/* maximum heap size */\n\t\n\tvar MAX_BITS      = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n\t\n\tvar Buf_size      = 16;\n\t/* size of bit buffer in bi_buf */\n\t\n\t\n\t/* ===========================================================================\n\t * Constants\n\t */\n\t\n\tvar MAX_BL_BITS = 7;\n\t/* Bit length codes must not exceed MAX_BL_BITS bits */\n\t\n\tvar END_BLOCK   = 256;\n\t/* end of block literal code */\n\t\n\tvar REP_3_6     = 16;\n\t/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\t\n\tvar REPZ_3_10   = 17;\n\t/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\t\n\tvar REPZ_11_138 = 18;\n\t/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\t\n\t/* eslint-disable comma-spacing,array-bracket-spacing */\n\tvar extra_lbits =   /* extra bits for each length code */\n\t  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\t\n\tvar extra_dbits =   /* extra bits for each distance code */\n\t  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\t\n\tvar extra_blbits =  /* extra bits for each bit length code */\n\t  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\t\n\tvar bl_order =\n\t  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n\t/* eslint-enable comma-spacing,array-bracket-spacing */\n\t\n\t/* The lengths of the bit length codes are sent in order of decreasing\n\t * probability, to avoid transmitting the lengths for unused bit length codes.\n\t */\n\t\n\t/* ===========================================================================\n\t * Local data. These are initialized only once.\n\t */\n\t\n\t// We pre-fill arrays with 0 to avoid uninitialized gaps\n\t\n\tvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\t\n\t// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\n\tvar static_ltree  = new Array((L_CODES + 2) * 2);\n\tzero(static_ltree);\n\t/* The static literal tree. Since the bit lengths are imposed, there is no\n\t * need for the L_CODES extra codes used during heap construction. However\n\t * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n\t * below).\n\t */\n\t\n\tvar static_dtree  = new Array(D_CODES * 2);\n\tzero(static_dtree);\n\t/* The static distance tree. (Actually a trivial tree since all codes use\n\t * 5 bits.)\n\t */\n\t\n\tvar _dist_code    = new Array(DIST_CODE_LEN);\n\tzero(_dist_code);\n\t/* Distance codes. The first 256 values correspond to the distances\n\t * 3 .. 258, the last 256 values correspond to the top 8 bits of\n\t * the 15 bit distances.\n\t */\n\t\n\tvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\n\tzero(_length_code);\n\t/* length code for each normalized match length (0 == MIN_MATCH) */\n\t\n\tvar base_length   = new Array(LENGTH_CODES);\n\tzero(base_length);\n\t/* First normalized length for each code (0 = MIN_MATCH) */\n\t\n\tvar base_dist     = new Array(D_CODES);\n\tzero(base_dist);\n\t/* First normalized distance for each code (0 = distance of 1) */\n\t\n\t\n\tfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\t\n\t  this.static_tree  = static_tree;  /* static tree or NULL */\n\t  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n\t  this.extra_base   = extra_base;   /* base index for extra_bits */\n\t  this.elems        = elems;        /* max number of elements in the tree */\n\t  this.max_length   = max_length;   /* max bit length for the codes */\n\t\n\t  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\t  this.has_stree    = static_tree && static_tree.length;\n\t}\n\t\n\t\n\tvar static_l_desc;\n\tvar static_d_desc;\n\tvar static_bl_desc;\n\t\n\t\n\tfunction TreeDesc(dyn_tree, stat_desc) {\n\t  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n\t  this.max_code = 0;            /* largest code with non zero frequency */\n\t  this.stat_desc = stat_desc;   /* the corresponding static tree */\n\t}\n\t\n\t\n\t\n\tfunction d_code(dist) {\n\t  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Output a short LSB first on the stream.\n\t * IN assertion: there is enough room in pendingBuf.\n\t */\n\tfunction put_short(s, w) {\n\t//    put_byte(s, (uch)((w) & 0xff));\n\t//    put_byte(s, (uch)((ush)(w) >> 8));\n\t  s.pending_buf[s.pending++] = (w) & 0xff;\n\t  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Send a value on a given number of bits.\n\t * IN assertion: length <= 16 and value fits in length bits.\n\t */\n\tfunction send_bits(s, value, length) {\n\t  if (s.bi_valid > (Buf_size - length)) {\n\t    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t    put_short(s, s.bi_buf);\n\t    s.bi_buf = value >> (Buf_size - s.bi_valid);\n\t    s.bi_valid += length - Buf_size;\n\t  } else {\n\t    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t    s.bi_valid += length;\n\t  }\n\t}\n\t\n\t\n\tfunction send_code(s, c, tree) {\n\t  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Reverse the first len bits of a code, using straightforward code (a faster\n\t * method would use a table)\n\t * IN assertion: 1 <= len <= 15\n\t */\n\tfunction bi_reverse(code, len) {\n\t  var res = 0;\n\t  do {\n\t    res |= code & 1;\n\t    code >>>= 1;\n\t    res <<= 1;\n\t  } while (--len > 0);\n\t  return res >>> 1;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Flush the bit buffer, keeping at most 7 bits in it.\n\t */\n\tfunction bi_flush(s) {\n\t  if (s.bi_valid === 16) {\n\t    put_short(s, s.bi_buf);\n\t    s.bi_buf = 0;\n\t    s.bi_valid = 0;\n\t\n\t  } else if (s.bi_valid >= 8) {\n\t    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n\t    s.bi_buf >>= 8;\n\t    s.bi_valid -= 8;\n\t  }\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Compute the optimal bit lengths for a tree and update the total bit length\n\t * for the current block.\n\t * IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t *    above are the tree nodes sorted by increasing frequency.\n\t * OUT assertions: the field len is set to the optimal bit length, the\n\t *     array bl_count contains the frequencies for each bit length.\n\t *     The length opt_len is updated; static_len is also updated if stree is\n\t *     not null.\n\t */\n\tfunction gen_bitlen(s, desc)\n\t//    deflate_state *s;\n\t//    tree_desc *desc;    /* the tree descriptor */\n\t{\n\t  var tree            = desc.dyn_tree;\n\t  var max_code        = desc.max_code;\n\t  var stree           = desc.stat_desc.static_tree;\n\t  var has_stree       = desc.stat_desc.has_stree;\n\t  var extra           = desc.stat_desc.extra_bits;\n\t  var base            = desc.stat_desc.extra_base;\n\t  var max_length      = desc.stat_desc.max_length;\n\t  var h;              /* heap index */\n\t  var n, m;           /* iterate over the tree elements */\n\t  var bits;           /* bit length */\n\t  var xbits;          /* extra bits */\n\t  var f;              /* frequency */\n\t  var overflow = 0;   /* number of elements with bit length too large */\n\t\n\t  for (bits = 0; bits <= MAX_BITS; bits++) {\n\t    s.bl_count[bits] = 0;\n\t  }\n\t\n\t  /* In a first pass, compute the optimal bit lengths (which may\n\t   * overflow in the case of the bit length tree).\n\t   */\n\t  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\t\n\t  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t    n = s.heap[h];\n\t    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n\t    if (bits > max_length) {\n\t      bits = max_length;\n\t      overflow++;\n\t    }\n\t    tree[n * 2 + 1]/*.Len*/ = bits;\n\t    /* We overwrite tree[n].Dad which is no longer needed */\n\t\n\t    if (n > max_code) { continue; } /* not a leaf node */\n\t\n\t    s.bl_count[bits]++;\n\t    xbits = 0;\n\t    if (n >= base) {\n\t      xbits = extra[n - base];\n\t    }\n\t    f = tree[n * 2]/*.Freq*/;\n\t    s.opt_len += f * (bits + xbits);\n\t    if (has_stree) {\n\t      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n\t    }\n\t  }\n\t  if (overflow === 0) { return; }\n\t\n\t  // Trace((stderr,\"\\nbit length overflow\\n\"));\n\t  /* This happens for example on obj2 and pic of the Calgary corpus */\n\t\n\t  /* Find the first bit length which could increase: */\n\t  do {\n\t    bits = max_length - 1;\n\t    while (s.bl_count[bits] === 0) { bits--; }\n\t    s.bl_count[bits]--;      /* move one leaf down the tree */\n\t    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n\t    s.bl_count[max_length]--;\n\t    /* The brother of the overflow item also moves one step up,\n\t     * but this does not affect bl_count[max_length]\n\t     */\n\t    overflow -= 2;\n\t  } while (overflow > 0);\n\t\n\t  /* Now recompute all bit lengths, scanning in increasing frequency.\n\t   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n\t   * lengths instead of fixing only the wrong ones. This idea is taken\n\t   * from 'ar' written by Haruhiko Okumura.)\n\t   */\n\t  for (bits = max_length; bits !== 0; bits--) {\n\t    n = s.bl_count[bits];\n\t    while (n !== 0) {\n\t      m = s.heap[--h];\n\t      if (m > max_code) { continue; }\n\t      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n\t        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n\t        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n\t        tree[m * 2 + 1]/*.Len*/ = bits;\n\t      }\n\t      n--;\n\t    }\n\t  }\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Generate the codes for a given tree and bit counts (which need not be\n\t * optimal).\n\t * IN assertion: the array bl_count contains the bit length statistics for\n\t * the given tree and the field len is set for all tree elements.\n\t * OUT assertion: the field code is set for all tree elements of non\n\t *     zero code length.\n\t */\n\tfunction gen_codes(tree, max_code, bl_count)\n\t//    ct_data *tree;             /* the tree to decorate */\n\t//    int max_code;              /* largest code with non zero frequency */\n\t//    ushf *bl_count;            /* number of codes at each bit length */\n\t{\n\t  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n\t  var code = 0;              /* running code value */\n\t  var bits;                  /* bit index */\n\t  var n;                     /* code index */\n\t\n\t  /* The distribution counts are first used to generate the code values\n\t   * without bit reversal.\n\t   */\n\t  for (bits = 1; bits <= MAX_BITS; bits++) {\n\t    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n\t  }\n\t  /* Check that the bit counts in bl_count are consistent. The last code\n\t   * must be all ones.\n\t   */\n\t  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t  //        \"inconsistent bit counts\");\n\t  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\t\n\t  for (n = 0;  n <= max_code; n++) {\n\t    var len = tree[n * 2 + 1]/*.Len*/;\n\t    if (len === 0) { continue; }\n\t    /* Now reverse the bits */\n\t    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\t\n\t    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n\t    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n\t  }\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Initialize the various 'constant' tables.\n\t */\n\tfunction tr_static_init() {\n\t  var n;        /* iterates over tree elements */\n\t  var bits;     /* bit counter */\n\t  var length;   /* length value */\n\t  var code;     /* code value */\n\t  var dist;     /* distance index */\n\t  var bl_count = new Array(MAX_BITS + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n\t\n\t  // do check in _tr_init()\n\t  //if (static_init_done) return;\n\t\n\t  /* For some embedded targets, global variables are not initialized: */\n\t/*#ifdef NO_INIT_GLOBAL_POINTERS\n\t  static_l_desc.static_tree = static_ltree;\n\t  static_l_desc.extra_bits = extra_lbits;\n\t  static_d_desc.static_tree = static_dtree;\n\t  static_d_desc.extra_bits = extra_dbits;\n\t  static_bl_desc.extra_bits = extra_blbits;\n\t#endif*/\n\t\n\t  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\t  length = 0;\n\t  for (code = 0; code < LENGTH_CODES - 1; code++) {\n\t    base_length[code] = length;\n\t    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n\t      _length_code[length++] = code;\n\t    }\n\t  }\n\t  //Assert (length == 256, \"tr_static_init: length != 256\");\n\t  /* Note that the length 255 (match length 258) can be represented\n\t   * in two different ways: code 284 + 5 bits or code 285, so we\n\t   * overwrite length_code[255] to use the best encoding:\n\t   */\n\t  _length_code[length - 1] = code;\n\t\n\t  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\t  dist = 0;\n\t  for (code = 0; code < 16; code++) {\n\t    base_dist[code] = dist;\n\t    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n\t      _dist_code[dist++] = code;\n\t    }\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\t  dist >>= 7; /* from now on, all distances are divided by 128 */\n\t  for (; code < D_CODES; code++) {\n\t    base_dist[code] = dist << 7;\n\t    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n\t      _dist_code[256 + dist++] = code;\n\t    }\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\t\n\t  /* Construct the codes of the static literal tree */\n\t  for (bits = 0; bits <= MAX_BITS; bits++) {\n\t    bl_count[bits] = 0;\n\t  }\n\t\n\t  n = 0;\n\t  while (n <= 143) {\n\t    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t    n++;\n\t    bl_count[8]++;\n\t  }\n\t  while (n <= 255) {\n\t    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n\t    n++;\n\t    bl_count[9]++;\n\t  }\n\t  while (n <= 279) {\n\t    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n\t    n++;\n\t    bl_count[7]++;\n\t  }\n\t  while (n <= 287) {\n\t    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t    n++;\n\t    bl_count[8]++;\n\t  }\n\t  /* Codes 286 and 287 do not exist, but we must include them in the\n\t   * tree construction to get a canonical Huffman tree (longest code\n\t   * all ones)\n\t   */\n\t  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\t\n\t  /* The static distance tree is trivial: */\n\t  for (n = 0; n < D_CODES; n++) {\n\t    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n\t    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n\t  }\n\t\n\t  // Now data ready and we can init static trees\n\t  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n\t  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n\t  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\t\n\t  //static_init_done = true;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Initialize a new block.\n\t */\n\tfunction init_block(s) {\n\t  var n; /* iterates over tree elements */\n\t\n\t  /* Initialize the trees. */\n\t  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\t\n\t  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n\t  s.opt_len = s.static_len = 0;\n\t  s.last_lit = s.matches = 0;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Flush the bit buffer and align the output on a byte boundary\n\t */\n\tfunction bi_windup(s)\n\t{\n\t  if (s.bi_valid > 8) {\n\t    put_short(s, s.bi_buf);\n\t  } else if (s.bi_valid > 0) {\n\t    //put_byte(s, (Byte)s->bi_buf);\n\t    s.pending_buf[s.pending++] = s.bi_buf;\n\t  }\n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n\t}\n\t\n\t/* ===========================================================================\n\t * Copy a stored block, storing first the length and its\n\t * one's complement if requested.\n\t */\n\tfunction copy_block(s, buf, len, header)\n\t//DeflateState *s;\n\t//charf    *buf;    /* the input data */\n\t//unsigned len;     /* its length */\n\t//int      header;  /* true if block header must be written */\n\t{\n\t  bi_windup(s);        /* align on byte boundary */\n\t\n\t  if (header) {\n\t    put_short(s, len);\n\t    put_short(s, ~len);\n\t  }\n\t//  while (len--) {\n\t//    put_byte(s, *buf++);\n\t//  }\n\t  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n\t  s.pending += len;\n\t}\n\t\n\t/* ===========================================================================\n\t * Compares to subtrees, using the tree depth as tie breaker when\n\t * the subtrees have equal frequency. This minimizes the worst case length.\n\t */\n\tfunction smaller(tree, n, m, depth) {\n\t  var _n2 = n * 2;\n\t  var _m2 = m * 2;\n\t  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n\t         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n\t}\n\t\n\t/* ===========================================================================\n\t * Restore the heap property by moving down the tree starting at node k,\n\t * exchanging a node with the smallest of its two sons if necessary, stopping\n\t * when the heap property is re-established (each father smaller than its\n\t * two sons).\n\t */\n\tfunction pqdownheap(s, tree, k)\n\t//    deflate_state *s;\n\t//    ct_data *tree;  /* the tree to restore */\n\t//    int k;               /* node to move down */\n\t{\n\t  var v = s.heap[k];\n\t  var j = k << 1;  /* left son of k */\n\t  while (j <= s.heap_len) {\n\t    /* Set j to the smallest of the two sons: */\n\t    if (j < s.heap_len &&\n\t      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n\t      j++;\n\t    }\n\t    /* Exit if v is smaller than both sons */\n\t    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\t\n\t    /* Exchange v with the smallest son */\n\t    s.heap[k] = s.heap[j];\n\t    k = j;\n\t\n\t    /* And continue down the tree, setting j to the left son of k */\n\t    j <<= 1;\n\t  }\n\t  s.heap[k] = v;\n\t}\n\t\n\t\n\t// inlined manually\n\t// var SMALLEST = 1;\n\t\n\t/* ===========================================================================\n\t * Send the block data compressed using the given Huffman trees\n\t */\n\tfunction compress_block(s, ltree, dtree)\n\t//    deflate_state *s;\n\t//    const ct_data *ltree; /* literal tree */\n\t//    const ct_data *dtree; /* distance tree */\n\t{\n\t  var dist;           /* distance of matched string */\n\t  var lc;             /* match length or unmatched char (if dist == 0) */\n\t  var lx = 0;         /* running index in l_buf */\n\t  var code;           /* the code to send */\n\t  var extra;          /* number of extra bits to send */\n\t\n\t  if (s.last_lit !== 0) {\n\t    do {\n\t      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n\t      lc = s.pending_buf[s.l_buf + lx];\n\t      lx++;\n\t\n\t      if (dist === 0) {\n\t        send_code(s, lc, ltree); /* send a literal byte */\n\t        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t      } else {\n\t        /* Here, lc is the match length - MIN_MATCH */\n\t        code = _length_code[lc];\n\t        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n\t        extra = extra_lbits[code];\n\t        if (extra !== 0) {\n\t          lc -= base_length[code];\n\t          send_bits(s, lc, extra);       /* send the extra length bits */\n\t        }\n\t        dist--; /* dist is now the match distance - 1 */\n\t        code = d_code(dist);\n\t        //Assert (code < D_CODES, \"bad d_code\");\n\t\n\t        send_code(s, code, dtree);       /* send the distance code */\n\t        extra = extra_dbits[code];\n\t        if (extra !== 0) {\n\t          dist -= base_dist[code];\n\t          send_bits(s, dist, extra);   /* send the extra distance bits */\n\t        }\n\t      } /* literal or match pair ? */\n\t\n\t      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n\t      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n\t      //       \"pendingBuf overflow\");\n\t\n\t    } while (lx < s.last_lit);\n\t  }\n\t\n\t  send_code(s, END_BLOCK, ltree);\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Construct one Huffman tree and assigns the code bit strings and lengths.\n\t * Update the total bit length for the current block.\n\t * IN assertion: the field freq is set for all tree elements.\n\t * OUT assertions: the fields len and code are set to the optimal bit length\n\t *     and corresponding code. The length opt_len is updated; static_len is\n\t *     also updated if stree is not null. The field max_code is set.\n\t */\n\tfunction build_tree(s, desc)\n\t//    deflate_state *s;\n\t//    tree_desc *desc; /* the tree descriptor */\n\t{\n\t  var tree     = desc.dyn_tree;\n\t  var stree    = desc.stat_desc.static_tree;\n\t  var has_stree = desc.stat_desc.has_stree;\n\t  var elems    = desc.stat_desc.elems;\n\t  var n, m;          /* iterate over heap elements */\n\t  var max_code = -1; /* largest code with non zero frequency */\n\t  var node;          /* new node being created */\n\t\n\t  /* Construct the initial heap, with least frequent element in\n\t   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t   * heap[0] is not used.\n\t   */\n\t  s.heap_len = 0;\n\t  s.heap_max = HEAP_SIZE;\n\t\n\t  for (n = 0; n < elems; n++) {\n\t    if (tree[n * 2]/*.Freq*/ !== 0) {\n\t      s.heap[++s.heap_len] = max_code = n;\n\t      s.depth[n] = 0;\n\t\n\t    } else {\n\t      tree[n * 2 + 1]/*.Len*/ = 0;\n\t    }\n\t  }\n\t\n\t  /* The pkzip format requires that at least one distance code exists,\n\t   * and that at least one bit should be sent even if there is only one\n\t   * possible code. So to avoid special checks later on we force at least\n\t   * two codes of non zero frequency.\n\t   */\n\t  while (s.heap_len < 2) {\n\t    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n\t    tree[node * 2]/*.Freq*/ = 1;\n\t    s.depth[node] = 0;\n\t    s.opt_len--;\n\t\n\t    if (has_stree) {\n\t      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n\t    }\n\t    /* node is 0 or 1 so it does not have extra bits */\n\t  }\n\t  desc.max_code = max_code;\n\t\n\t  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t   * establish sub-heaps of increasing lengths:\n\t   */\n\t  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\t\n\t  /* Construct the Huffman tree by repeatedly combining the least two\n\t   * frequent nodes.\n\t   */\n\t  node = elems;              /* next internal node of the tree */\n\t  do {\n\t    //pqremove(s, tree, n);  /* n = node of least frequency */\n\t    /*** pqremove ***/\n\t    n = s.heap[1/*SMALLEST*/];\n\t    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n\t    pqdownheap(s, tree, 1/*SMALLEST*/);\n\t    /***/\n\t\n\t    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\t\n\t    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n\t    s.heap[--s.heap_max] = m;\n\t\n\t    /* Create a new node father of n and m */\n\t    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n\t    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n\t    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\t\n\t    /* and insert the new node in the heap */\n\t    s.heap[1/*SMALLEST*/] = node++;\n\t    pqdownheap(s, tree, 1/*SMALLEST*/);\n\t\n\t  } while (s.heap_len >= 2);\n\t\n\t  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\t\n\t  /* At this point, the fields freq and dad are set. We can now\n\t   * generate the bit lengths.\n\t   */\n\t  gen_bitlen(s, desc);\n\t\n\t  /* The field len is now set, we can generate the bit codes */\n\t  gen_codes(tree, max_code, s.bl_count);\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Scan a literal or distance tree to determine the frequencies of the codes\n\t * in the bit length tree.\n\t */\n\tfunction scan_tree(s, tree, max_code)\n\t//    deflate_state *s;\n\t//    ct_data *tree;   /* the tree to be scanned */\n\t//    int max_code;    /* and its largest code of non zero frequency */\n\t{\n\t  var n;                     /* iterates over all tree elements */\n\t  var prevlen = -1;          /* last emitted length */\n\t  var curlen;                /* length of current code */\n\t\n\t  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\t\n\t  var count = 0;             /* repeat count of the current code */\n\t  var max_count = 7;         /* max repeat count */\n\t  var min_count = 4;         /* min repeat count */\n\t\n\t  if (nextlen === 0) {\n\t    max_count = 138;\n\t    min_count = 3;\n\t  }\n\t  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\t\n\t  for (n = 0; n <= max_code; n++) {\n\t    curlen = nextlen;\n\t    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\t\n\t    if (++count < max_count && curlen === nextlen) {\n\t      continue;\n\t\n\t    } else if (count < min_count) {\n\t      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\t\n\t    } else if (curlen !== 0) {\n\t\n\t      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n\t      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\t\n\t    } else if (count <= 10) {\n\t      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\t\n\t    } else {\n\t      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n\t    }\n\t\n\t    count = 0;\n\t    prevlen = curlen;\n\t\n\t    if (nextlen === 0) {\n\t      max_count = 138;\n\t      min_count = 3;\n\t\n\t    } else if (curlen === nextlen) {\n\t      max_count = 6;\n\t      min_count = 3;\n\t\n\t    } else {\n\t      max_count = 7;\n\t      min_count = 4;\n\t    }\n\t  }\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Send a literal or distance tree in compressed form, using the codes in\n\t * bl_tree.\n\t */\n\tfunction send_tree(s, tree, max_code)\n\t//    deflate_state *s;\n\t//    ct_data *tree; /* the tree to be scanned */\n\t//    int max_code;       /* and its largest code of non zero frequency */\n\t{\n\t  var n;                     /* iterates over all tree elements */\n\t  var prevlen = -1;          /* last emitted length */\n\t  var curlen;                /* length of current code */\n\t\n\t  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\t\n\t  var count = 0;             /* repeat count of the current code */\n\t  var max_count = 7;         /* max repeat count */\n\t  var min_count = 4;         /* min repeat count */\n\t\n\t  /* tree[max_code+1].Len = -1; */  /* guard already set */\n\t  if (nextlen === 0) {\n\t    max_count = 138;\n\t    min_count = 3;\n\t  }\n\t\n\t  for (n = 0; n <= max_code; n++) {\n\t    curlen = nextlen;\n\t    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\t\n\t    if (++count < max_count && curlen === nextlen) {\n\t      continue;\n\t\n\t    } else if (count < min_count) {\n\t      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\t\n\t    } else if (curlen !== 0) {\n\t      if (curlen !== prevlen) {\n\t        send_code(s, curlen, s.bl_tree);\n\t        count--;\n\t      }\n\t      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t      send_code(s, REP_3_6, s.bl_tree);\n\t      send_bits(s, count - 3, 2);\n\t\n\t    } else if (count <= 10) {\n\t      send_code(s, REPZ_3_10, s.bl_tree);\n\t      send_bits(s, count - 3, 3);\n\t\n\t    } else {\n\t      send_code(s, REPZ_11_138, s.bl_tree);\n\t      send_bits(s, count - 11, 7);\n\t    }\n\t\n\t    count = 0;\n\t    prevlen = curlen;\n\t    if (nextlen === 0) {\n\t      max_count = 138;\n\t      min_count = 3;\n\t\n\t    } else if (curlen === nextlen) {\n\t      max_count = 6;\n\t      min_count = 3;\n\t\n\t    } else {\n\t      max_count = 7;\n\t      min_count = 4;\n\t    }\n\t  }\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Construct the Huffman tree for the bit lengths and return the index in\n\t * bl_order of the last bit length code to send.\n\t */\n\tfunction build_bl_tree(s) {\n\t  var max_blindex;  /* index of last bit length code of non zero freq */\n\t\n\t  /* Determine the bit length frequencies for literal and distance trees */\n\t  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n\t  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\t\n\t  /* Build the bit length tree: */\n\t  build_tree(s, s.bl_desc);\n\t  /* opt_len now includes the length of the tree representations, except\n\t   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n\t   */\n\t\n\t  /* Determine the number of bit length codes to send. The pkzip format\n\t   * requires that at least 4 bit length codes be sent. (appnote.txt says\n\t   * 3 but the actual value used is 4.)\n\t   */\n\t  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n\t    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n\t      break;\n\t    }\n\t  }\n\t  /* Update opt_len to include the bit length tree and counts */\n\t  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t  //        s->opt_len, s->static_len));\n\t\n\t  return max_blindex;\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Send the header for a block using dynamic Huffman trees: the counts, the\n\t * lengths of the bit length codes, the literal tree and the distance tree.\n\t * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t */\n\tfunction send_all_trees(s, lcodes, dcodes, blcodes)\n\t//    deflate_state *s;\n\t//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\t{\n\t  var rank;                    /* index in bl_order */\n\t\n\t  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n\t  //        \"too many codes\");\n\t  //Tracev((stderr, \"\\nbl counts: \"));\n\t  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n\t  send_bits(s, dcodes - 1,   5);\n\t  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n\t  for (rank = 0; rank < blcodes; rank++) {\n\t    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n\t  }\n\t  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\t\n\t  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n\t  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\t\n\t  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n\t  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Check if the data type is TEXT or BINARY, using the following algorithm:\n\t * - TEXT if the two conditions below are satisfied:\n\t *    a) There are no non-portable control characters belonging to the\n\t *       \"black list\" (0..6, 14..25, 28..31).\n\t *    b) There is at least one printable character belonging to the\n\t *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n\t * - BINARY otherwise.\n\t * - The following partially-portable control characters form a\n\t *   \"gray list\" that is ignored in this detection algorithm:\n\t *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n\t * IN assertion: the fields Freq of dyn_ltree are set.\n\t */\n\tfunction detect_data_type(s) {\n\t  /* black_mask is the bit mask of black-listed bytes\n\t   * set bits 0..6, 14..25, and 28..31\n\t   * 0xf3ffc07f = binary 11110011111111111100000001111111\n\t   */\n\t  var black_mask = 0xf3ffc07f;\n\t  var n;\n\t\n\t  /* Check for non-textual (\"black-listed\") bytes. */\n\t  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n\t    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n\t      return Z_BINARY;\n\t    }\n\t  }\n\t\n\t  /* Check for textual (\"white-listed\") bytes. */\n\t  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n\t      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n\t    return Z_TEXT;\n\t  }\n\t  for (n = 32; n < LITERALS; n++) {\n\t    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n\t      return Z_TEXT;\n\t    }\n\t  }\n\t\n\t  /* There are no \"black-listed\" or \"white-listed\" bytes:\n\t   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n\t   */\n\t  return Z_BINARY;\n\t}\n\t\n\t\n\tvar static_init_done = false;\n\t\n\t/* ===========================================================================\n\t * Initialize the tree data structures for a new zlib stream.\n\t */\n\tfunction _tr_init(s)\n\t{\n\t\n\t  if (!static_init_done) {\n\t    tr_static_init();\n\t    static_init_done = true;\n\t  }\n\t\n\t  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n\t  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n\t  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\t\n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n\t\n\t  /* Initialize the first block of the first file: */\n\t  init_block(s);\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Send a stored block\n\t */\n\tfunction _tr_stored_block(s, buf, stored_len, last)\n\t//DeflateState *s;\n\t//charf *buf;       /* input block */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n\t  copy_block(s, buf, stored_len, true); /* with header */\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Send one empty static block to give enough lookahead for inflate.\n\t * This takes 10 bits, of which 7 may remain in the bit buffer.\n\t */\n\tfunction _tr_align(s) {\n\t  send_bits(s, STATIC_TREES << 1, 3);\n\t  send_code(s, END_BLOCK, static_ltree);\n\t  bi_flush(s);\n\t}\n\t\n\t\n\t/* ===========================================================================\n\t * Determine the best encoding for the current block: dynamic trees, static\n\t * trees or store, and output the encoded block to the zip file.\n\t */\n\tfunction _tr_flush_block(s, buf, stored_len, last)\n\t//DeflateState *s;\n\t//charf *buf;       /* input block, or NULL if too old */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n\t  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\t\n\t  /* Build the Huffman trees unless a stored block is forced */\n\t  if (s.level > 0) {\n\t\n\t    /* Check if the file is binary or text */\n\t    if (s.strm.data_type === Z_UNKNOWN) {\n\t      s.strm.data_type = detect_data_type(s);\n\t    }\n\t\n\t    /* Construct the literal and distance trees */\n\t    build_tree(s, s.l_desc);\n\t    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t    //        s->static_len));\n\t\n\t    build_tree(s, s.d_desc);\n\t    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t    //        s->static_len));\n\t    /* At this point, opt_len and static_len are the total bit lengths of\n\t     * the compressed block data, excluding the tree representations.\n\t     */\n\t\n\t    /* Build the bit length tree for the above two trees, and get the index\n\t     * in bl_order of the last bit length code to send.\n\t     */\n\t    max_blindex = build_bl_tree(s);\n\t\n\t    /* Determine the best encoding. Compute the block lengths in bytes. */\n\t    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n\t    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\t\n\t    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t    //        s->last_lit));\n\t\n\t    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\t\n\t  } else {\n\t    // Assert(buf != (char*)0, \"lost buf\");\n\t    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n\t  }\n\t\n\t  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n\t    /* 4: two words for the lengths */\n\t\n\t    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t     * Otherwise we can't have processed more than WSIZE input bytes since\n\t     * the last block flush, because compression would have been\n\t     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t     * transform a block into a stored block.\n\t     */\n\t    _tr_stored_block(s, buf, stored_len, last);\n\t\n\t  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\t\n\t    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n\t    compress_block(s, static_ltree, static_dtree);\n\t\n\t  } else {\n\t    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n\t    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n\t    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n\t  }\n\t  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\t  /* The above check is made mod 2^32, for files larger than 512 MB\n\t   * and uLong implemented on 32 bits.\n\t   */\n\t  init_block(s);\n\t\n\t  if (last) {\n\t    bi_windup(s);\n\t  }\n\t  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n\t  //       s->compressed_len-7*last));\n\t}\n\t\n\t/* ===========================================================================\n\t * Save the match info and tally the frequency counts. Return true if\n\t * the current block must be flushed.\n\t */\n\tfunction _tr_tally(s, dist, lc)\n\t//    deflate_state *s;\n\t//    unsigned dist;  /* distance of matched string */\n\t//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\t{\n\t  //var out_length, in_length, dcode;\n\t\n\t  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n\t  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\t\n\t  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n\t  s.last_lit++;\n\t\n\t  if (dist === 0) {\n\t    /* lc is the unmatched char */\n\t    s.dyn_ltree[lc * 2]/*.Freq*/++;\n\t  } else {\n\t    s.matches++;\n\t    /* Here, lc is the match length - MIN_MATCH */\n\t    dist--;             /* dist = match distance - 1 */\n\t    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n\t    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n\t    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\t\n\t    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n\t    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n\t  }\n\t\n\t// (!) This block is disabled in zlib defailts,\n\t// don't enable it for binary compatibility\n\t\n\t//#ifdef TRUNCATE_BLOCK\n\t//  /* Try to guess if it is profitable to stop the current block here */\n\t//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n\t//    /* Compute an upper bound for the compressed length */\n\t//    out_length = s.last_lit*8;\n\t//    in_length = s.strstart - s.block_start;\n\t//\n\t//    for (dcode = 0; dcode < D_CODES; dcode++) {\n\t//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n\t//    }\n\t//    out_length >>>= 3;\n\t//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n\t//    //       s->last_lit, in_length, out_length,\n\t//    //       100L - out_length*100L/in_length));\n\t//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n\t//      return true;\n\t//    }\n\t//  }\n\t//#endif\n\t\n\t  return (s.last_lit === s.lit_bufsize - 1);\n\t  /* We avoid equality with lit_bufsize because of wraparound at 64K\n\t   * on 16 bit machines and because stored blocks are restricted to\n\t   * 64K-1 bytes.\n\t   */\n\t}\n\t\n\texports._tr_init  = _tr_init;\n\texports._tr_stored_block = _tr_stored_block;\n\texports._tr_flush_block  = _tr_flush_block;\n\texports._tr_tally = _tr_tally;\n\texports._tr_align = _tr_align;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Note: adler32 takes 12% for level 0 and 2% for level 6.\n\t// It doesn't worth to make additional optimizationa as in original.\n\t// Small size is preferable.\n\t\n\tfunction adler32(adler, buf, len, pos) {\n\t  var s1 = (adler & 0xffff) |0,\n\t      s2 = ((adler >>> 16) & 0xffff) |0,\n\t      n = 0;\n\t\n\t  while (len !== 0) {\n\t    // Set limit ~ twice less than 5552, to keep\n\t    // s2 in 31-bits, because we force signed ints.\n\t    // in other case %= will fail.\n\t    n = len > 2000 ? 2000 : len;\n\t    len -= n;\n\t\n\t    do {\n\t      s1 = (s1 + buf[pos++]) |0;\n\t      s2 = (s2 + s1) |0;\n\t    } while (--n);\n\t\n\t    s1 %= 65521;\n\t    s2 %= 65521;\n\t  }\n\t\n\t  return (s1 | (s2 << 16)) |0;\n\t}\n\t\n\t\n\tmodule.exports = adler32;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// Note: we can't get significant speed boost here.\n\t// So write code to minimize size - no pregenerated tables\n\t// and array tools dependencies.\n\t\n\t\n\t// Use ordinary array, since untyped makes no boost here\n\tfunction makeTable() {\n\t  var c, table = [];\n\t\n\t  for (var n = 0; n < 256; n++) {\n\t    c = n;\n\t    for (var k = 0; k < 8; k++) {\n\t      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n\t    }\n\t    table[n] = c;\n\t  }\n\t\n\t  return table;\n\t}\n\t\n\t// Create table on load. Just 255 signed longs. Not a problem.\n\tvar crcTable = makeTable();\n\t\n\t\n\tfunction crc32(crc, buf, len, pos) {\n\t  var t = crcTable,\n\t      end = pos + len;\n\t\n\t  crc ^= -1;\n\t\n\t  for (var i = pos; i < end; i++) {\n\t    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n\t  }\n\t\n\t  return (crc ^ (-1)); // >>> 0;\n\t}\n\t\n\t\n\tmodule.exports = crc32;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n\t  1:      'stream end',          /* Z_STREAM_END      1  */\n\t  0:      '',                    /* Z_OK              0  */\n\t  '-1':   'file error',          /* Z_ERRNO         (-1) */\n\t  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n\t  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n\t  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n\t  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n\t  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar utils         = __webpack_require__(36);\n\tvar adler32       = __webpack_require__(38);\n\tvar crc32         = __webpack_require__(39);\n\tvar inflate_fast  = __webpack_require__(42);\n\tvar inflate_table = __webpack_require__(43);\n\t\n\tvar CODES = 0;\n\tvar LENS = 1;\n\tvar DISTS = 2;\n\t\n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n\t\n\t\n\t/* Allowed flush values; see deflate() and inflate() below for details */\n\t//var Z_NO_FLUSH      = 0;\n\t//var Z_PARTIAL_FLUSH = 1;\n\t//var Z_SYNC_FLUSH    = 2;\n\t//var Z_FULL_FLUSH    = 3;\n\tvar Z_FINISH        = 4;\n\tvar Z_BLOCK         = 5;\n\tvar Z_TREES         = 6;\n\t\n\t\n\t/* Return codes for the compression/decompression functions. Negative values\n\t * are errors, positive values are used for special but normal events.\n\t */\n\tvar Z_OK            = 0;\n\tvar Z_STREAM_END    = 1;\n\tvar Z_NEED_DICT     = 2;\n\t//var Z_ERRNO         = -1;\n\tvar Z_STREAM_ERROR  = -2;\n\tvar Z_DATA_ERROR    = -3;\n\tvar Z_MEM_ERROR     = -4;\n\tvar Z_BUF_ERROR     = -5;\n\t//var Z_VERSION_ERROR = -6;\n\t\n\t/* The deflate compression method */\n\tvar Z_DEFLATED  = 8;\n\t\n\t\n\t/* STATES ====================================================================*/\n\t/* ===========================================================================*/\n\t\n\t\n\tvar    HEAD = 1;       /* i: waiting for magic header */\n\tvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\n\tvar    TIME = 3;       /* i: waiting for modification time (gzip) */\n\tvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\n\tvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\n\tvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\n\tvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\n\tvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\n\tvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\n\tvar    DICTID = 10;    /* i: waiting for dictionary check value */\n\tvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\n\tvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\tvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\n\tvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\n\tvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\n\tvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\n\tvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\n\tvar        LENLENS = 18;   /* i: waiting for code length code lengths */\n\tvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\n\tvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\n\tvar            LEN = 21;       /* i: waiting for length/lit/eob code */\n\tvar            LENEXT = 22;    /* i: waiting for length extra bits */\n\tvar            DIST = 23;      /* i: waiting for distance code */\n\tvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\n\tvar            MATCH = 25;     /* o: waiting for output space to copy string */\n\tvar            LIT = 26;       /* o: waiting for output space to write literal */\n\tvar    CHECK = 27;     /* i: waiting for 32-bit check value */\n\tvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\n\tvar    DONE = 29;      /* finished check, done -- remain here until reset */\n\tvar    BAD = 30;       /* got a data error -- remain here until reset */\n\tvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\n\tvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\t\n\t/* ===========================================================================*/\n\t\n\t\n\t\n\tvar ENOUGH_LENS = 852;\n\tvar ENOUGH_DISTS = 592;\n\t//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\t\n\tvar MAX_WBITS = 15;\n\t/* 32K LZ77 window */\n\tvar DEF_WBITS = MAX_WBITS;\n\t\n\t\n\tfunction zswap32(q) {\n\t  return  (((q >>> 24) & 0xff) +\n\t          ((q >>> 8) & 0xff00) +\n\t          ((q & 0xff00) << 8) +\n\t          ((q & 0xff) << 24));\n\t}\n\t\n\t\n\tfunction InflateState() {\n\t  this.mode = 0;             /* current inflate mode */\n\t  this.last = false;          /* true if processing last block */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.havedict = false;      /* true if dictionary provided */\n\t  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n\t  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n\t  this.check = 0;             /* protected copy of check value */\n\t  this.total = 0;             /* protected copy of output count */\n\t  // TODO: may be {}\n\t  this.head = null;           /* where to save gzip header information */\n\t\n\t  /* sliding window */\n\t  this.wbits = 0;             /* log base 2 of requested window size */\n\t  this.wsize = 0;             /* window size or zero if not using window */\n\t  this.whave = 0;             /* valid bytes in the window */\n\t  this.wnext = 0;             /* window write index */\n\t  this.window = null;         /* allocated sliding window, if needed */\n\t\n\t  /* bit accumulator */\n\t  this.hold = 0;              /* input bit accumulator */\n\t  this.bits = 0;              /* number of bits in \"in\" */\n\t\n\t  /* for string and stored block copying */\n\t  this.length = 0;            /* literal or length of data to copy */\n\t  this.offset = 0;            /* distance back to copy string from */\n\t\n\t  /* for table and code decoding */\n\t  this.extra = 0;             /* extra bits needed */\n\t\n\t  /* fixed and dynamic code tables */\n\t  this.lencode = null;          /* starting table for length/literal codes */\n\t  this.distcode = null;         /* starting table for distance codes */\n\t  this.lenbits = 0;           /* index bits for lencode */\n\t  this.distbits = 0;          /* index bits for distcode */\n\t\n\t  /* dynamic table building */\n\t  this.ncode = 0;             /* number of code length code lengths */\n\t  this.nlen = 0;              /* number of length code lengths */\n\t  this.ndist = 0;             /* number of distance code lengths */\n\t  this.have = 0;              /* number of code lengths in lens[] */\n\t  this.next = null;              /* next available space in codes[] */\n\t\n\t  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n\t  this.work = new utils.Buf16(288); /* work area for code table building */\n\t\n\t  /*\n\t   because we don't have pointers in js, we use lencode and distcode directly\n\t   as buffers so we don't need codes\n\t  */\n\t  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n\t  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n\t  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n\t  this.sane = 0;                   /* if false, allow invalid distance too far */\n\t  this.back = 0;                   /* bits back of last unprocessed length/lit */\n\t  this.was = 0;                    /* initial length of match */\n\t}\n\t\n\tfunction inflateResetKeep(strm) {\n\t  var state;\n\t\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n\t  state = strm.state;\n\t  strm.total_in = strm.total_out = state.total = 0;\n\t  strm.msg = ''; /*Z_NULL*/\n\t  if (state.wrap) {       /* to support ill-conceived Java test suite */\n\t    strm.adler = state.wrap & 1;\n\t  }\n\t  state.mode = HEAD;\n\t  state.last = 0;\n\t  state.havedict = 0;\n\t  state.dmax = 32768;\n\t  state.head = null/*Z_NULL*/;\n\t  state.hold = 0;\n\t  state.bits = 0;\n\t  //state.lencode = state.distcode = state.next = state.codes;\n\t  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n\t  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\t\n\t  state.sane = 1;\n\t  state.back = -1;\n\t  //Tracev((stderr, \"inflate: reset\\n\"));\n\t  return Z_OK;\n\t}\n\t\n\tfunction inflateReset(strm) {\n\t  var state;\n\t\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n\t  state = strm.state;\n\t  state.wsize = 0;\n\t  state.whave = 0;\n\t  state.wnext = 0;\n\t  return inflateResetKeep(strm);\n\t\n\t}\n\t\n\tfunction inflateReset2(strm, windowBits) {\n\t  var wrap;\n\t  var state;\n\t\n\t  /* get the state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n\t  state = strm.state;\n\t\n\t  /* extract wrap request from windowBits parameter */\n\t  if (windowBits < 0) {\n\t    wrap = 0;\n\t    windowBits = -windowBits;\n\t  }\n\t  else {\n\t    wrap = (windowBits >> 4) + 1;\n\t    if (windowBits < 48) {\n\t      windowBits &= 15;\n\t    }\n\t  }\n\t\n\t  /* set number of window bits, free window if different */\n\t  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t  if (state.window !== null && state.wbits !== windowBits) {\n\t    state.window = null;\n\t  }\n\t\n\t  /* update state and reset the rest of it */\n\t  state.wrap = wrap;\n\t  state.wbits = windowBits;\n\t  return inflateReset(strm);\n\t}\n\t\n\tfunction inflateInit2(strm, windowBits) {\n\t  var ret;\n\t  var state;\n\t\n\t  if (!strm) { return Z_STREAM_ERROR; }\n\t  //strm.msg = Z_NULL;                 /* in case we return an error */\n\t\n\t  state = new InflateState();\n\t\n\t  //if (state === Z_NULL) return Z_MEM_ERROR;\n\t  //Tracev((stderr, \"inflate: allocated\\n\"));\n\t  strm.state = state;\n\t  state.window = null/*Z_NULL*/;\n\t  ret = inflateReset2(strm, windowBits);\n\t  if (ret !== Z_OK) {\n\t    strm.state = null/*Z_NULL*/;\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction inflateInit(strm) {\n\t  return inflateInit2(strm, DEF_WBITS);\n\t}\n\t\n\t\n\t/*\n\t Return state with length and distance decoding tables and index sizes set to\n\t fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n\t If BUILDFIXED is defined, then instead this routine builds the tables the\n\t first time it's called, and returns those tables the first time and\n\t thereafter.  This reduces the size of the code by about 2K bytes, in\n\t exchange for a little execution time.  However, BUILDFIXED should not be\n\t used for threaded applications, since the rewriting of the tables and virgin\n\t may not be thread-safe.\n\t */\n\tvar virgin = true;\n\t\n\tvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\t\n\tfunction fixedtables(state) {\n\t  /* build fixed huffman tables if first call (may not be thread safe) */\n\t  if (virgin) {\n\t    var sym;\n\t\n\t    lenfix = new utils.Buf32(512);\n\t    distfix = new utils.Buf32(32);\n\t\n\t    /* literal/length table */\n\t    sym = 0;\n\t    while (sym < 144) { state.lens[sym++] = 8; }\n\t    while (sym < 256) { state.lens[sym++] = 9; }\n\t    while (sym < 280) { state.lens[sym++] = 7; }\n\t    while (sym < 288) { state.lens[sym++] = 8; }\n\t\n\t    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\t\n\t    /* distance table */\n\t    sym = 0;\n\t    while (sym < 32) { state.lens[sym++] = 5; }\n\t\n\t    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\t\n\t    /* do this just once */\n\t    virgin = false;\n\t  }\n\t\n\t  state.lencode = lenfix;\n\t  state.lenbits = 9;\n\t  state.distcode = distfix;\n\t  state.distbits = 5;\n\t}\n\t\n\t\n\t/*\n\t Update the window with the last wsize (normally 32K) bytes written before\n\t returning.  If window does not exist yet, create it.  This is only called\n\t when a window is already in use, or when output has been written during this\n\t inflate call, but the end of the deflate stream has not been reached yet.\n\t It is also called to create a window for dictionary data when a dictionary\n\t is loaded.\n\t\n\t Providing output buffers larger than 32K to inflate() should provide a speed\n\t advantage, since only the last 32K of output is copied to the sliding window\n\t upon return from inflate(), and since all distances after the first 32K of\n\t output will fall in the output data, making match copies simpler and faster.\n\t The advantage may be dependent on the size of the processor's data caches.\n\t */\n\tfunction updatewindow(strm, src, end, copy) {\n\t  var dist;\n\t  var state = strm.state;\n\t\n\t  /* if it hasn't been done already, allocate space for the window */\n\t  if (state.window === null) {\n\t    state.wsize = 1 << state.wbits;\n\t    state.wnext = 0;\n\t    state.whave = 0;\n\t\n\t    state.window = new utils.Buf8(state.wsize);\n\t  }\n\t\n\t  /* copy state->wsize or less output bytes into the circular window */\n\t  if (copy >= state.wsize) {\n\t    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n\t    state.wnext = 0;\n\t    state.whave = state.wsize;\n\t  }\n\t  else {\n\t    dist = state.wsize - state.wnext;\n\t    if (dist > copy) {\n\t      dist = copy;\n\t    }\n\t    //zmemcpy(state->window + state->wnext, end - copy, dist);\n\t    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n\t    copy -= dist;\n\t    if (copy) {\n\t      //zmemcpy(state->window, end - copy, copy);\n\t      utils.arraySet(state.window, src, end - copy, copy, 0);\n\t      state.wnext = copy;\n\t      state.whave = state.wsize;\n\t    }\n\t    else {\n\t      state.wnext += dist;\n\t      if (state.wnext === state.wsize) { state.wnext = 0; }\n\t      if (state.whave < state.wsize) { state.whave += dist; }\n\t    }\n\t  }\n\t  return 0;\n\t}\n\t\n\tfunction inflate(strm, flush) {\n\t  var state;\n\t  var input, output;          // input/output buffers\n\t  var next;                   /* next input INDEX */\n\t  var put;                    /* next output INDEX */\n\t  var have, left;             /* available input and output */\n\t  var hold;                   /* bit buffer */\n\t  var bits;                   /* bits in bit buffer */\n\t  var _in, _out;              /* save starting available input and output */\n\t  var copy;                   /* number of stored or match bytes to copy */\n\t  var from;                   /* where to copy match bytes from */\n\t  var from_source;\n\t  var here = 0;               /* current decoding table entry */\n\t  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n\t  //var last;                   /* parent table entry */\n\t  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n\t  var len;                    /* length to copy for repeats, bits to drop */\n\t  var ret;                    /* return code */\n\t  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n\t  var opts;\n\t\n\t  var n; // temporary var for NEED_BITS\n\t\n\t  var order = /* permutation of code lengths */\n\t    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\t\n\t\n\t  if (!strm || !strm.state || !strm.output ||\n\t      (!strm.input && strm.avail_in !== 0)) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  state = strm.state;\n\t  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\t\n\t\n\t  //--- LOAD() ---\n\t  put = strm.next_out;\n\t  output = strm.output;\n\t  left = strm.avail_out;\n\t  next = strm.next_in;\n\t  input = strm.input;\n\t  have = strm.avail_in;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  //---\n\t\n\t  _in = have;\n\t  _out = left;\n\t  ret = Z_OK;\n\t\n\t  inf_leave: // goto emulation\n\t  for (;;) {\n\t    switch (state.mode) {\n\t    case HEAD:\n\t      if (state.wrap === 0) {\n\t        state.mode = TYPEDO;\n\t        break;\n\t      }\n\t      //=== NEEDBITS(16);\n\t      while (bits < 16) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n\t        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n\t        //=== CRC2(state.check, hold);\n\t        hbuf[0] = hold & 0xff;\n\t        hbuf[1] = (hold >>> 8) & 0xff;\n\t        state.check = crc32(state.check, hbuf, 2, 0);\n\t        //===//\n\t\n\t        //=== INITBITS();\n\t        hold = 0;\n\t        bits = 0;\n\t        //===//\n\t        state.mode = FLAGS;\n\t        break;\n\t      }\n\t      state.flags = 0;           /* expect zlib header */\n\t      if (state.head) {\n\t        state.head.done = false;\n\t      }\n\t      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n\t        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n\t        strm.msg = 'incorrect header check';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n\t        strm.msg = 'unknown compression method';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      //--- DROPBITS(4) ---//\n\t      hold >>>= 4;\n\t      bits -= 4;\n\t      //---//\n\t      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n\t      if (state.wbits === 0) {\n\t        state.wbits = len;\n\t      }\n\t      else if (len > state.wbits) {\n\t        strm.msg = 'invalid window size';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      state.dmax = 1 << len;\n\t      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n\t      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t      state.mode = hold & 0x200 ? DICTID : TYPE;\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      break;\n\t    case FLAGS:\n\t      //=== NEEDBITS(16); */\n\t      while (bits < 16) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      state.flags = hold;\n\t      if ((state.flags & 0xff) !== Z_DEFLATED) {\n\t        strm.msg = 'unknown compression method';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      if (state.flags & 0xe000) {\n\t        strm.msg = 'unknown header flags set';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      if (state.head) {\n\t        state.head.text = ((hold >> 8) & 1);\n\t      }\n\t      if (state.flags & 0x0200) {\n\t        //=== CRC2(state.check, hold);\n\t        hbuf[0] = hold & 0xff;\n\t        hbuf[1] = (hold >>> 8) & 0xff;\n\t        state.check = crc32(state.check, hbuf, 2, 0);\n\t        //===//\n\t      }\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      state.mode = TIME;\n\t      /* falls through */\n\t    case TIME:\n\t      //=== NEEDBITS(32); */\n\t      while (bits < 32) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      if (state.head) {\n\t        state.head.time = hold;\n\t      }\n\t      if (state.flags & 0x0200) {\n\t        //=== CRC4(state.check, hold)\n\t        hbuf[0] = hold & 0xff;\n\t        hbuf[1] = (hold >>> 8) & 0xff;\n\t        hbuf[2] = (hold >>> 16) & 0xff;\n\t        hbuf[3] = (hold >>> 24) & 0xff;\n\t        state.check = crc32(state.check, hbuf, 4, 0);\n\t        //===\n\t      }\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      state.mode = OS;\n\t      /* falls through */\n\t    case OS:\n\t      //=== NEEDBITS(16); */\n\t      while (bits < 16) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      if (state.head) {\n\t        state.head.xflags = (hold & 0xff);\n\t        state.head.os = (hold >> 8);\n\t      }\n\t      if (state.flags & 0x0200) {\n\t        //=== CRC2(state.check, hold);\n\t        hbuf[0] = hold & 0xff;\n\t        hbuf[1] = (hold >>> 8) & 0xff;\n\t        state.check = crc32(state.check, hbuf, 2, 0);\n\t        //===//\n\t      }\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      state.mode = EXLEN;\n\t      /* falls through */\n\t    case EXLEN:\n\t      if (state.flags & 0x0400) {\n\t        //=== NEEDBITS(16); */\n\t        while (bits < 16) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        state.length = hold;\n\t        if (state.head) {\n\t          state.head.extra_len = hold;\n\t        }\n\t        if (state.flags & 0x0200) {\n\t          //=== CRC2(state.check, hold);\n\t          hbuf[0] = hold & 0xff;\n\t          hbuf[1] = (hold >>> 8) & 0xff;\n\t          state.check = crc32(state.check, hbuf, 2, 0);\n\t          //===//\n\t        }\n\t        //=== INITBITS();\n\t        hold = 0;\n\t        bits = 0;\n\t        //===//\n\t      }\n\t      else if (state.head) {\n\t        state.head.extra = null/*Z_NULL*/;\n\t      }\n\t      state.mode = EXTRA;\n\t      /* falls through */\n\t    case EXTRA:\n\t      if (state.flags & 0x0400) {\n\t        copy = state.length;\n\t        if (copy > have) { copy = have; }\n\t        if (copy) {\n\t          if (state.head) {\n\t            len = state.head.extra_len - state.length;\n\t            if (!state.head.extra) {\n\t              // Use untyped array for more conveniend processing later\n\t              state.head.extra = new Array(state.head.extra_len);\n\t            }\n\t            utils.arraySet(\n\t              state.head.extra,\n\t              input,\n\t              next,\n\t              // extra field is limited to 65536 bytes\n\t              // - no need for additional size check\n\t              copy,\n\t              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n\t              len\n\t            );\n\t            //zmemcpy(state.head.extra + len, next,\n\t            //        len + copy > state.head.extra_max ?\n\t            //        state.head.extra_max - len : copy);\n\t          }\n\t          if (state.flags & 0x0200) {\n\t            state.check = crc32(state.check, input, copy, next);\n\t          }\n\t          have -= copy;\n\t          next += copy;\n\t          state.length -= copy;\n\t        }\n\t        if (state.length) { break inf_leave; }\n\t      }\n\t      state.length = 0;\n\t      state.mode = NAME;\n\t      /* falls through */\n\t    case NAME:\n\t      if (state.flags & 0x0800) {\n\t        if (have === 0) { break inf_leave; }\n\t        copy = 0;\n\t        do {\n\t          // TODO: 2 or 1 bytes?\n\t          len = input[next + copy++];\n\t          /* use constant limit because in js we should not preallocate memory */\n\t          if (state.head && len &&\n\t              (state.length < 65536 /*state.head.name_max*/)) {\n\t            state.head.name += String.fromCharCode(len);\n\t          }\n\t        } while (len && copy < have);\n\t\n\t        if (state.flags & 0x0200) {\n\t          state.check = crc32(state.check, input, copy, next);\n\t        }\n\t        have -= copy;\n\t        next += copy;\n\t        if (len) { break inf_leave; }\n\t      }\n\t      else if (state.head) {\n\t        state.head.name = null;\n\t      }\n\t      state.length = 0;\n\t      state.mode = COMMENT;\n\t      /* falls through */\n\t    case COMMENT:\n\t      if (state.flags & 0x1000) {\n\t        if (have === 0) { break inf_leave; }\n\t        copy = 0;\n\t        do {\n\t          len = input[next + copy++];\n\t          /* use constant limit because in js we should not preallocate memory */\n\t          if (state.head && len &&\n\t              (state.length < 65536 /*state.head.comm_max*/)) {\n\t            state.head.comment += String.fromCharCode(len);\n\t          }\n\t        } while (len && copy < have);\n\t        if (state.flags & 0x0200) {\n\t          state.check = crc32(state.check, input, copy, next);\n\t        }\n\t        have -= copy;\n\t        next += copy;\n\t        if (len) { break inf_leave; }\n\t      }\n\t      else if (state.head) {\n\t        state.head.comment = null;\n\t      }\n\t      state.mode = HCRC;\n\t      /* falls through */\n\t    case HCRC:\n\t      if (state.flags & 0x0200) {\n\t        //=== NEEDBITS(16); */\n\t        while (bits < 16) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        if (hold !== (state.check & 0xffff)) {\n\t          strm.msg = 'header crc mismatch';\n\t          state.mode = BAD;\n\t          break;\n\t        }\n\t        //=== INITBITS();\n\t        hold = 0;\n\t        bits = 0;\n\t        //===//\n\t      }\n\t      if (state.head) {\n\t        state.head.hcrc = ((state.flags >> 9) & 1);\n\t        state.head.done = true;\n\t      }\n\t      strm.adler = state.check = 0;\n\t      state.mode = TYPE;\n\t      break;\n\t    case DICTID:\n\t      //=== NEEDBITS(32); */\n\t      while (bits < 32) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      strm.adler = state.check = zswap32(hold);\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      state.mode = DICT;\n\t      /* falls through */\n\t    case DICT:\n\t      if (state.havedict === 0) {\n\t        //--- RESTORE() ---\n\t        strm.next_out = put;\n\t        strm.avail_out = left;\n\t        strm.next_in = next;\n\t        strm.avail_in = have;\n\t        state.hold = hold;\n\t        state.bits = bits;\n\t        //---\n\t        return Z_NEED_DICT;\n\t      }\n\t      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t      state.mode = TYPE;\n\t      /* falls through */\n\t    case TYPE:\n\t      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n\t      /* falls through */\n\t    case TYPEDO:\n\t      if (state.last) {\n\t        //--- BYTEBITS() ---//\n\t        hold >>>= bits & 7;\n\t        bits -= bits & 7;\n\t        //---//\n\t        state.mode = CHECK;\n\t        break;\n\t      }\n\t      //=== NEEDBITS(3); */\n\t      while (bits < 3) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      state.last = (hold & 0x01)/*BITS(1)*/;\n\t      //--- DROPBITS(1) ---//\n\t      hold >>>= 1;\n\t      bits -= 1;\n\t      //---//\n\t\n\t      switch ((hold & 0x03)/*BITS(2)*/) {\n\t      case 0:                             /* stored block */\n\t        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n\t        //        state.last ? \" (last)\" : \"\"));\n\t        state.mode = STORED;\n\t        break;\n\t      case 1:                             /* fixed block */\n\t        fixedtables(state);\n\t        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n\t        //        state.last ? \" (last)\" : \"\"));\n\t        state.mode = LEN_;             /* decode codes */\n\t        if (flush === Z_TREES) {\n\t          //--- DROPBITS(2) ---//\n\t          hold >>>= 2;\n\t          bits -= 2;\n\t          //---//\n\t          break inf_leave;\n\t        }\n\t        break;\n\t      case 2:                             /* dynamic block */\n\t        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n\t        //        state.last ? \" (last)\" : \"\"));\n\t        state.mode = TABLE;\n\t        break;\n\t      case 3:\n\t        strm.msg = 'invalid block type';\n\t        state.mode = BAD;\n\t      }\n\t      //--- DROPBITS(2) ---//\n\t      hold >>>= 2;\n\t      bits -= 2;\n\t      //---//\n\t      break;\n\t    case STORED:\n\t      //--- BYTEBITS() ---// /* go to byte boundary */\n\t      hold >>>= bits & 7;\n\t      bits -= bits & 7;\n\t      //---//\n\t      //=== NEEDBITS(32); */\n\t      while (bits < 32) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n\t        strm.msg = 'invalid stored block lengths';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      state.length = hold & 0xffff;\n\t      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n\t      //        state.length));\n\t      //=== INITBITS();\n\t      hold = 0;\n\t      bits = 0;\n\t      //===//\n\t      state.mode = COPY_;\n\t      if (flush === Z_TREES) { break inf_leave; }\n\t      /* falls through */\n\t    case COPY_:\n\t      state.mode = COPY;\n\t      /* falls through */\n\t    case COPY:\n\t      copy = state.length;\n\t      if (copy) {\n\t        if (copy > have) { copy = have; }\n\t        if (copy > left) { copy = left; }\n\t        if (copy === 0) { break inf_leave; }\n\t        //--- zmemcpy(put, next, copy); ---\n\t        utils.arraySet(output, input, next, copy, put);\n\t        //---//\n\t        have -= copy;\n\t        next += copy;\n\t        left -= copy;\n\t        put += copy;\n\t        state.length -= copy;\n\t        break;\n\t      }\n\t      //Tracev((stderr, \"inflate:       stored end\\n\"));\n\t      state.mode = TYPE;\n\t      break;\n\t    case TABLE:\n\t      //=== NEEDBITS(14); */\n\t      while (bits < 14) {\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t      }\n\t      //===//\n\t      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n\t      //--- DROPBITS(5) ---//\n\t      hold >>>= 5;\n\t      bits -= 5;\n\t      //---//\n\t      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n\t      //--- DROPBITS(5) ---//\n\t      hold >>>= 5;\n\t      bits -= 5;\n\t      //---//\n\t      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n\t      //--- DROPBITS(4) ---//\n\t      hold >>>= 4;\n\t      bits -= 4;\n\t      //---//\n\t//#ifndef PKZIP_BUG_WORKAROUND\n\t      if (state.nlen > 286 || state.ndist > 30) {\n\t        strm.msg = 'too many length or distance symbols';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t//#endif\n\t      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\t      state.have = 0;\n\t      state.mode = LENLENS;\n\t      /* falls through */\n\t    case LENLENS:\n\t      while (state.have < state.ncode) {\n\t        //=== NEEDBITS(3);\n\t        while (bits < 3) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n\t        //--- DROPBITS(3) ---//\n\t        hold >>>= 3;\n\t        bits -= 3;\n\t        //---//\n\t      }\n\t      while (state.have < 19) {\n\t        state.lens[order[state.have++]] = 0;\n\t      }\n\t      // We have separate tables & no pointers. 2 commented lines below not needed.\n\t      //state.next = state.codes;\n\t      //state.lencode = state.next;\n\t      // Switch to use dynamic table\n\t      state.lencode = state.lendyn;\n\t      state.lenbits = 7;\n\t\n\t      opts = { bits: state.lenbits };\n\t      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n\t      state.lenbits = opts.bits;\n\t\n\t      if (ret) {\n\t        strm.msg = 'invalid code lengths set';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\t      state.have = 0;\n\t      state.mode = CODELENS;\n\t      /* falls through */\n\t    case CODELENS:\n\t      while (state.have < state.nlen + state.ndist) {\n\t        for (;;) {\n\t          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n\t          here_bits = here >>> 24;\n\t          here_op = (here >>> 16) & 0xff;\n\t          here_val = here & 0xffff;\n\t\n\t          if ((here_bits) <= bits) { break; }\n\t          //--- PULLBYTE() ---//\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t          //---//\n\t        }\n\t        if (here_val < 16) {\n\t          //--- DROPBITS(here.bits) ---//\n\t          hold >>>= here_bits;\n\t          bits -= here_bits;\n\t          //---//\n\t          state.lens[state.have++] = here_val;\n\t        }\n\t        else {\n\t          if (here_val === 16) {\n\t            //=== NEEDBITS(here.bits + 2);\n\t            n = here_bits + 2;\n\t            while (bits < n) {\n\t              if (have === 0) { break inf_leave; }\n\t              have--;\n\t              hold += input[next++] << bits;\n\t              bits += 8;\n\t            }\n\t            //===//\n\t            //--- DROPBITS(here.bits) ---//\n\t            hold >>>= here_bits;\n\t            bits -= here_bits;\n\t            //---//\n\t            if (state.have === 0) {\n\t              strm.msg = 'invalid bit length repeat';\n\t              state.mode = BAD;\n\t              break;\n\t            }\n\t            len = state.lens[state.have - 1];\n\t            copy = 3 + (hold & 0x03);//BITS(2);\n\t            //--- DROPBITS(2) ---//\n\t            hold >>>= 2;\n\t            bits -= 2;\n\t            //---//\n\t          }\n\t          else if (here_val === 17) {\n\t            //=== NEEDBITS(here.bits + 3);\n\t            n = here_bits + 3;\n\t            while (bits < n) {\n\t              if (have === 0) { break inf_leave; }\n\t              have--;\n\t              hold += input[next++] << bits;\n\t              bits += 8;\n\t            }\n\t            //===//\n\t            //--- DROPBITS(here.bits) ---//\n\t            hold >>>= here_bits;\n\t            bits -= here_bits;\n\t            //---//\n\t            len = 0;\n\t            copy = 3 + (hold & 0x07);//BITS(3);\n\t            //--- DROPBITS(3) ---//\n\t            hold >>>= 3;\n\t            bits -= 3;\n\t            //---//\n\t          }\n\t          else {\n\t            //=== NEEDBITS(here.bits + 7);\n\t            n = here_bits + 7;\n\t            while (bits < n) {\n\t              if (have === 0) { break inf_leave; }\n\t              have--;\n\t              hold += input[next++] << bits;\n\t              bits += 8;\n\t            }\n\t            //===//\n\t            //--- DROPBITS(here.bits) ---//\n\t            hold >>>= here_bits;\n\t            bits -= here_bits;\n\t            //---//\n\t            len = 0;\n\t            copy = 11 + (hold & 0x7f);//BITS(7);\n\t            //--- DROPBITS(7) ---//\n\t            hold >>>= 7;\n\t            bits -= 7;\n\t            //---//\n\t          }\n\t          if (state.have + copy > state.nlen + state.ndist) {\n\t            strm.msg = 'invalid bit length repeat';\n\t            state.mode = BAD;\n\t            break;\n\t          }\n\t          while (copy--) {\n\t            state.lens[state.have++] = len;\n\t          }\n\t        }\n\t      }\n\t\n\t      /* handle error breaks in while */\n\t      if (state.mode === BAD) { break; }\n\t\n\t      /* check for end-of-block code (better have one) */\n\t      if (state.lens[256] === 0) {\n\t        strm.msg = 'invalid code -- missing end-of-block';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t\n\t      /* build code tables -- note: do not change the lenbits or distbits\n\t         values here (9 and 6) without reading the comments in inftrees.h\n\t         concerning the ENOUGH constants, which depend on those values */\n\t      state.lenbits = 9;\n\t\n\t      opts = { bits: state.lenbits };\n\t      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n\t      // We have separate tables & no pointers. 2 commented lines below not needed.\n\t      // state.next_index = opts.table_index;\n\t      state.lenbits = opts.bits;\n\t      // state.lencode = state.next;\n\t\n\t      if (ret) {\n\t        strm.msg = 'invalid literal/lengths set';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t\n\t      state.distbits = 6;\n\t      //state.distcode.copy(state.codes);\n\t      // Switch to use dynamic table\n\t      state.distcode = state.distdyn;\n\t      opts = { bits: state.distbits };\n\t      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n\t      // We have separate tables & no pointers. 2 commented lines below not needed.\n\t      // state.next_index = opts.table_index;\n\t      state.distbits = opts.bits;\n\t      // state.distcode = state.next;\n\t\n\t      if (ret) {\n\t        strm.msg = 'invalid distances set';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      //Tracev((stderr, 'inflate:       codes ok\\n'));\n\t      state.mode = LEN_;\n\t      if (flush === Z_TREES) { break inf_leave; }\n\t      /* falls through */\n\t    case LEN_:\n\t      state.mode = LEN;\n\t      /* falls through */\n\t    case LEN:\n\t      if (have >= 6 && left >= 258) {\n\t        //--- RESTORE() ---\n\t        strm.next_out = put;\n\t        strm.avail_out = left;\n\t        strm.next_in = next;\n\t        strm.avail_in = have;\n\t        state.hold = hold;\n\t        state.bits = bits;\n\t        //---\n\t        inflate_fast(strm, _out);\n\t        //--- LOAD() ---\n\t        put = strm.next_out;\n\t        output = strm.output;\n\t        left = strm.avail_out;\n\t        next = strm.next_in;\n\t        input = strm.input;\n\t        have = strm.avail_in;\n\t        hold = state.hold;\n\t        bits = state.bits;\n\t        //---\n\t\n\t        if (state.mode === TYPE) {\n\t          state.back = -1;\n\t        }\n\t        break;\n\t      }\n\t      state.back = 0;\n\t      for (;;) {\n\t        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n\t        here_bits = here >>> 24;\n\t        here_op = (here >>> 16) & 0xff;\n\t        here_val = here & 0xffff;\n\t\n\t        if (here_bits <= bits) { break; }\n\t        //--- PULLBYTE() ---//\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t        //---//\n\t      }\n\t      if (here_op && (here_op & 0xf0) === 0) {\n\t        last_bits = here_bits;\n\t        last_op = here_op;\n\t        last_val = here_val;\n\t        for (;;) {\n\t          here = state.lencode[last_val +\n\t                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t          here_bits = here >>> 24;\n\t          here_op = (here >>> 16) & 0xff;\n\t          here_val = here & 0xffff;\n\t\n\t          if ((last_bits + here_bits) <= bits) { break; }\n\t          //--- PULLBYTE() ---//\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t          //---//\n\t        }\n\t        //--- DROPBITS(last.bits) ---//\n\t        hold >>>= last_bits;\n\t        bits -= last_bits;\n\t        //---//\n\t        state.back += last_bits;\n\t      }\n\t      //--- DROPBITS(here.bits) ---//\n\t      hold >>>= here_bits;\n\t      bits -= here_bits;\n\t      //---//\n\t      state.back += here_bits;\n\t      state.length = here_val;\n\t      if (here_op === 0) {\n\t        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t        //        \"inflate:         literal '%c'\\n\" :\n\t        //        \"inflate:         literal 0x%02x\\n\", here.val));\n\t        state.mode = LIT;\n\t        break;\n\t      }\n\t      if (here_op & 32) {\n\t        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t        state.back = -1;\n\t        state.mode = TYPE;\n\t        break;\n\t      }\n\t      if (here_op & 64) {\n\t        strm.msg = 'invalid literal/length code';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      state.extra = here_op & 15;\n\t      state.mode = LENEXT;\n\t      /* falls through */\n\t    case LENEXT:\n\t      if (state.extra) {\n\t        //=== NEEDBITS(state.extra);\n\t        n = state.extra;\n\t        while (bits < n) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t        //--- DROPBITS(state.extra) ---//\n\t        hold >>>= state.extra;\n\t        bits -= state.extra;\n\t        //---//\n\t        state.back += state.extra;\n\t      }\n\t      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n\t      state.was = state.length;\n\t      state.mode = DIST;\n\t      /* falls through */\n\t    case DIST:\n\t      for (;;) {\n\t        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n\t        here_bits = here >>> 24;\n\t        here_op = (here >>> 16) & 0xff;\n\t        here_val = here & 0xffff;\n\t\n\t        if ((here_bits) <= bits) { break; }\n\t        //--- PULLBYTE() ---//\n\t        if (have === 0) { break inf_leave; }\n\t        have--;\n\t        hold += input[next++] << bits;\n\t        bits += 8;\n\t        //---//\n\t      }\n\t      if ((here_op & 0xf0) === 0) {\n\t        last_bits = here_bits;\n\t        last_op = here_op;\n\t        last_val = here_val;\n\t        for (;;) {\n\t          here = state.distcode[last_val +\n\t                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t          here_bits = here >>> 24;\n\t          here_op = (here >>> 16) & 0xff;\n\t          here_val = here & 0xffff;\n\t\n\t          if ((last_bits + here_bits) <= bits) { break; }\n\t          //--- PULLBYTE() ---//\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t          //---//\n\t        }\n\t        //--- DROPBITS(last.bits) ---//\n\t        hold >>>= last_bits;\n\t        bits -= last_bits;\n\t        //---//\n\t        state.back += last_bits;\n\t      }\n\t      //--- DROPBITS(here.bits) ---//\n\t      hold >>>= here_bits;\n\t      bits -= here_bits;\n\t      //---//\n\t      state.back += here_bits;\n\t      if (here_op & 64) {\n\t        strm.msg = 'invalid distance code';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t      state.offset = here_val;\n\t      state.extra = (here_op) & 15;\n\t      state.mode = DISTEXT;\n\t      /* falls through */\n\t    case DISTEXT:\n\t      if (state.extra) {\n\t        //=== NEEDBITS(state.extra);\n\t        n = state.extra;\n\t        while (bits < n) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t        //--- DROPBITS(state.extra) ---//\n\t        hold >>>= state.extra;\n\t        bits -= state.extra;\n\t        //---//\n\t        state.back += state.extra;\n\t      }\n\t//#ifdef INFLATE_STRICT\n\t      if (state.offset > state.dmax) {\n\t        strm.msg = 'invalid distance too far back';\n\t        state.mode = BAD;\n\t        break;\n\t      }\n\t//#endif\n\t      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n\t      state.mode = MATCH;\n\t      /* falls through */\n\t    case MATCH:\n\t      if (left === 0) { break inf_leave; }\n\t      copy = _out - left;\n\t      if (state.offset > copy) {         /* copy from window */\n\t        copy = state.offset - copy;\n\t        if (copy > state.whave) {\n\t          if (state.sane) {\n\t            strm.msg = 'invalid distance too far back';\n\t            state.mode = BAD;\n\t            break;\n\t          }\n\t// (!) This block is disabled in zlib defailts,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//          Trace((stderr, \"inflate.c too far\\n\"));\n\t//          copy -= state.whave;\n\t//          if (copy > state.length) { copy = state.length; }\n\t//          if (copy > left) { copy = left; }\n\t//          left -= copy;\n\t//          state.length -= copy;\n\t//          do {\n\t//            output[put++] = 0;\n\t//          } while (--copy);\n\t//          if (state.length === 0) { state.mode = LEN; }\n\t//          break;\n\t//#endif\n\t        }\n\t        if (copy > state.wnext) {\n\t          copy -= state.wnext;\n\t          from = state.wsize - copy;\n\t        }\n\t        else {\n\t          from = state.wnext - copy;\n\t        }\n\t        if (copy > state.length) { copy = state.length; }\n\t        from_source = state.window;\n\t      }\n\t      else {                              /* copy from output */\n\t        from_source = output;\n\t        from = put - state.offset;\n\t        copy = state.length;\n\t      }\n\t      if (copy > left) { copy = left; }\n\t      left -= copy;\n\t      state.length -= copy;\n\t      do {\n\t        output[put++] = from_source[from++];\n\t      } while (--copy);\n\t      if (state.length === 0) { state.mode = LEN; }\n\t      break;\n\t    case LIT:\n\t      if (left === 0) { break inf_leave; }\n\t      output[put++] = state.length;\n\t      left--;\n\t      state.mode = LEN;\n\t      break;\n\t    case CHECK:\n\t      if (state.wrap) {\n\t        //=== NEEDBITS(32);\n\t        while (bits < 32) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          // Use '|' insdead of '+' to make sure that result is signed\n\t          hold |= input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        _out -= left;\n\t        strm.total_out += _out;\n\t        state.total += _out;\n\t        if (_out) {\n\t          strm.adler = state.check =\n\t              /*UPDATE(state.check, put - _out, _out);*/\n\t              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\t\n\t        }\n\t        _out = left;\n\t        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n\t        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n\t          strm.msg = 'incorrect data check';\n\t          state.mode = BAD;\n\t          break;\n\t        }\n\t        //=== INITBITS();\n\t        hold = 0;\n\t        bits = 0;\n\t        //===//\n\t        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\t      }\n\t      state.mode = LENGTH;\n\t      /* falls through */\n\t    case LENGTH:\n\t      if (state.wrap && state.flags) {\n\t        //=== NEEDBITS(32);\n\t        while (bits < 32) {\n\t          if (have === 0) { break inf_leave; }\n\t          have--;\n\t          hold += input[next++] << bits;\n\t          bits += 8;\n\t        }\n\t        //===//\n\t        if (hold !== (state.total & 0xffffffff)) {\n\t          strm.msg = 'incorrect length check';\n\t          state.mode = BAD;\n\t          break;\n\t        }\n\t        //=== INITBITS();\n\t        hold = 0;\n\t        bits = 0;\n\t        //===//\n\t        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\t      }\n\t      state.mode = DONE;\n\t      /* falls through */\n\t    case DONE:\n\t      ret = Z_STREAM_END;\n\t      break inf_leave;\n\t    case BAD:\n\t      ret = Z_DATA_ERROR;\n\t      break inf_leave;\n\t    case MEM:\n\t      return Z_MEM_ERROR;\n\t    case SYNC:\n\t      /* falls through */\n\t    default:\n\t      return Z_STREAM_ERROR;\n\t    }\n\t  }\n\t\n\t  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\t\n\t  /*\n\t     Return from inflate(), updating the total counts and the check value.\n\t     If there was no progress during the inflate() call, return a buffer\n\t     error.  Call updatewindow() to create and/or update the window state.\n\t     Note: a memory error from inflate() is non-recoverable.\n\t   */\n\t\n\t  //--- RESTORE() ---\n\t  strm.next_out = put;\n\t  strm.avail_out = left;\n\t  strm.next_in = next;\n\t  strm.avail_in = have;\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  //---\n\t\n\t  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n\t                      (state.mode < CHECK || flush !== Z_FINISH))) {\n\t    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n\t      state.mode = MEM;\n\t      return Z_MEM_ERROR;\n\t    }\n\t  }\n\t  _in -= strm.avail_in;\n\t  _out -= strm.avail_out;\n\t  strm.total_in += _in;\n\t  strm.total_out += _out;\n\t  state.total += _out;\n\t  if (state.wrap && _out) {\n\t    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n\t      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n\t  }\n\t  strm.data_type = state.bits + (state.last ? 64 : 0) +\n\t                    (state.mode === TYPE ? 128 : 0) +\n\t                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\t  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n\t    ret = Z_BUF_ERROR;\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction inflateEnd(strm) {\n\t\n\t  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  var state = strm.state;\n\t  if (state.window) {\n\t    state.window = null;\n\t  }\n\t  strm.state = null;\n\t  return Z_OK;\n\t}\n\t\n\tfunction inflateGetHeader(strm, head) {\n\t  var state;\n\t\n\t  /* check state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n\t  state = strm.state;\n\t  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\t\n\t  /* save header structure */\n\t  state.head = head;\n\t  head.done = false;\n\t  return Z_OK;\n\t}\n\t\n\tfunction inflateSetDictionary(strm, dictionary) {\n\t  var dictLength = dictionary.length;\n\t\n\t  var state;\n\t  var dictid;\n\t  var ret;\n\t\n\t  /* check state */\n\t  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n\t  state = strm.state;\n\t\n\t  if (state.wrap !== 0 && state.mode !== DICT) {\n\t    return Z_STREAM_ERROR;\n\t  }\n\t\n\t  /* check for correct dictionary identifier */\n\t  if (state.mode === DICT) {\n\t    dictid = 1; /* adler32(0, null, 0)*/\n\t    /* dictid = adler32(dictid, dictionary, dictLength); */\n\t    dictid = adler32(dictid, dictionary, dictLength, 0);\n\t    if (dictid !== state.check) {\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  /* copy dictionary to window using updatewindow(), which will amend the\n\t   existing dictionary if appropriate */\n\t  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n\t  if (ret) {\n\t    state.mode = MEM;\n\t    return Z_MEM_ERROR;\n\t  }\n\t  state.havedict = 1;\n\t  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n\t  return Z_OK;\n\t}\n\t\n\texports.inflateReset = inflateReset;\n\texports.inflateReset2 = inflateReset2;\n\texports.inflateResetKeep = inflateResetKeep;\n\texports.inflateInit = inflateInit;\n\texports.inflateInit2 = inflateInit2;\n\texports.inflate = inflate;\n\texports.inflateEnd = inflateEnd;\n\texports.inflateGetHeader = inflateGetHeader;\n\texports.inflateSetDictionary = inflateSetDictionary;\n\texports.inflateInfo = 'pako inflate (from Nodeca project)';\n\t\n\t/* Not implemented\n\texports.inflateCopy = inflateCopy;\n\texports.inflateGetDictionary = inflateGetDictionary;\n\texports.inflateMark = inflateMark;\n\texports.inflatePrime = inflatePrime;\n\texports.inflateSync = inflateSync;\n\texports.inflateSyncPoint = inflateSyncPoint;\n\texports.inflateUndermine = inflateUndermine;\n\t*/\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// See state defs from inflate.js\n\tvar BAD = 30;       /* got a data error -- remain here until reset */\n\tvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\t\n\t/*\n\t   Decode literal, length, and distance codes and write out the resulting\n\t   literal and match bytes until either not enough input or output is\n\t   available, an end-of-block is encountered, or a data error is encountered.\n\t   When large enough input and output buffers are supplied to inflate(), for\n\t   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n\t   inflate execution time is spent in this routine.\n\t\n\t   Entry assumptions:\n\t\n\t        state.mode === LEN\n\t        strm.avail_in >= 6\n\t        strm.avail_out >= 258\n\t        start >= strm.avail_out\n\t        state.bits < 8\n\t\n\t   On return, state.mode is one of:\n\t\n\t        LEN -- ran out of enough output space or enough available input\n\t        TYPE -- reached end of block code, inflate() to interpret next block\n\t        BAD -- error in block data\n\t\n\t   Notes:\n\t\n\t    - The maximum input bits used by a length/distance pair is 15 bits for the\n\t      length code, 5 bits for the length extra, 15 bits for the distance code,\n\t      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n\t      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n\t      checking for available input while decoding.\n\t\n\t    - The maximum bytes that a single length/distance pair can output is 258\n\t      bytes, which is the maximum length that can be coded.  inflate_fast()\n\t      requires strm.avail_out >= 258 for each loop to avoid checking for\n\t      output space.\n\t */\n\tmodule.exports = function inflate_fast(strm, start) {\n\t  var state;\n\t  var _in;                    /* local strm.input */\n\t  var last;                   /* have enough input while in < last */\n\t  var _out;                   /* local strm.output */\n\t  var beg;                    /* inflate()'s initial strm.output */\n\t  var end;                    /* while out < end, enough space available */\n\t//#ifdef INFLATE_STRICT\n\t  var dmax;                   /* maximum distance from zlib header */\n\t//#endif\n\t  var wsize;                  /* window size or zero if not using window */\n\t  var whave;                  /* valid bytes in the window */\n\t  var wnext;                  /* window write index */\n\t  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n\t  var s_window;               /* allocated sliding window, if wsize != 0 */\n\t  var hold;                   /* local strm.hold */\n\t  var bits;                   /* local strm.bits */\n\t  var lcode;                  /* local strm.lencode */\n\t  var dcode;                  /* local strm.distcode */\n\t  var lmask;                  /* mask for first level of length codes */\n\t  var dmask;                  /* mask for first level of distance codes */\n\t  var here;                   /* retrieved table entry */\n\t  var op;                     /* code bits, operation, extra bits, or */\n\t                              /*  window position, window bytes to copy */\n\t  var len;                    /* match length, unused bytes */\n\t  var dist;                   /* match distance */\n\t  var from;                   /* where to copy match from */\n\t  var from_source;\n\t\n\t\n\t  var input, output; // JS specific, because we have no pointers\n\t\n\t  /* copy state to local variables */\n\t  state = strm.state;\n\t  //here = state.here;\n\t  _in = strm.next_in;\n\t  input = strm.input;\n\t  last = _in + (strm.avail_in - 5);\n\t  _out = strm.next_out;\n\t  output = strm.output;\n\t  beg = _out - (start - strm.avail_out);\n\t  end = _out + (strm.avail_out - 257);\n\t//#ifdef INFLATE_STRICT\n\t  dmax = state.dmax;\n\t//#endif\n\t  wsize = state.wsize;\n\t  whave = state.whave;\n\t  wnext = state.wnext;\n\t  s_window = state.window;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  lcode = state.lencode;\n\t  dcode = state.distcode;\n\t  lmask = (1 << state.lenbits) - 1;\n\t  dmask = (1 << state.distbits) - 1;\n\t\n\t\n\t  /* decode literals and length/distances until end-of-block or not enough\n\t     input data or output space */\n\t\n\t  top:\n\t  do {\n\t    if (bits < 15) {\n\t      hold += input[_in++] << bits;\n\t      bits += 8;\n\t      hold += input[_in++] << bits;\n\t      bits += 8;\n\t    }\n\t\n\t    here = lcode[hold & lmask];\n\t\n\t    dolen:\n\t    for (;;) { // Goto emulation\n\t      op = here >>> 24/*here.bits*/;\n\t      hold >>>= op;\n\t      bits -= op;\n\t      op = (here >>> 16) & 0xff/*here.op*/;\n\t      if (op === 0) {                          /* literal */\n\t        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t        //        \"inflate:         literal '%c'\\n\" :\n\t        //        \"inflate:         literal 0x%02x\\n\", here.val));\n\t        output[_out++] = here & 0xffff/*here.val*/;\n\t      }\n\t      else if (op & 16) {                     /* length base */\n\t        len = here & 0xffff/*here.val*/;\n\t        op &= 15;                           /* number of extra bits */\n\t        if (op) {\n\t          if (bits < op) {\n\t            hold += input[_in++] << bits;\n\t            bits += 8;\n\t          }\n\t          len += hold & ((1 << op) - 1);\n\t          hold >>>= op;\n\t          bits -= op;\n\t        }\n\t        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n\t        if (bits < 15) {\n\t          hold += input[_in++] << bits;\n\t          bits += 8;\n\t          hold += input[_in++] << bits;\n\t          bits += 8;\n\t        }\n\t        here = dcode[hold & dmask];\n\t\n\t        dodist:\n\t        for (;;) { // goto emulation\n\t          op = here >>> 24/*here.bits*/;\n\t          hold >>>= op;\n\t          bits -= op;\n\t          op = (here >>> 16) & 0xff/*here.op*/;\n\t\n\t          if (op & 16) {                      /* distance base */\n\t            dist = here & 0xffff/*here.val*/;\n\t            op &= 15;                       /* number of extra bits */\n\t            if (bits < op) {\n\t              hold += input[_in++] << bits;\n\t              bits += 8;\n\t              if (bits < op) {\n\t                hold += input[_in++] << bits;\n\t                bits += 8;\n\t              }\n\t            }\n\t            dist += hold & ((1 << op) - 1);\n\t//#ifdef INFLATE_STRICT\n\t            if (dist > dmax) {\n\t              strm.msg = 'invalid distance too far back';\n\t              state.mode = BAD;\n\t              break top;\n\t            }\n\t//#endif\n\t            hold >>>= op;\n\t            bits -= op;\n\t            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n\t            op = _out - beg;                /* max distance in output */\n\t            if (dist > op) {                /* see if copy from window */\n\t              op = dist - op;               /* distance back in window */\n\t              if (op > whave) {\n\t                if (state.sane) {\n\t                  strm.msg = 'invalid distance too far back';\n\t                  state.mode = BAD;\n\t                  break top;\n\t                }\n\t\n\t// (!) This block is disabled in zlib defailts,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//                if (len <= op - whave) {\n\t//                  do {\n\t//                    output[_out++] = 0;\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//                len -= op - whave;\n\t//                do {\n\t//                  output[_out++] = 0;\n\t//                } while (--op > whave);\n\t//                if (op === 0) {\n\t//                  from = _out - dist;\n\t//                  do {\n\t//                    output[_out++] = output[from++];\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//#endif\n\t              }\n\t              from = 0; // window index\n\t              from_source = s_window;\n\t              if (wnext === 0) {           /* very common case */\n\t                from += wsize - op;\n\t                if (op < len) {         /* some from window */\n\t                  len -= op;\n\t                  do {\n\t                    output[_out++] = s_window[from++];\n\t                  } while (--op);\n\t                  from = _out - dist;  /* rest from output */\n\t                  from_source = output;\n\t                }\n\t              }\n\t              else if (wnext < op) {      /* wrap around window */\n\t                from += wsize + wnext - op;\n\t                op -= wnext;\n\t                if (op < len) {         /* some from end of window */\n\t                  len -= op;\n\t                  do {\n\t                    output[_out++] = s_window[from++];\n\t                  } while (--op);\n\t                  from = 0;\n\t                  if (wnext < len) {  /* some from start of window */\n\t                    op = wnext;\n\t                    len -= op;\n\t                    do {\n\t                      output[_out++] = s_window[from++];\n\t                    } while (--op);\n\t                    from = _out - dist;      /* rest from output */\n\t                    from_source = output;\n\t                  }\n\t                }\n\t              }\n\t              else {                      /* contiguous in window */\n\t                from += wnext - op;\n\t                if (op < len) {         /* some from window */\n\t                  len -= op;\n\t                  do {\n\t                    output[_out++] = s_window[from++];\n\t                  } while (--op);\n\t                  from = _out - dist;  /* rest from output */\n\t                  from_source = output;\n\t                }\n\t              }\n\t              while (len > 2) {\n\t                output[_out++] = from_source[from++];\n\t                output[_out++] = from_source[from++];\n\t                output[_out++] = from_source[from++];\n\t                len -= 3;\n\t              }\n\t              if (len) {\n\t                output[_out++] = from_source[from++];\n\t                if (len > 1) {\n\t                  output[_out++] = from_source[from++];\n\t                }\n\t              }\n\t            }\n\t            else {\n\t              from = _out - dist;          /* copy direct from output */\n\t              do {                        /* minimum length is three */\n\t                output[_out++] = output[from++];\n\t                output[_out++] = output[from++];\n\t                output[_out++] = output[from++];\n\t                len -= 3;\n\t              } while (len > 2);\n\t              if (len) {\n\t                output[_out++] = output[from++];\n\t                if (len > 1) {\n\t                  output[_out++] = output[from++];\n\t                }\n\t              }\n\t            }\n\t          }\n\t          else if ((op & 64) === 0) {          /* 2nd level distance code */\n\t            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t            continue dodist;\n\t          }\n\t          else {\n\t            strm.msg = 'invalid distance code';\n\t            state.mode = BAD;\n\t            break top;\n\t          }\n\t\n\t          break; // need to emulate goto via \"continue\"\n\t        }\n\t      }\n\t      else if ((op & 64) === 0) {              /* 2nd level length code */\n\t        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t        continue dolen;\n\t      }\n\t      else if (op & 32) {                     /* end-of-block */\n\t        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t        state.mode = TYPE;\n\t        break top;\n\t      }\n\t      else {\n\t        strm.msg = 'invalid literal/length code';\n\t        state.mode = BAD;\n\t        break top;\n\t      }\n\t\n\t      break; // need to emulate goto via \"continue\"\n\t    }\n\t  } while (_in < last && _out < end);\n\t\n\t  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n\t  len = bits >> 3;\n\t  _in -= len;\n\t  bits -= len << 3;\n\t  hold &= (1 << bits) - 1;\n\t\n\t  /* update state and return */\n\t  strm.next_in = _in;\n\t  strm.next_out = _out;\n\t  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n\t  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  return;\n\t};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\tvar utils = __webpack_require__(36);\n\t\n\tvar MAXBITS = 15;\n\tvar ENOUGH_LENS = 852;\n\tvar ENOUGH_DISTS = 592;\n\t//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\t\n\tvar CODES = 0;\n\tvar LENS = 1;\n\tvar DISTS = 2;\n\t\n\tvar lbase = [ /* Length codes 257..285 base */\n\t  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n\t];\n\t\n\tvar lext = [ /* Length codes 257..285 extra */\n\t  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n\t  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n\t];\n\t\n\tvar dbase = [ /* Distance codes 0..29 base */\n\t  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t  8193, 12289, 16385, 24577, 0, 0\n\t];\n\t\n\tvar dext = [ /* Distance codes 0..29 extra */\n\t  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n\t  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n\t  28, 28, 29, 29, 64, 64\n\t];\n\t\n\tmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n\t{\n\t  var bits = opts.bits;\n\t      //here = opts.here; /* table entry for duplication */\n\t\n\t  var len = 0;               /* a code's length in bits */\n\t  var sym = 0;               /* index of code symbols */\n\t  var min = 0, max = 0;          /* minimum and maximum code lengths */\n\t  var root = 0;              /* number of index bits for root table */\n\t  var curr = 0;              /* number of index bits for current table */\n\t  var drop = 0;              /* code bits to drop for sub-table */\n\t  var left = 0;                   /* number of prefix codes available */\n\t  var used = 0;              /* code entries in table used */\n\t  var huff = 0;              /* Huffman code */\n\t  var incr;              /* for incrementing code, index */\n\t  var fill;              /* index for replicating entries */\n\t  var low;               /* low bits for current root entry */\n\t  var mask;              /* mask for low root bits */\n\t  var next;             /* next available space in table */\n\t  var base = null;     /* base value table to use */\n\t  var base_index = 0;\n\t//  var shoextra;    /* extra bits table to use */\n\t  var end;                    /* use base and extra for symbol > end */\n\t  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n\t  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n\t  var extra = null;\n\t  var extra_index = 0;\n\t\n\t  var here_bits, here_op, here_val;\n\t\n\t  /*\n\t   Process a set of code lengths to create a canonical Huffman code.  The\n\t   code lengths are lens[0..codes-1].  Each length corresponds to the\n\t   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n\t   symbols by length from short to long, and retaining the symbol order\n\t   for codes with equal lengths.  Then the code starts with all zero bits\n\t   for the first code of the shortest length, and the codes are integer\n\t   increments for the same length, and zeros are appended as the length\n\t   increases.  For the deflate format, these bits are stored backwards\n\t   from their more natural integer increment ordering, and so when the\n\t   decoding tables are built in the large loop below, the integer codes\n\t   are incremented backwards.\n\t\n\t   This routine assumes, but does not check, that all of the entries in\n\t   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n\t   1..MAXBITS is interpreted as that code length.  zero means that that\n\t   symbol does not occur in this code.\n\t\n\t   The codes are sorted by computing a count of codes for each length,\n\t   creating from that a table of starting indices for each length in the\n\t   sorted table, and then entering the symbols in order in the sorted\n\t   table.  The sorted table is work[], with that space being provided by\n\t   the caller.\n\t\n\t   The length counts are used for other purposes as well, i.e. finding\n\t   the minimum and maximum length codes, determining if there are any\n\t   codes at all, checking for a valid set of lengths, and looking ahead\n\t   at length counts to determine sub-table sizes when building the\n\t   decoding tables.\n\t   */\n\t\n\t  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n\t  for (len = 0; len <= MAXBITS; len++) {\n\t    count[len] = 0;\n\t  }\n\t  for (sym = 0; sym < codes; sym++) {\n\t    count[lens[lens_index + sym]]++;\n\t  }\n\t\n\t  /* bound code lengths, force root to be within code lengths */\n\t  root = bits;\n\t  for (max = MAXBITS; max >= 1; max--) {\n\t    if (count[max] !== 0) { break; }\n\t  }\n\t  if (root > max) {\n\t    root = max;\n\t  }\n\t  if (max === 0) {                     /* no symbols to code at all */\n\t    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n\t    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n\t    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n\t    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\t\n\t\n\t    //table.op[opts.table_index] = 64;\n\t    //table.bits[opts.table_index] = 1;\n\t    //table.val[opts.table_index++] = 0;\n\t    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\t\n\t    opts.bits = 1;\n\t    return 0;     /* no symbols, but wait for decoding to report error */\n\t  }\n\t  for (min = 1; min < max; min++) {\n\t    if (count[min] !== 0) { break; }\n\t  }\n\t  if (root < min) {\n\t    root = min;\n\t  }\n\t\n\t  /* check for an over-subscribed or incomplete set of lengths */\n\t  left = 1;\n\t  for (len = 1; len <= MAXBITS; len++) {\n\t    left <<= 1;\n\t    left -= count[len];\n\t    if (left < 0) {\n\t      return -1;\n\t    }        /* over-subscribed */\n\t  }\n\t  if (left > 0 && (type === CODES || max !== 1)) {\n\t    return -1;                      /* incomplete set */\n\t  }\n\t\n\t  /* generate offsets into symbol table for each length for sorting */\n\t  offs[1] = 0;\n\t  for (len = 1; len < MAXBITS; len++) {\n\t    offs[len + 1] = offs[len] + count[len];\n\t  }\n\t\n\t  /* sort symbols by length, by symbol order within each length */\n\t  for (sym = 0; sym < codes; sym++) {\n\t    if (lens[lens_index + sym] !== 0) {\n\t      work[offs[lens[lens_index + sym]]++] = sym;\n\t    }\n\t  }\n\t\n\t  /*\n\t   Create and fill in decoding tables.  In this loop, the table being\n\t   filled is at next and has curr index bits.  The code being used is huff\n\t   with length len.  That code is converted to an index by dropping drop\n\t   bits off of the bottom.  For codes where len is less than drop + curr,\n\t   those top drop + curr - len bits are incremented through all values to\n\t   fill the table with replicated entries.\n\t\n\t   root is the number of index bits for the root table.  When len exceeds\n\t   root, sub-tables are created pointed to by the root entry with an index\n\t   of the low root bits of huff.  This is saved in low to check for when a\n\t   new sub-table should be started.  drop is zero when the root table is\n\t   being filled, and drop is root when sub-tables are being filled.\n\t\n\t   When a new sub-table is needed, it is necessary to look ahead in the\n\t   code lengths to determine what size sub-table is needed.  The length\n\t   counts are used for this, and so count[] is decremented as codes are\n\t   entered in the tables.\n\t\n\t   used keeps track of how many table entries have been allocated from the\n\t   provided *table space.  It is checked for LENS and DIST tables against\n\t   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n\t   the initial root table size constants.  See the comments in inftrees.h\n\t   for more information.\n\t\n\t   sym increments through all symbols, and the loop terminates when\n\t   all codes of length max, i.e. all codes, have been processed.  This\n\t   routine permits incomplete codes, so another loop after this one fills\n\t   in the rest of the decoding tables with invalid code markers.\n\t   */\n\t\n\t  /* set up for code type */\n\t  // poor man optimization - use if-else instead of switch,\n\t  // to avoid deopts in old v8\n\t  if (type === CODES) {\n\t    base = extra = work;    /* dummy value--not used */\n\t    end = 19;\n\t\n\t  } else if (type === LENS) {\n\t    base = lbase;\n\t    base_index -= 257;\n\t    extra = lext;\n\t    extra_index -= 257;\n\t    end = 256;\n\t\n\t  } else {                    /* DISTS */\n\t    base = dbase;\n\t    extra = dext;\n\t    end = -1;\n\t  }\n\t\n\t  /* initialize opts for loop */\n\t  huff = 0;                   /* starting code */\n\t  sym = 0;                    /* starting code symbol */\n\t  len = min;                  /* starting code length */\n\t  next = table_index;              /* current table to fill in */\n\t  curr = root;                /* current table index bits */\n\t  drop = 0;                   /* current bits to drop from code for index */\n\t  low = -1;                   /* trigger new sub-table when len > root */\n\t  used = 1 << root;          /* use root table entries */\n\t  mask = used - 1;            /* mask for comparing low */\n\t\n\t  /* check available table space */\n\t  if ((type === LENS && used > ENOUGH_LENS) ||\n\t    (type === DISTS && used > ENOUGH_DISTS)) {\n\t    return 1;\n\t  }\n\t\n\t  var i = 0;\n\t  /* process all codes and make table entries */\n\t  for (;;) {\n\t    i++;\n\t    /* create table entry */\n\t    here_bits = len - drop;\n\t    if (work[sym] < end) {\n\t      here_op = 0;\n\t      here_val = work[sym];\n\t    }\n\t    else if (work[sym] > end) {\n\t      here_op = extra[extra_index + work[sym]];\n\t      here_val = base[base_index + work[sym]];\n\t    }\n\t    else {\n\t      here_op = 32 + 64;         /* end of block */\n\t      here_val = 0;\n\t    }\n\t\n\t    /* replicate for those indices with low len bits equal to huff */\n\t    incr = 1 << (len - drop);\n\t    fill = 1 << curr;\n\t    min = fill;                 /* save offset to next table */\n\t    do {\n\t      fill -= incr;\n\t      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n\t    } while (fill !== 0);\n\t\n\t    /* backwards increment the len-bit code huff */\n\t    incr = 1 << (len - 1);\n\t    while (huff & incr) {\n\t      incr >>= 1;\n\t    }\n\t    if (incr !== 0) {\n\t      huff &= incr - 1;\n\t      huff += incr;\n\t    } else {\n\t      huff = 0;\n\t    }\n\t\n\t    /* go to next symbol, update count, len */\n\t    sym++;\n\t    if (--count[len] === 0) {\n\t      if (len === max) { break; }\n\t      len = lens[lens_index + work[sym]];\n\t    }\n\t\n\t    /* create new sub-table if needed */\n\t    if (len > root && (huff & mask) !== low) {\n\t      /* if first time, transition to sub-tables */\n\t      if (drop === 0) {\n\t        drop = root;\n\t      }\n\t\n\t      /* increment past last table */\n\t      next += min;            /* here min is 1 << curr */\n\t\n\t      /* determine length of next table */\n\t      curr = len - drop;\n\t      left = 1 << curr;\n\t      while (curr + drop < max) {\n\t        left -= count[curr + drop];\n\t        if (left <= 0) { break; }\n\t        curr++;\n\t        left <<= 1;\n\t      }\n\t\n\t      /* check for enough space */\n\t      used += 1 << curr;\n\t      if ((type === LENS && used > ENOUGH_LENS) ||\n\t        (type === DISTS && used > ENOUGH_DISTS)) {\n\t        return 1;\n\t      }\n\t\n\t      /* point entry in root table to sub-table */\n\t      low = huff & mask;\n\t      /*table.op[low] = curr;\n\t      table.bits[low] = root;\n\t      table.val[low] = next - opts.table_index;*/\n\t      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n\t    }\n\t  }\n\t\n\t  /* fill in remaining table entry if code is incomplete (guaranteed to have\n\t   at most one remaining entry, since if the code is incomplete, the\n\t   maximum code length that was allowed to get this far is one bit) */\n\t  if (huff !== 0) {\n\t    //table.op[next + huff] = 64;            /* invalid code marker */\n\t    //table.bits[next + huff] = len - drop;\n\t    //table.val[next + huff] = 0;\n\t    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n\t  }\n\t\n\t  /* set return parameters */\n\t  //opts.table_index += used;\n\t  opts.bits = root;\n\t  return 0;\n\t};\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t\n\tfunction ZStream() {\n\t  /* next input byte */\n\t  this.input = null; // JS specific, because we have no pointers\n\t  this.next_in = 0;\n\t  /* number of bytes available at input */\n\t  this.avail_in = 0;\n\t  /* total number of input bytes read so far */\n\t  this.total_in = 0;\n\t  /* next output byte should be put there */\n\t  this.output = null; // JS specific, because we have no pointers\n\t  this.next_out = 0;\n\t  /* remaining free space at output */\n\t  this.avail_out = 0;\n\t  /* total number of bytes output so far */\n\t  this.total_out = 0;\n\t  /* last error message, NULL if no error */\n\t  this.msg = ''/*Z_NULL*/;\n\t  /* not visible by applications */\n\t  this.state = null;\n\t  /* best guess about the data type: binary or text */\n\t  this.data_type = 2/*Z_UNKNOWN*/;\n\t  /* adler32 value of the uncompressed data */\n\t  this.adler = 0;\n\t}\n\t\n\tmodule.exports = ZStream;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"name\": \"doppiojvm\",\n\t\t\"version\": \"0.4.2\",\n\t\t\"engine\": \"node >= 4.0.0\",\n\t\t\"license\": \"MIT\",\n\t\t\"main\": \"dist/release/doppio.js\",\n\t\t\"typings\": \"dist/typings/src/doppiojvm\",\n\t\t\"dependencies\": {\n\t\t\t\"async\": \"^2.0.0\",\n\t\t\t\"browserfs\": \"^0.5.12\",\n\t\t\t\"glob\": \"^7.0.3\",\n\t\t\t\"gunzip-maybe\": \"^1.3.1\",\n\t\t\t\"optimist\": \"~0.6\",\n\t\t\t\"pako\": \"^1.0.1\",\n\t\t\t\"rimraf\": \"^2.5.2\",\n\t\t\t\"source-map-support\": \"^0.4.0\",\n\t\t\t\"tar-fs\": \"^1.12.0\"\n\t\t},\n\t\t\"devDependencies\": {\n\t\t\t\"bfs-buffer\": \"^0.1.7\",\n\t\t\t\"bfs-path\": \"^0.1.2\",\n\t\t\t\"bfs-process\": \"^0.1.6\",\n\t\t\t\"body-parser\": \"^1.15.1\",\n\t\t\t\"cpr\": \"^2.0.0\",\n\t\t\t\"detect-browser\": \"^1.3.1\",\n\t\t\t\"escodegen\": \"^1.8.0\",\n\t\t\t\"esprima\": \"^2.7.2\",\n\t\t\t\"estraverse\": \"^4.2.0\",\n\t\t\t\"express\": \"^4.13.4\",\n\t\t\t\"grunt\": \"^1.0\",\n\t\t\t\"grunt-cli\": \"^1.2\",\n\t\t\t\"grunt-contrib-compress\": \"^1.2.0\",\n\t\t\t\"grunt-contrib-connect\": \"^1.0\",\n\t\t\t\"grunt-contrib-copy\": \"^1.0\",\n\t\t\t\"grunt-contrib-uglify\": \"^2.0\",\n\t\t\t\"grunt-karma\": \"^2.0\",\n\t\t\t\"grunt-lineending\": \"^1.0.0\",\n\t\t\t\"grunt-merge-source-maps\": \"^0.1.0\",\n\t\t\t\"grunt-newer\": \"^1.2.0\",\n\t\t\t\"grunt-ts\": \"^5.5\",\n\t\t\t\"grunt-webpack\": \"^1.0.11\",\n\t\t\t\"imports-loader\": \"^0.6.5\",\n\t\t\t\"jasmine-core\": \"^2.3.4\",\n\t\t\t\"json-loader\": \"^0.5.4\",\n\t\t\t\"karma\": \"^1.2.0\",\n\t\t\t\"karma-chrome-launcher\": \"^2.0\",\n\t\t\t\"karma-firefox-launcher\": \"^1.0\",\n\t\t\t\"karma-ie-launcher\": \"^1.0\",\n\t\t\t\"karma-jasmine\": \"^1.0\",\n\t\t\t\"karma-opera-launcher\": \"^1.0\",\n\t\t\t\"karma-safari-launcher\": \"^1.0\",\n\t\t\t\"locate-java-home\": \"^0.1.6\",\n\t\t\t\"semver\": \"^5.1.0\",\n\t\t\t\"source-map-loader\": \"^0.1.5\",\n\t\t\t\"typescript\": \"^1.8.10\",\n\t\t\t\"uglify-js\": \"^2.7.3\",\n\t\t\t\"underscore\": \"^1.8.3\",\n\t\t\t\"webpack\": \"^1.13.1\",\n\t\t\t\"webpack-dev-server\": \"^1.14.1\"\n\t\t},\n\t\t\"scripts\": {\n\t\t\t\"test\": \"grunt test\",\n\t\t\t\"prepublish\": \"node ./prepublish.js\",\n\t\t\t\"install\": \"node ./install.js\",\n\t\t\t\"appveyor-test\": \"grunt --stack test-browser-appveyor\"\n\t\t},\n\t\t\"repository\": {\n\t\t\t\"type\": \"git\",\n\t\t\t\"url\": \"http://github.com/plasma-umass/doppio.git\"\n\t\t},\n\t\t\"bin\": {\n\t\t\t\"doppio\": \"./bin/doppio\",\n\t\t\t\"doppioh\": \"./bin/doppioh\",\n\t\t\t\"doppio-dev\": \"./bin/doppio-dev\",\n\t\t\t\"doppio-fast-dev\": \"./bin/doppio-fast-dev\"\n\t\t}\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t\"use strict\";function text_diff(a,b,c){return new SequenceMatcher(a,b).text_diff(c)}function __ntuplecomp(a,b){for(var c=Math.max(a.length,b.length),d=0;d<c;d++){if(a[d]<b[d])return-1;if(a[d]>b[d])return 1}return a.length==b.length?0:a.length<b.length?-1:1}function __dictget(a,b,c){return a.hasOwnProperty(b)?a[b]:c}exports.text_diff=text_diff;var SequenceMatcher=function(){function a(a,b){this.a=a,this.b=b,this.b2j={};for(var c=0;c<b.length;c++){var d=b[c];this.b2j.hasOwnProperty(d)?this.b2j[d].push(c):this.b2j[d]=[c]}}return a.prototype.find_longest_match=function(a,b,c,d){for(var e=this.a,f=this.b,g=this.b2j,h=a,i=c,j=0,k={},l=a;l<b;l++){var m={},n=__dictget(g,e[l],[]);for(var o in n)if(n.hasOwnProperty(o)){var p=n[o];if(p<c)continue;if(p>=d)break;var q=__dictget(k,p-1,0)+1;m[p]=q,q>j&&(h=l-q+1,i=p-q+1,j=q)}k=m}for(;h>a&&i>c&&e[h-1]==f[i-1];)h--,i--,j++;for(;h+j<b&&i+j<d&&e[h+j]==f[i+j];)j++;return[h,i,j]},a.prototype.get_matching_blocks=function(){if(null!=this.matching_blocks)return this.matching_blocks;for(var a=this.a.length,b=this.b.length,c=[[0,a,0,b]],d=[];c.length;){var e=c.pop(),f=e[0],g=e[1],h=e[2],i=e[3],j=this.find_longest_match(f,g,h,i),k=j[0],l=j[1],m=j[2];m&&(d.push(j),f<k&&h<l&&c.push([f,k,h,l]),k+m<g&&l+m<i&&c.push([k+m,g,l+m,i]))}d.sort(__ntuplecomp);for(var n=0,o=0,p=0,q=[],r=0;r<d.length;r++){var s=d[r],t=s[0],u=s[1],v=s[2];n+p==t&&o+p==u?p+=v:(p&&q.push([n,o,p]),n=t,o=u,p=v)}return p&&q.push([n,o,p]),q.push([a,b,0]),this.matching_blocks=q,this.matching_blocks},a.prototype.get_opcodes=function(){if(null!=this.opcodes)return this.opcodes;var a=0,b=0,c=[];this.opcodes=c;for(var d=this.get_matching_blocks(),e=0;e<d.length;e++){var f=d[e],g=f[0],h=f[1],i=f[2],j=\"\";a<g&&b<h?j=\"replace\":a<g?j=\"delete\":b<h&&(j=\"insert\"),j&&c.push([j,a,g,b,h]),a=g+i,b=h+i,i&&c.push([\"equal\",g,a,h,b])}return c},a.prototype.text_diff=function(a){for(var b=this.get_opcodes(),c=[],d=[],e=[],f=0,g=-1,h=0;h<b.length;h++){var i=b[h];if(\"equal\"!==i[0]){var j=i[1],k=i[3],l=i[2]-1,m=i[4]-1,n=Math.min(j,k),o=Math.max(l,m),p=\"\";switch(i[0]){case\"delete\":p=\" < \";break;case\"insert\":p=\" > \";break;case\"replace\":p=\" | \"}for(var q=Math.max(g+1,n-a);q<n;q++){var r=q+\": \";q<this.a.length?(d.push(r+this.a[q]),f=Math.max(f,this.a[q].length+r.length)):d.push(r),q<this.b.length?e.push(this.b[q]):e.push(\"\"),c.push(\"   \")}for(var q=n;q<=o;q++){var r=q+\": \";q>=j&&q<=l?(d.push(r+this.a[q]),f=Math.max(f,this.a[q].length+r.length)):d.push(r),q>=k&&q<=m?e.push(this.b[q]):e.push(\"\"),c.push(p)}g=o}}for(var q=0;q<c.length;q++){var s=d[q],t=e[q];s.length<f&&(s+=new Array(f-s.length+1).join(\" \")),c[q]=s+c[q]+t}return c},a}();exports.SequenceMatcher=SequenceMatcher;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var JVM=__webpack_require__(5);exports.JVM=JVM;var CLI=__webpack_require__(48);exports.CLI=CLI;var ClassFile=__webpack_require__(50);exports.ClassFile=ClassFile;var Threading=__webpack_require__(14);exports.Threading=Threading;var Long=__webpack_require__(8);exports.Long=Long;var Util=__webpack_require__(7);exports.Util=Util;var Enums=__webpack_require__(9);exports.Enums=Enums;var Interfaces=__webpack_require__(51);exports.Interfaces=Interfaces;var Monitor=__webpack_require__(25);exports.Monitor=Monitor;var fd_state_1=__webpack_require__(52);exports.FDState=fd_state_1[\"default\"];\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\"use strict\";function java(a,b,c,d){void 0===d&&(d=function(a){});var e,f=parser.parse(a),g=f[\"default\"],h=f.X;if(b.properties=g.mapOption(\"D\"),g.flag(\"help\",!1))return printHelp(b.launcherName,parser.help(\"default\"),c,0);if(g.flag(\"X\",!1))return printNonStandardHelp(b.launcherName,parser.help(\"X\"),c,0);var i=h.stringOption(\"log\",\"ERROR\");if(b.intMode=h.flag(\"int\",!1),b.dumpJITStats=h.flag(\"dump-JIT-stats\",!1),/^[0-9]+$/.test(i))logging.log_level=parseInt(i,10);else{var j=logging[i.toUpperCase()];if(null==j)return process.stderr.write(\"Unrecognized log level: \"+i+\".\"),printHelp(b.launcherName,parser.help(\"default\"),c,1);logging.log_level=j}h.flag(\"list-class-cache\",!1)&&(c=function(a){return function(b){var c=e.getBootstrapClassLoader().getLoadedClassFiles();process.stdout.write(c.join(\"\\n\")+\"\\n\"),a(b)}}(c)),g.flag(\"enablesystemassertions\",!1)&&(b.enableSystemAssertions=!0),g.flag(\"disablesystemassertions\",!1)&&(b.enableSystemAssertions=!1),g.flag(\"enableassertions\",!1)?b.enableAssertions=!0:g.stringOption(\"enableassertions\",null)&&(b.enableAssertions=g.stringOption(\"enableassertions\",null).split(\":\")),g.stringOption(\"disableassertions\",null)&&(b.disableAssertions=g.stringOption(\"disableassertions\",null).split(\":\"));var k=h.stringOption(\"bootclasspath\",null);null!==k&&(b.bootstrapClasspath=k.split(\":\"));var l=h.stringOption(\"bootclasspath/a\",null);l&&(b.bootstrapClasspath=b.bootstrapClasspath.concat(l.split(\":\")));var m=h.stringOption(\"bootclasspath/p\",null);m&&(b.bootstrapClasspath=m.split(\":\").concat(b.bootstrapClasspath)),b.classpath||(b.classpath=[]),g.stringOption(\"jar\",null)?b.classpath.push(g.stringOption(\"jar\",null)):g.stringOption(\"classpath\",null)?b.classpath=b.classpath.concat(g.stringOption(\"classpath\",null).split(\":\")):b.classpath.push(process.cwd());var n=g.stringOption(\"native-classpath\",null);n&&(b.nativeClasspath=b.nativeClasspath.concat(n.split(\":\"))),e=new JVM(b,function(a){a?(process.stderr.write(\"Error constructing JVM:\\n\"),process.stderr.write(a.toString()+\"\\n\"),c(1)):launchJvm(g,b,e,c,d)}),e.setPrintJITCompilation(h.flag(\"X:+PrintCompilation\",!1));var o=h.stringOption(\"vtrace-methods\",null);o&&o.split(\":\").forEach(function(a){return e.vtraceMethod(a)});var p=h.stringOption(\"dump-compiled-code\",null);p&&e.dumpCompiledCode(p)}function launchJvm(a,b,c,d,e){var f=a.unparsedArgs();if(a.stringOption(\"jar\",null))c.runJar(f,d),e(c);else if(f.length>0){var g=f[0];\".class\"===g.slice(-6)&&(g=g.slice(0,-6)),g.indexOf(\".\")!==-1&&(g=util.descriptor2typestr(util.int_classname(g))),c.runClass(g,f.slice(1),d),e(c)}else printHelp(b.launcherName,parser.help(\"default\"),d,0)}function printHelp(a,b,c,d){process.stdout.write(\"Usage: \"+a+\" [-options] class [args...]\\n        (to execute a class)\\nor  \"+a+\" [-options] -jar jarfile [args...]\\n        (to execute a jar file)\\nwhere options include:\\n\"+b),c(d)}function printNonStandardHelp(a,b,c,d){process.stdout.write(b+\"\\n\\nThe -X options are non-standard and subject to change without notice.\\n\"),c(d)}var option_parser_1=__webpack_require__(49),JVM=__webpack_require__(5),util=__webpack_require__(7),logging=__webpack_require__(16),parser=new option_parser_1.OptionParser({default:{classpath:{type:3,alias:\"cp\",optDesc:\" <class search path of directories and zip/jar files>\",desc:\"A : separated list of directories, JAR archives, and ZIP archives to search for class files.\"},D:{type:4,optDesc:\"<name>=<value>\",desc:\"set a system property\"},jar:{type:3,stopParsing:!0},help:{alias:\"?\",desc:\"print this help message\"},X:{desc:\"print help on non-standard options\"},enableassertions:{type:2,optDesc:\"[:<packagename>...|:<classname>]\",alias:\"ea\",desc:\"enable assertions with specified granularity\"},disableassertions:{type:2,optDesc:\"[:<packagename>...|:<classname>]\",alias:\"da\",desc:\"disable assertions with specified granularity\"},enablesystemassertions:{alias:\"esa\",desc:\"enable system assertions\"},disablesystemassertions:{alias:\"dsa\",desc:\"disable system assertions \"}},X:{int:{desc:\"interpreted mode execution only\"},\"dump-JIT-stats\":{desc:\"dump JIT statistics\",enabled:!1},log:{desc:\"log level, [0-10]|vtrace|trace|debug|error\",type:3,enabled:!1},\"vtrace-methods\":{type:3,optDesc:\" <java/lang/Object/getHashCode()I:...>\",desc:\"specify particular methods to vtrace separated by colons\",enabled:!1},\"list-class-cache\":{desc:\"list all of the bootstrap loaded classes after execution\"},\"dump-compiled-code\":{type:3,optDesc:\" <directory>\",desc:\"location to dump compiled object definitions\",enabled:!1},\"native-classpath\":{type:3,optDesc:\" <class search path of directories>\",desc:\"A : separated list of directories to search for native mathods in JS files.\"},\"bootclasspath/a\":{type:1,optDesc:\":<directories and zip/jar files separated by :>\",desc:\"append to end of bootstrap class path\"},\"bootclasspath/p\":{type:1,optDesc:\":<directories and zip/jar files separated by :>\",desc:\"prepend in front of bootstrap class path\"},bootclasspath:{type:1,optDesc:\":<directories and zip/jar files separated by :>\",desc:\"set search path for bootstrap classes and resources\"},\"X:+PrintCompilation\":{desc:\"Print JIT compilation details\",enabled:!1}}});module.exports=java;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t\"use strict\";function getOptName(a,b){return\"default\"!==a?\"\"+a+b:b}function printCol(a,b){for(var c=a,d=b-a.length;d-- >0;)c+=\" \";return c}function _showHelp(a,b){var c={},d=13;return Object.keys(a).forEach(function(d){var e=a[d];if(!e.stopParsing){var f=[d];null!=e.alias&&f.push(e.alias);var g;g=e.optDesc?f.map(function(a){return\"-\"+b+a+e.optDesc}).join(\"\\n\"):f.map(function(a){return\"-\"+b+a}).join(\" | \"),c[g]=e}}),Object.keys(c).map(function(a){var b=c[a];if(b.optDesc){var e=a.split(\"\\n\"),f=e.map(function(a){return\"    \"+a});return f.join(\"\\n\")+\"\\n                  \"+b.desc}var g=printCol(a,d);return g.length===d?\"    \"+g+\" \"+b.desc:\"    \"+g+\"\\n                  \"+b.desc}).join(\"\\n\")+\"\\n\"}var PrefixParseResult=function(){function a(a,b){void 0===b&&(b=[]),this._result=a,this._unparsedArgs=b}return a.prototype.unparsedArgs=function(){return this._unparsedArgs},a.prototype.flag=function(a,b){var c=this._result[a];return\"boolean\"==typeof c?c:b},a.prototype.stringOption=function(a,b){var c=this._result[a];return\"string\"==typeof c?c:b},a.prototype.mapOption=function(a){var b=this._result[a];return\"object\"==typeof b?b:{}},a}();exports.PrefixParseResult=PrefixParseResult;var OptionParser=function(){function a(a){var b=this;this._parseMap={},this._prefixes=[],this._mapArgs=[],this._rawDesc=a,this._prefixes=Object.keys(a),this._prefixes.forEach(function(c){var d=a[c],e=Object.keys(d);e.slice(0).forEach(function(f){var g=d[f];return g.enabled===!1?void delete a[c][f]:(g.type||(g.type=0),4===g.type&&b._mapArgs.push(f),g.prefix=c,g.name=f,b._parseMap[getOptName(c,f)]=g,void(g.alias&&(e.push(g.alias),b._parseMap[getOptName(c,g.alias)]=g)))})})}return a.prototype.parse=function(a){var b,c=this,d={},e=0;for(this._prefixes.forEach(function(a){return d[a]={}}),a=a.map(function(a){return a.trim()}).filter(function(a){return\"\"!==a}),b=a.length;e<b;){var f=a[e];if(\"-\"!==f[0])break;f=f.slice(1);var g;if(g=this._parseMap[f])switch(g.type){case 0:case 2:d[g.prefix][g.name]=!0;break;case 3:case 1:if(e++,!(e<b))throw new Error(\"-\"+f+\" requires an argument.\");d[g.prefix][g.name]=a[e];break;case 4:break;default:throw new Error(\"INTERNAL ERROR: Invalid parse type for -\"+f+\".\")}else if(this._mapArgs.filter(function(a){return f.slice(0,a.length)===a&&(g=c._parseMap[a],!0)}).length>0){var h=f.slice(g.name.length),i=d[g.prefix][g.name];i||(i=d[g.prefix][g.name]={});var j=h.indexOf(\"=\");j!==-1?i[h.slice(0,j)]=h.slice(j+1):i[h]=\"\"}else{if(f.indexOf(\":\")===-1||!(g=this._parseMap[f.slice(0,f.indexOf(\":\"))]))throw new Error(\"Unrecognized option: -\"+f);if(1!==g.type&&2!==g.type)throw new Error(\"Unrecognized option: -\"+f);d[g.prefix][g.name]=f.slice(f.indexOf(\":\")+1)}if(g.stopParsing){e++;break}e++}var k=a.slice(e),l={};return Object.keys(d).forEach(function(a){l[a]=new PrefixParseResult(d[a],k)}),l},a.prototype.help=function(a){return _showHelp(this._rawDesc[a],\"default\"===a?\"\":a)},a}();exports.OptionParser=OptionParser;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";function __export(a){for(var b in a)exports.hasOwnProperty(b)||(exports[b]=a[b])}var ConstantPool=__webpack_require__(23);exports.ConstantPool=ConstantPool;var Attributes=__webpack_require__(12);exports.Attributes=Attributes,__export(__webpack_require__(21)),__export(__webpack_require__(11)),__export(__webpack_require__(20)),__export(__webpack_require__(26));\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t\"use strict\";var FDState=function(){function a(){}return a.open=function(a,b){this._positions[a]=b},a.getPos=function(a){return this._positions[a]},a.incrementPos=function(a,b){this._positions[a]+=b},a.setPos=function(a,b){this._positions[a]=b},a.close=function(a){delete this._positions[a]},a._positions={},a}();exports.__esModule=!0,exports[\"default\"]=FDState;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";var Assert=__webpack_require__(13);exports.Assert=Assert;var Logging=__webpack_require__(16);exports.Logging=Logging;var Difflib=__webpack_require__(46);exports.Difflib=Difflib;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** release/doppio.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap fafc27e5d3632b232e43\n **/","/// <reference path=\"../typings/index.d.ts\" />\n// Main entry point for browserify. Separate from doppiojvm.ts so we can reference\n// main.d.ts here without polluting our official typings.\nimport doppiojvm = require('./doppiojvm');\nexport = doppiojvm;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/index.ts\n **/","/**\n * Top-level doppio interface. Exposed through the `DoppioJVM` global.\n */\nimport * as Testing from './testing';\nimport Heap = require('./heap');\nimport * as VM from './VM';\nimport * as Debug from './Debug';\n\nexport {Testing, VM, Heap, Debug};\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/doppiojvm.ts\n **/","\"use strict\";\nimport JVM = require('./jvm');\nimport util = require('./util');\nimport difflib = require('./difflib');\nimport path = require('path');\nimport fs = require('fs');\nimport interfaces = require('./interfaces');\nimport logging = require('./logging');\n\nexport interface TestingError extends Error {\n  originalError?: any;\n  fatal?: boolean;\n}\n\nfunction makeTestingError(msg: string, origErr?: any, fatal?: boolean): TestingError {\n  var err = <TestingError> new Error(msg);\n  err.originalError = origErr;\n  err.fatal = fatal;\n  return err;\n}\n\n/**\n * Captures stdout/stderr.\n * @todo Do this the proper Node way once BFS is more compliant.\n */\nclass OutputCapturer {\n  private _stdoutWrite = process.stdout.write;\n  private _stderrWrite = process.stderr.write;\n  private _data: string = \"\";\n  private _isCapturing = false;\n\n  private debugWrite(str: string): void {\n    this._stdoutWrite.apply(process.stdout, [str, 'utf8']);\n  }\n\n  /**\n   * Begin capturing output.\n   */\n  public start(clear?: boolean): void {\n    if (this._isCapturing) {\n      throw new Error(`Already capturing.`);\n    }\n    this._isCapturing = true;\n    if (clear) {\n      this._data = \"\";\n    }\n    process.stderr.write = process.stdout.write = (data: any, arg2?: any, arg3?: any): boolean => {\n      if (typeof(data) !== 'string') {\n        // Buffer.\n        data = data.toString();\n      }\n      this._data += data;\n      return true;\n    };\n  }\n\n  /**\n   * Stop capturing output.\n   */\n  public stop(): void {\n    if (!this._isCapturing) {\n      // May be called twice when there's a catastrophic error.\n      return;\n    }\n    this._isCapturing = false;\n    process.stderr.write = this._stderrWrite;\n    process.stdout.write = this._stdoutWrite;\n  }\n\n  /**\n   * Retrieve the captured output.\n   * @param clear Clear the captured output.\n   */\n  public getOutput(clear?: boolean): string {\n    var data = this._data;\n    if (clear) {\n      this._data = \"\";\n    }\n    return data;\n  }\n}\n\n/**\n * Doppio testing options.\n */\nexport interface TestOptions extends interfaces.JVMOptions {\n  /**\n   * Classes to test. Each can be in one of the following forms:\n   * - foo.bar.Baz\n   * - foo/bar/Baz\n   */\n  testClasses?: string[];\n}\n\n/**\n * Represents a single unit test, where we compare Doppio's output to the native\n * JVM.\n */\nexport class DoppioTest {\n  /**\n   * Test runner options.\n   */\n  private opts: TestOptions;\n  /**\n   * The class to test.\n   */\n  public cls: string;\n  /**\n   * Path to the file recording the output from the native JVM.\n   */\n  private outFile: string;\n  /**\n   * The output capturer for this test.\n   */\n  private outputCapturer: OutputCapturer = new OutputCapturer();\n\n  constructor(opts: TestOptions, cls: string) {\n    this.opts = opts;\n    if (cls.indexOf('.') !== -1) {\n      // Convert foo.bar.Baz => foo/bar/Baz\n      cls = util.descriptor2typestr(util.int_classname(cls));\n    }\n    this.cls = cls;\n    this.outFile = path.resolve(opts.doppioHomePath, cls) + \".runout\";\n  }\n\n  /**\n   * Constructs a new JVM for the test.\n   */\n  private constructJVM(cb: (err: any, jvm?: JVM) => void): void {\n    new JVM(<any> util.merge(JVM.getDefaultOptions(this.opts.doppioHomePath), this.opts, {\n      classpath: [this.opts.doppioHomePath],\n      enableAssertions: true,\n      enableSystemAssertions: true\n    }), cb);\n  }\n\n  /**\n   * Runs the unit test.\n   */\n  public run(registerGlobalErrorTrap: (cb: (err: Error) => void) => void, cb: (err: Error, actual?: string, expected?: string, diff?: string) => void) {\n    var outputCapturer = this.outputCapturer, _jvm: JVM = null, terminated: boolean = false, jvmConstructHasFinished: boolean = false,\n      hasFinished: boolean = false;\n    registerGlobalErrorTrap((err) => {\n      if (_jvm) {\n        try {\n          _jvm.halt(1);\n        } catch (e) {\n          err.message += `\\n\\nAdditionally, test runner received the following error while trying to halt the JVM: ${e}${e.stack ? `\\n\\n${e.stack}` : ''}\\n\\nOriginal error's stack trace:`;\n        }\n      }\n      outputCapturer.stop();\n      cb(makeTestingError(`Uncaught error. Aborting further tests.\\n\\t${err}${err.stack ? `\\n\\n${err.stack}` : ``}`, err, true));\n    });\n\n    this.constructJVM((err: any, jvm?: JVM) => {\n      _jvm = jvm;\n      if (terminated) {\n        // Already handled.\n        return;\n      }\n      if (jvmConstructHasFinished) {\n        return cb(makeTestingError(`constructJVM returned twice. Aborting further tests.`, null, true));\n      }\n      jvmConstructHasFinished = true;\n\n      if (err) {\n        cb(makeTestingError(`Could not construct JVM:\\n${err}`, err));\n      } else {\n        outputCapturer.start(true);\n        jvm.runClass(this.cls, [], (status: number) => {\n          if (terminated) {\n            // Already handled.\n            return;\n          }\n          outputCapturer.stop();\n          if(hasFinished) {\n            return cb(makeTestingError(`JVM triggered completion callback twice. Aborting further tests.`, null, true));\n          }\n          hasFinished = true;\n\n          var actual = outputCapturer.getOutput(true);\n          fs.readFile(this.outFile, { encoding: 'utf8' }, (err: any, expected?: string) => {\n            if (err) {\n              cb(makeTestingError(`Could not read runout file:\\n${err}`, err));\n            } else {\n              var diffText = diff(actual, expected), errMsg: string = null;\n              if (diffText !== null) {\n                errMsg = `Output does not match native JVM.`;\n              }\n              cb(errMsg ? makeTestingError(errMsg) : null, actual, expected, diffText);\n            }\n          });\n        });\n      }\n    });\n  }\n}\n\n/**\n * Locate all of Doppio's test classes, and pass them to the callback.\n */\nfunction findTestClasses(doppioDir: string, cb: (files: string[]) => void): void {\n  var testDir = path.resolve(doppioDir, path.join('classes', 'test'));\n  fs.readdir(testDir, (err, files) => {\n    if (err) {\n      cb([]);\n    } else {\n      cb(files.filter((file) => path.extname(file) === '.java')\n              .map((file) => path.join('classes','test', path.basename(file, '.java'))));\n    }\n  });\n}\n\n/**\n * Retrieve all of the unit tests.\n */\nexport function getTests(opts: TestOptions, cb: (tests: DoppioTest[]) => void): void {\n  var testClasses = opts.testClasses,\n    tests: DoppioTest[];\n  if (testClasses == null || testClasses.length === 0) {\n    // If no test classes are specified, get ALL the tests!\n    findTestClasses(opts.doppioHomePath, (testClasses) => {\n      opts.testClasses = testClasses;\n      getTests(opts, cb);\n    });\n  } else {\n    cb(testClasses.map((testClass: string): DoppioTest => {\n      return new DoppioTest(opts, testClass);\n    }));\n  }\n}\n\n/**\n * Returns a formatted diff between doppioOut and nativeOut.\n * Returns NULL if the strings are identical.\n */\nexport function diff(doppioOut: string, nativeOut: string): string {\n  // @todo Robust to Windows line breaks!\n  var doppioLines = doppioOut.split(/\\n/),\n    jvmLines = nativeOut.split(/\\n/),\n    diff: string[] = difflib.text_diff(doppioLines, jvmLines, 2);\n  if (diff.length > 0) {\n    return 'Doppio | Java\\n' + diff.join('\\n');\n  }\n  return null;\n}\n\n/**\n * Run the specified tests.\n */\nexport function runTests(opts: TestOptions, quiet: boolean, continueAfterFailure: boolean, hideDiffs: boolean,\n  registerGlobalErrorTrap: (cb: (err: Error) => void) => void, cb: (err?: TestingError) => void): void {\n  function print(str: string): void {\n    if (!quiet) {\n      process.stdout.write(str);\n    }\n  }\n\n  getTests(opts, (tests) => {\n    util.asyncForEach(tests, (test: DoppioTest, nextTest: (err?: any) => void) => {\n      var hasFinished = false;\n      print(`[${test.cls}]: Running... `);\n      test.run(registerGlobalErrorTrap, (err: TestingError, actual?: string, expected?: string, diff?: string): void => {\n        if (err && !hideDiffs && diff) {\n          err.message += `\\n${diff}`\n        }\n\n        if (err) {\n          print(`fail.\\n\\t${err.message}\\n`);\n          if (err.originalError && err.originalError.stack) {\n            print(`${err.stack}\\n`);\n          }\n          if (!continueAfterFailure || (<TestingError> err)['fatal']) {\n            err.message = `Failed ${test.cls}: ${err.message}`;\n            nextTest(err);\n          } else {\n            nextTest();\n          }\n        } else {\n          print(`pass.\\n`);\n          nextTest();\n        }\n      });\n    }, cb);\n  });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/testing.ts\n **/","var BrowserFS = require('browserfs');module.exports=BrowserFS.BFSRequire('process');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./shims/process.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"BrowserFS\",\"commonjs2\":\"browserfs\",\"commonjs\":\"browserfs\",\"amd\":\"browserfs\"}\n ** module id = 4\n ** module chunks = 0\n **/","\"use strict\";\nimport util = require('./util');\nimport SafeMap = require('./SafeMap');\nimport methods = require('./methods');\nimport {ClassData, ReferenceClassData, ArrayClassData} from './ClassData';\nimport ClassLoader = require('./ClassLoader');\nimport fs = require('fs');\nimport path = require('path');\nimport buffer = require('buffer');\nimport {JVMThread} from './threading';\nimport {ThreadStatus, JVMStatus} from './enums';\nimport Heap = require('./heap');\nimport assert = require('./assert');\nimport interfaces = require('./interfaces');\nimport JVMTypes = require('../includes/JVMTypes');\nimport Parker = require('./parker');\nimport ThreadPool from './threadpool';\nimport logging = require('./logging');\nimport JDKInfo = require('../vendor/java_home/jdk.json');\nimport global = require('./global');\nimport getGlobalRequire from './global_require';\ndeclare var RELEASE: boolean;\nif (typeof RELEASE === 'undefined') global.RELEASE = false;\n\n// Do not import, otherwise TypeScript will prune it.\n// Referenced only in eval'd code.\nlet BrowserFS = require('browserfs');\nlet deflate = require('pako/lib/zlib/deflate');\nlet inflate = require('pako/lib/zlib/inflate');\nlet zstream = require('pako/lib/zlib/zstream');\nlet crc32 = require('pako/lib/zlib/crc32');\nlet adler32 = require('pako/lib/zlib/adler32');\n// For version information.\nlet pkg: any;\nif (util.are_in_browser()) {\n  pkg = require('../package.json');\n} else {\n  pkg = require('../../../package.json');\n}\n\n\n// XXX: We currently initialize these classes at JVM bootup. This is expensive.\n// We should attempt to prune this list as much as possible.\nvar coreClasses = [\n  'Ljava/lang/String;',\n  'Ljava/lang/Class;', 'Ljava/lang/ClassLoader;',\n  'Ljava/lang/reflect/Constructor;', 'Ljava/lang/reflect/Field;',\n  'Ljava/lang/reflect/Method;',\n  'Ljava/lang/Error;', 'Ljava/lang/StackTraceElement;',\n  'Ljava/lang/System;',\n  'Ljava/lang/Thread;',\n  'Ljava/lang/ThreadGroup;',\n  'Ljava/lang/Throwable;',\n  'Ljava/nio/ByteOrder;',\n  'Lsun/misc/VM;', 'Lsun/reflect/ConstantPool;', 'Ljava/lang/Byte;',\n  'Ljava/lang/Character;', 'Ljava/lang/Double;', 'Ljava/lang/Float;',\n  'Ljava/lang/Integer;', 'Ljava/lang/Long;', 'Ljava/lang/Short;',\n  'Ljava/lang/Void;', 'Ljava/io/FileDescriptor;',\n  'Ljava/lang/Boolean;', '[Lsun/management/MemoryManagerImpl;',\n  '[Lsun/management/MemoryPoolImpl;',\n  // Contains important FS constants used by natives. These constants are\n  // inlined into JCL class files, so it typically never gets initialized\n  // implicitly by the JVM.\n  'Lsun/nio/fs/UnixConstants;'\n];\n\n/**\n * Encapsulates a single JVM instance.\n */\nclass JVM {\n  private systemProperties: {[prop: string]: string} = null;\n  private internedStrings: SafeMap<JVMTypes.java_lang_String> = new SafeMap<JVMTypes.java_lang_String>();\n  private bsCl: ClassLoader.BootstrapClassLoader = null;\n  private threadPool: ThreadPool<JVMThread> = null;\n  private natives: { [clsName: string]: { [methSig: string]: Function } } = {};\n  // 20MB heap\n  // @todo Make heap resizeable.\n  private heap: Heap = new Heap(20 * 1024 * 1024);\n  private nativeClasspath: string[] = null;\n  private startupTime: Date = new Date();\n  private terminationCb: (code: number) => void = null;\n  // The initial JVM thread used to kick off execution.\n  private firstThread: JVMThread = null;\n  private responsiveness: number | (() => number) = null;\n  private enableSystemAssertions: boolean = false;\n  private enabledAssertions: boolean | string[] = false;\n  private disabledAssertions: string[] = [];\n  private printJITCompilation: boolean = false;\n  private systemClassLoader: ClassLoader.ClassLoader = null;\n  private nextRef: number = 0;\n  // Set of all of the methods we want vtrace to be enabled on.\n  // DEBUG builds only.\n  private vtraceMethods: {[fullSig: string]: boolean} = {};\n  // [DEBUG] directory to dump compiled code to.\n  private dumpCompiledCodeDir: string = null;\n  // Handles parking/unparking threads.\n  private parker = new Parker();\n  // The current status of the JVM.\n  private status: JVMStatus = JVMStatus.BOOTING;\n  // The JVM's planned exit code.\n  private exitCode: number = 0;\n\n  // is JIT disabled?\n  private jitDisabled: boolean = false;\n  private dumpJITStats: boolean = false;\n\n  // Get the environment's require variable, indirectly.\n  // Hidden from webpack and other builders, as it confuses them.\n  private globalRequire: Function = null;\n\n  public static isReleaseBuild(): boolean {\n    return typeof(RELEASE) !== 'undefined' && RELEASE;\n  }\n\n  /**\n   * (Async) Construct a new instance of the Java Virtual Machine.\n   */\n  constructor(opts: interfaces.JVMOptions, cb: (e: any, jvm?: JVM) => void) {\n    if (typeof(opts.doppioHomePath) !== 'string') {\n      throw new TypeError(\"opts.doppioHomePath *must* be specified.\");\n    }\n    opts = <interfaces.JVMOptions> util.merge(JVM.getDefaultOptions(opts.doppioHomePath), opts);\n\n    this.jitDisabled = opts.intMode;\n    this.dumpJITStats = opts.dumpJITStats;\n\n    var bootstrapClasspath: string[] = opts.bootstrapClasspath.map((p: string): string => path.resolve(p)),\n      // JVM bootup tasks, from first to last task.\n      bootupTasks: {(next: (err?: any) => void): void}[] = [],\n      firstThread: JVMThread,\n      firstThreadObj: JVMTypes.java_lang_Thread;\n\n    // Sanity checks.\n    if (!Array.isArray(opts.bootstrapClasspath) || opts.bootstrapClasspath.length === 0) {\n      throw new TypeError(\"opts.bootstrapClasspath must be specified as an array of file paths.\");\n    }\n    if (!Array.isArray(opts.classpath)) {\n      throw new TypeError(\"opts.classpath must be specified as an array of file paths.\");\n    }\n    if(typeof(opts.javaHomePath) !== 'string') {\n      throw new TypeError(\"opts.javaHomePath must be specified.\");\n    }\n    if (!Array.isArray(opts.nativeClasspath) || opts.nativeClasspath.length === 0) {\n      throw new TypeError(\"opts.nativeClasspath must be specified as an array of file paths.\");\n    }\n\n    this.nativeClasspath = opts.nativeClasspath;\n    if (opts.enableSystemAssertions) {\n      this.enableSystemAssertions = opts.enableSystemAssertions;\n    }\n    if (opts.enableAssertions) {\n      this.enabledAssertions = opts.enableAssertions;\n    }\n    if (opts.disableAssertions) {\n      this.disabledAssertions = opts.disableAssertions;\n    }\n\n    this.responsiveness = opts.responsiveness;\n\n    this._initSystemProperties(bootstrapClasspath,\n      opts.classpath.map((p: string): string => path.resolve(p)),\n      path.resolve(opts.javaHomePath),\n      path.resolve(opts.tmpDir),\n      opts.properties);\n\n    /**\n     * Task #1: Initialize native methods.\n     */\n    bootupTasks.push((next: (err?: any) => void): void => {\n      this.initializeNatives(next);\n    });\n\n    /**\n     * Task #2: Construct the bootstrap class loader.\n     */\n    bootupTasks.push((next: (err?: any) => void): void => {\n      this.bsCl =\n        new ClassLoader.BootstrapClassLoader(this.systemProperties['java.home'], bootstrapClasspath, next);\n    });\n\n    /**\n     * Task #3: Construct the thread pool, resolve thread class, and construct\n     * the first thread.\n     */\n    bootupTasks.push((next: (err?: any) => void): void => {\n      this.threadPool = new ThreadPool<JVMThread>((): boolean => { return this.threadPoolIsEmpty(); });\n      // Resolve Ljava/lang/Thread so we can fake a thread.\n      // NOTE: This should never actually use the Thread object unless\n      // there's an error loading java/lang/Thread and associated classes.\n      this.bsCl.resolveClass(null, 'Ljava/lang/Thread;', (threadCdata: ReferenceClassData<JVMTypes.java_lang_Thread>) => {\n        if (threadCdata == null) {\n          // Failed.\n          next(\"Failed to resolve java/lang/Thread.\");\n        } else {\n          // Construct a thread.\n          firstThreadObj = new (threadCdata.getConstructor(null))(null);\n          firstThreadObj.$thread = firstThread = this.firstThread = new JVMThread(this, this.threadPool, firstThreadObj);\n          firstThreadObj.ref = 1;\n          firstThreadObj['java/lang/Thread/priority'] = 5;\n          firstThreadObj['java/lang/Thread/name'] = util.initCarr(this.bsCl, 'main');\n          firstThreadObj['java/lang/Thread/blockerLock'] = new ((<ReferenceClassData<JVMTypes.java_lang_Object>> this.bsCl.getResolvedClass('Ljava/lang/Object;')).getConstructor(firstThread))(firstThread);\n          next();\n        }\n      });\n    });\n\n    /**\n     * Task #4: Preinitialize some essential JVM classes, and initializes the\n     * JVM's ThreadGroup once that class is initialized.\n     */\n    bootupTasks.push((next: (err?: any) => void): void => {\n      util.asyncForEach<string>(coreClasses, (coreClass: string, nextItem: (err?: any) => void) => {\n        this.bsCl.initializeClass(firstThread, coreClass, (cdata: ClassData) => {\n          if (cdata == null) {\n            nextItem(`Failed to initialize ${coreClass}`);\n          } else {\n            // One of the later preinitialized classes references Thread.group.\n            // Initialize the system's ThreadGroup now.\n            if (coreClass === 'Ljava/lang/ThreadGroup;') {\n              // Construct a ThreadGroup object for the first thread.\n              var threadGroupCons = (<ReferenceClassData<JVMTypes.java_lang_ThreadGroup>> cdata).getConstructor(firstThread),\n                groupObj = new threadGroupCons(firstThread);\n              groupObj['<init>()V'](firstThread, null, (e?: JVMTypes.java_lang_Throwable) => {\n                // Tell the initial thread to use this group.\n                firstThreadObj['java/lang/Thread/group'] = groupObj;\n                nextItem(e);\n              });\n            } else {\n              nextItem();\n            }\n          }\n        });\n      }, next);\n    });\n\n    /**\n     * Task #5: Initialize the system class.\n     */\n    bootupTasks.push((next: (err?: any) => void): void => {\n      // Initialize the system class (initializes things like println/etc).\n      var sysInit = <typeof JVMTypes.java_lang_System> (<ReferenceClassData<JVMTypes.java_lang_System>> this.bsCl.getInitializedClass(firstThread, 'Ljava/lang/System;')).getConstructor(firstThread);\n      sysInit['java/lang/System/initializeSystemClass()V'](firstThread, null, next);;\n    });\n\n    /**\n     * Task #6: Initialize the application's classloader.\n     */\n    bootupTasks.push((next: (err?: any) => void) => {\n      var clCons = <typeof JVMTypes.java_lang_ClassLoader> (<ReferenceClassData<JVMTypes.java_lang_ClassLoader>> this.bsCl.getInitializedClass(firstThread, 'Ljava/lang/ClassLoader;')).getConstructor(firstThread);\n      clCons['java/lang/ClassLoader/getSystemClassLoader()Ljava/lang/ClassLoader;'](firstThread, null, (e?: JVMTypes.java_lang_Throwable, rv?: JVMTypes.java_lang_ClassLoader) => {\n        if (e) {\n          next(e);\n        } else {\n          this.systemClassLoader = rv.$loader;\n          firstThreadObj['java/lang/Thread/contextClassLoader'] = rv;\n\n          // Initialize assertion data.\n          // TODO: Is there a better way to force this? :|\n          let defaultAssertionStatus = this.enabledAssertions === true ? 1 : 0;\n          rv['java/lang/ClassLoader/setDefaultAssertionStatus(Z)V'](firstThread, [defaultAssertionStatus], next);\n        }\n      });\n    });\n\n    /**\n     * Task #7: Initialize DoppioJVM's security provider for things like cryptographically strong RNG.\n     */\n    bootupTasks.push((next: (err?: any) => void) => {\n      this.bsCl.initializeClass(firstThread, 'Ldoppio/security/DoppioProvider;', (cdata) => {\n        next(cdata ? null : new Error(`Failed to initialize DoppioProvider.`));\n      });\n    });\n\n    // Perform bootup tasks, and then trigger the callback function.\n    util.asyncSeries(bootupTasks, (err?: any): void => {\n      // XXX: Without setImmediate, the firstThread won't clear out the stack\n      // frame that triggered us, and the firstThread won't transition to a\n      // 'terminated' status.\n      setImmediate(() => {\n        if (err) {\n          this.status = JVMStatus.TERMINATED;\n          cb(err);\n        } else {\n          this.status = JVMStatus.BOOTED;\n          cb(null, this);\n        }\n      });\n    });\n  }\n\n  public getResponsiveness():number {\n    const resp = this.responsiveness;\n    if (typeof resp === 'number') {\n      return resp;\n    } else if (typeof resp === 'function') {\n      return resp();\n    }\n  }\n\n  public static getDefaultOptions(doppioHome: string): interfaces.JVMOptions {\n    let javaHome = path.join(doppioHome, 'vendor', 'java_home');\n    return {\n      doppioHomePath: doppioHome,\n      classpath: ['.'],\n      bootstrapClasspath: JDKInfo.classpath.map((item) => path.join(javaHome, item)),\n      javaHomePath: javaHome,\n      nativeClasspath: [path.join(doppioHome, 'natives')],\n      enableSystemAssertions: false,\n      enableAssertions: false,\n      disableAssertions: null,\n      properties: {},\n      tmpDir: '/tmp',\n      responsiveness: 1000,\n      intMode: false,\n      dumpJITStats: false\n    };\n  }\n\n  /**\n   * Get the URL to the version of the JDK that DoppioJVM was compiled with.\n   */\n  public static getCompiledJDKURL(): string {\n    return JDKInfo.url;\n  }\n\n  /**\n   * Get the JDK information that DoppioJVM was compiled against.\n   */\n  public static getJDKInfo(): any {\n    return JDKInfo;\n  }\n\n  public getSystemClassLoader(): ClassLoader.ClassLoader {\n    return this.systemClassLoader;\n  }\n\n  /**\n   * Get the next \"ref\" number for JVM objects.\n   */\n  public getNextRef(): number {\n    return this.nextRef++;\n  }\n\n  /**\n   * Retrieve the JVM's parker. Handles parking/unparking threads.\n   */\n  public getParker(): Parker {\n    return this.parker;\n  }\n\n  /**\n   * Run the specified class on this JVM instance.\n   * @param className The name of the class to run. Can be specified in either\n   *   foo.bar.Baz or foo/bar/Baz format.\n   * @param args Command line arguments passed to the class.\n   * @param cb Called when the JVM finishes executing. Called with 'true' if\n   *   the JVM exited normally, 'false' if there was an error.\n   */\n  public runClass(className: string, args: string[], cb: (code: number) => void): void {\n    if (this.status !== JVMStatus.BOOTED) {\n      switch (this.status) {\n        case JVMStatus.BOOTING:\n          throw new Error(`JVM is currently booting up. Please wait for it to call the bootup callback, which you passed to the constructor.`);\n        case JVMStatus.RUNNING:\n          throw new Error(`JVM is already running.`);\n        case JVMStatus.TERMINATED:\n          throw new Error(`This JVM has already terminated. Please create a new JVM.`);\n        case JVMStatus.TERMINATING:\n          throw new Error(`This JVM is currently terminating. You should create a new JVM for each class you wish to run.`);\n      }\n    }\n    this.terminationCb = cb;\n\n    var thread = this.firstThread;\n    assert(thread != null, `Thread isn't created yet?`);\n    // Convert foo.bar.Baz => Lfoo/bar/Baz;\n    className = util.int_classname(className);\n\n    // Initialize the class.\n    this.systemClassLoader.initializeClass(thread, className, (cdata: ReferenceClassData<any>) => {\n      // If cdata is null, there was an error that ended execution.\n      if (cdata != null) {\n        // Convert the arguments.\n        var strArrCons = (<ArrayClassData<JVMTypes.java_lang_String>> this.bsCl.getInitializedClass(thread, '[Ljava/lang/String;')).getConstructor(thread),\n          jvmifiedArgs = new strArrCons(thread, args.length), i: number;\n\n        for (i = 0; i < args.length; i++) {\n          jvmifiedArgs.array[i] = util.initString(this.bsCl, args[i]);\n        }\n\n        // Find the main method, and run it.\n        this.status = JVMStatus.RUNNING;\n        var cdataStatics = <any> cdata.getConstructor(thread);\n        if (cdataStatics['main([Ljava/lang/String;)V']) {\n          cdataStatics['main([Ljava/lang/String;)V'](thread, [jvmifiedArgs]);\n        } else {\n          thread.throwNewException(\"Ljava/lang/NoSuchMethodError;\", `Could not find main method in class ${cdata.getExternalName()}.`);\n        }\n      } else {\n        process.stdout.write(`Error: Could not find or load main class ${util.ext_classname(className)}\\n`);\n        // Erroneous exit.\n        this.terminationCb(1);\n      }\n    });\n  }\n\n  /**\n   * Returns 'true' if confined to interpreter mode\n   */\n  public isJITDisabled(): boolean {\n    return this.jitDisabled;\n  }\n\n  /**\n   * [DEBUG] Returns 'true' if the specified method should be vtraced.\n   */\n  public shouldVtrace(sig: string): boolean {\n    return this.vtraceMethods[sig] === true;\n  }\n\n  /**\n   * [DEBUG] Specify a method to vtrace.\n   */\n  public vtraceMethod(sig: string): void {\n    this.vtraceMethods[sig] = true;\n  }\n\n  /**\n   * Run the specified JAR file on this JVM instance.\n   * @param args Command line arguments passed to the class.\n   * @param cb Called when the JVM finishes executing. Called with 'true' if\n   *   the JVM exited normally, 'false' if there was an error.\n   */\n  public runJar(args: string[], cb: (code: number) => void): void {\n    this.runClass('doppio.JarLauncher', args, cb);\n  }\n\n  /**\n   * Called when the ThreadPool is empty.\n   */\n  private threadPoolIsEmpty(): boolean {\n    var systemClass: ReferenceClassData<JVMTypes.java_lang_System>,\n      systemCons: typeof JVMTypes.java_lang_System;\n    switch (this.status) {\n      case JVMStatus.BOOTING:\n        // Ignore empty thread pools during boot process.\n        return false;\n      case JVMStatus.BOOTED:\n        assert(false, `Thread pool should not become empty after JVM is booted, but before it begins to run.`);\n        return false;\n      case JVMStatus.RUNNING:\n        this.status = JVMStatus.TERMINATING;\n        systemClass = <any> this.bsCl.getInitializedClass(this.firstThread, 'Ljava/lang/System;');\n        assert(systemClass !== null, `Invariant failure: System class must be initialized when JVM is in RUNNING state.`);\n        systemCons = <any> systemClass.getConstructor(this.firstThread);\n        // This is a normal, non-erroneous exit. When this function completes, threadPoolIsEmpty() will be invoked again.\n        systemCons['java/lang/System/exit(I)V'](this.firstThread, [0]);\n        return false;\n      case JVMStatus.TERMINATED:\n        assert(false, `Invariant failure: Thread pool cannot be emptied post-JVM termination.`);\n        return false;\n      case JVMStatus.TERMINATING:\n\n        if (!RELEASE && this.dumpJITStats) {\n          methods.dumpStats();\n        }\n\n        this.status = JVMStatus.TERMINATED;\n        if (this.terminationCb) {\n          this.terminationCb(this.exitCode);\n        }\n        this.firstThread.close();\n        return true;\n    }\n  }\n\n  /**\n   * Check if the JVM has started running the main class.\n   */\n  public hasVMBooted(): boolean {\n    return !(this.status === JVMStatus.BOOTING || this.status === JVMStatus.BOOTED);\n  }\n\n  /**\n   * Completely halt the JVM.\n   */\n  public halt(status: number): void {\n    this.exitCode = status;\n    this.status = JVMStatus.TERMINATING;\n    this.threadPool.getThreads().forEach((t) => {\n      t.setStatus(ThreadStatus.TERMINATED);\n    });\n  }\n\n  /**\n   * Retrieve the given system property.\n   */\n  public getSystemProperty(prop: string): string {\n    return this.systemProperties[prop];\n  }\n\n  /**\n   * Retrieve an array of all of the system property names.\n   */\n  public getSystemPropertyNames(): string[] {\n    return Object.keys(this.systemProperties);\n  }\n\n  /**\n   * Retrieve the unmanaged heap.\n   */\n  public getHeap(): Heap {\n    return this.heap;\n  }\n\n  /**\n   * Interns the given JavaScript string. Returns the interned string.\n   */\n  public internString(str: string, javaObj?: JVMTypes.java_lang_String): JVMTypes.java_lang_String {\n    if (this.internedStrings.has(str)) {\n      return this.internedStrings.get(str);\n    } else {\n      if (!javaObj) {\n        javaObj = util.initString(this.bsCl, str);\n      }\n      this.internedStrings.set(str, javaObj);\n      return javaObj;\n    }\n  }\n\n  /**\n   * Evaluate native modules. Emulates CommonJS functionality.\n   */\n  private evalNativeModule(mod: string): any {\n    \"use strict\"; // Prevent eval from being terrible.\n    if (!this.globalRequire) {\n      this.globalRequire = getGlobalRequire();\n    }\n    var rv: any;\n    /**\n     * Called by the native method file. Registers the package's native\n     * methods with the JVM.\n     */\n    function registerNatives(defs: any): void {\n      rv = defs;\n    }\n    // Provide the natives with the Doppio API, if needed.\n    const DoppioJVM = require('./doppiojvm'),\n      globalRequire = this.globalRequire;\n\n    /**\n     * An emulation of CommonJS require() for the modules.\n     */\n    function moduleRequire(name: string): any {\n      switch(name) {\n        case 'doppiojvm':\n        case '../doppiojvm':\n          return DoppioJVM;\n        case 'fs':\n          return fs;\n        case 'path':\n          return path;\n        case 'buffer':\n          return buffer;\n        case 'browserfs':\n          return BrowserFS;\n        case 'pako/lib/zlib/zstream':\n          return zstream;\n        case 'pako/lib/zlib/inflate':\n          return inflate;\n        case 'pako/lib/zlib/deflate':\n          return deflate;\n        case 'pako/lib/zlib/crc32':\n          return crc32;\n        case 'pako/lib/zlib/adler32':\n          return adler32;\n        case 'crypto':\n          return util.are_in_browser() ? null : globalRequire('crypto');\n        default:\n          return globalRequire(name);\n      }\n    }\n    /**\n     * Emulate AMD module 'define' function for natives compiled as AMD modules.\n     */\n    function moduleDefine(resources: string[], module: Function): void {\n      let args: any[] = [];\n      resources.forEach(function(resource) {\n        switch (resource) {\n          case 'require':\n            args.push(moduleRequire);\n            break;\n          case 'exports':\n            args.push({});\n            break;\n          default:\n            args.push(moduleRequire(resource));\n            break;\n        }\n      });\n      module.apply(null, args);\n    }\n\n    const modFcn = new Function(\"require\", \"define\", \"registerNatives\", \"process\", \"DoppioJVM\", \"Buffer\", mod);\n    modFcn(moduleRequire, moduleDefine, registerNatives, process, DoppioJVM, Buffer);\n    return rv;\n  }\n\n  /**\n   * Register native methods with the virtual machine.\n   */\n  public registerNatives(newNatives: { [clsName: string]: { [methSig: string]: Function } }): void {\n    var clsName: string, methSig: string;\n    for (clsName in newNatives) {\n      if (newNatives.hasOwnProperty(clsName)) {\n        if (!this.natives.hasOwnProperty(clsName)) {\n          this.natives[clsName] = {};\n        }\n        var clsMethods = newNatives[clsName];\n        for (methSig in clsMethods) {\n          if (clsMethods.hasOwnProperty(methSig)) {\n            // Don't check if it exists already. This allows us to overwrite\n            // native methods dynamically at runtime.\n            this.natives[clsName][methSig] = clsMethods[methSig];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convenience function. Register a single native method with the virtual\n   * machine. Can be used to update existing native methods based on runtime\n   * information.\n   */\n  public registerNative(clsName: string, methSig: string, native: Function): void {\n    this.registerNatives({ clsName: { methSig: native } });\n  }\n\n  /**\n   * Retrieve the native method for the given method of the given class.\n   * Returns null if none found.\n   */\n  public getNative(clsName: string, methSig: string): Function {\n    clsName = util.descriptor2typestr(clsName);\n    if (this.natives.hasOwnProperty(clsName)) {\n      var clsMethods = this.natives[clsName];\n      if (clsMethods.hasOwnProperty(methSig)) {\n        return clsMethods[methSig];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * !!DO NOT MUTATE THE RETURNED VALUE!!\n   * Used by the find_invalid_natives tool.\n   */\n  public getNatives(): { [clsName: string]: { [methSig: string]: Function } } {\n    return this.natives;\n  }\n\n  /**\n   * Loads in all of the native method modules prior to execution.\n   * Currently a hack around our classloader.\n   * @todo Make neater with util.async stuff.\n   */\n  private initializeNatives(doneCb: () => void): void {\n    var nextDir = () => {\n      if (i === this.nativeClasspath.length) {\n        // Next phase: Load up the files.\n        var count: number = processFiles.length;\n        processFiles.forEach((file: string) => {\n          fs.readFile(file, (err: any, data: NodeBuffer) => {\n            if (!err) {\n              this.registerNatives(this.evalNativeModule(data.toString()));\n            }\n            if (--count === 0) {\n              doneCb();\n            }\n          });\n        });\n      } else {\n        var dir = this.nativeClasspath[i++];\n        fs.readdir(dir, (err: any, files: string[]) => {\n          if (err) {\n            return doneCb();\n          }\n\n          var j: number, file: string;\n          for (j = 0; j < files.length; j++) {\n            file = files[j];\n            if (file.substring(file.length - 3, file.length) === '.js') {\n              processFiles.push(path.join(dir, file));\n            }\n          }\n          nextDir();\n        });\n      }\n    }, i: number = 0, processFiles: string[] = [];\n\n    nextDir();\n  }\n\n  /**\n   * [Private] Same as reset_system_properties, but called by the constructor.\n   */\n  private _initSystemProperties(bootstrapClasspath: string[], javaClassPath: string[], javaHomePath: string, tmpDir: string, opts: {[name: string]: string}): void {\n    this.systemProperties = util.merge({\n      'java.class.path': javaClassPath.join(':'),\n      'java.home': javaHomePath,\n      'java.ext.dirs': path.join(javaHomePath, 'lib', 'ext'),\n      'java.io.tmpdir': tmpDir,\n      'sun.boot.class.path': bootstrapClasspath.join(':'),\n      'file.encoding': 'UTF-8',\n      'java.vendor': 'Doppio',\n      'java.version': '1.8',\n      'java.vendor.url': 'https://github.com/plasma-umass/doppio',\n      'java.class.version': '52.0',\n      'java.specification.version': '1.8',\n      'line.separator': '\\n',\n      'file.separator': path.sep,\n      'path.separator': ':',\n      'user.dir': path.resolve('.'),\n      'user.home': '.',\n      'user.name': 'DoppioUser',\n      'os.name': 'doppio',\n      'os.arch': 'js',\n      'os.version': '0',\n      'java.vm.name': 'DoppioJVM 32-bit VM',\n      'java.vm.version': pkg.version,\n      'java.vm.vendor': 'PLASMA@UMass',\n      'java.awt.headless': (util.are_in_browser()).toString(), // true if we're using the console frontend\n      'java.awt.graphicsenv': 'classes.awt.CanvasGraphicsEnvironment',\n      'jline.terminal': 'jline.UnsupportedTerminal', // we can't shell out to `stty`,\n      'sun.arch.data.model': '32', // Identify as 32-bit, because that's how we act.\n      'sun.jnu.encoding': \"UTF-8\" // Determines how Java parses command line options.\n    }, opts);\n  }\n\n  /**\n   * Retrieves the bootstrap class loader.\n   */\n  public getBootstrapClassLoader(): ClassLoader.BootstrapClassLoader {\n    return this.bsCl;\n  }\n\n  public getStartupTime(): Date {\n    return this.startupTime;\n  }\n\n  /**\n   * Returns `true` if system assertions are enabled, false otherwise.\n   */\n  public areSystemAssertionsEnabled(): boolean {\n    return this.enableSystemAssertions;\n  }\n\n  /**\n   * Get a listing of classes with assertions enabled. Can also return 'true' or 'false.\n   */\n  public getEnabledAssertions(): string[] | boolean {\n    return this.enabledAssertions;\n  }\n\n  /**\n   * Get a listing of classes with assertions disabled.\n   */\n  public getDisabledAssertions(): string[] {\n    return this.disabledAssertions;\n  }\n\n  public setPrintJITCompilation(enabledOrNot: boolean) {\n    this.printJITCompilation = enabledOrNot;\n  }\n\n  public shouldPrintJITCompilation(): boolean {\n    return this.printJITCompilation;\n  }\n\n  /**\n   * Specifies a directory to dump compiled code to.\n   */\n  public dumpCompiledCode(dir: string): void {\n    this.dumpCompiledCodeDir = dir;\n  }\n\n  public shouldDumpCompiledCode(): boolean {\n    return this.dumpCompiledCodeDir !== null;\n  }\n\n  public dumpObjectDefinition(cls: ClassData, evalText: string): void {\n    if (this.shouldDumpCompiledCode()) {\n      fs.writeFile(path.resolve(this.dumpCompiledCodeDir, cls.getExternalName() + \".js\"), evalText, () => {});\n    }\n  }\n\n  public dumpBridgeMethod(methodSig: string, evalText: string): void {\n    if (this.shouldDumpCompiledCode()) {\n      fs.appendFile(path.resolve(this.dumpCompiledCodeDir, \"vmtarget_bridge_methods.dump\"), `${methodSig}:\\n${evalText}\\n\\n`, () => {});\n    }\n  }\n\n  public dumpCompiledMethod(methodSig: string, pc: number, code: string): void {\n    if (this.shouldDumpCompiledCode()) {\n      fs.appendFile(path.resolve(this.dumpCompiledCodeDir, 'JIT_compiled_methods.dump'), `${methodSig}:${pc}:\\n${code}\\n\\n`, () => {});\n    }\n  }\n\n  /**\n   * Asynchronously dumps JVM state to a file. Currently limited to thread\n   * state.\n   */\n  public dumpState(filename: string, cb: (er: any) => void): void {\n    fs.appendFile(filename, this.threadPool.getThreads().map((t: JVMThread) => `Thread ${t.getRef()}:\\n` + t.getPrintableStackTrace()).join(\"\\n\\n\"), cb);\n  }\n}\n\nexport = JVM;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/jvm.ts\n **/","var BrowserFS = require('browserfs');module.exports=BrowserFS.BFSRequire('buffer').Buffer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./shims/BFSBuffer.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\nimport gLong = require('./gLong');\nimport threading = require('./threading');\nimport enums = require('./enums');\nimport JVMTypes = require('../includes/JVMTypes');\nimport BrowserFS = require('browserfs');\n\n// For type information\nimport ClassLoader = require('./ClassLoader');\nimport ClassData = require('./ClassData');\n\nlet BFSUtils = BrowserFS.BFSRequire('bfs_utils');\n\n/**\n * util contains stateless utility functions that are used around Doppio's\n * codebase.\n * TODO: Separate general JS utility methods from JVM utility methods.\n */\n\n/**\n * Merges object literals together into a new object. Emulates underscore's merge function.\n */\nexport function merge(...literals: {[prop: string]: any}[]): {[prop: string]: any} {\n  var newObject: {[prop: string]: any} = {};\n  literals.forEach((literal) => {\n    Object.keys(literal).forEach((key) => {\n      newObject[key] = literal[key];\n    });\n  });\n  return newObject;\n}\n\nexport function are_in_browser(): boolean {\n  return process.platform === 'browser';\n}\n\nexport var typedArraysSupported: boolean = typeof ArrayBuffer !== \"undefined\";\n\n/**\n * Converts JVM internal names into JS-safe names. Only for use with reference\n * types.\n * Ljava/lang/Object; => java_lang_Object\n * Lfoo/Bar_baz; => foo_Bar__baz\n *\n * Is NOT meant to be unambiguous!\n *\n * Also handles the special characters described here:\n * https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm\n */\nexport function jvmName2JSName(jvmName: string): string {\n  switch (jvmName[0]) {\n    case 'L':\n      return jvmName.slice(1, jvmName.length - 1).replace(/_/g, '__')\n        // Remove / replace characters that are invalid for JS symbols.\n        .replace(/[\\/.;$<>\\[\\]:\\\\=^-]/g, '_');\n    case '[':\n      return `ARR_${jvmName2JSName(jvmName.slice(1))}`;\n    default:\n      return jvmName;\n  }\n}\n\n/**\n * Re-escapes JVM names for eval'd code. Otherwise, JavaScript removes the escapes.\n */\nexport function reescapeJVMName(jvmName: string): string {\n  return jvmName.replace(/\\\\/g, '\\\\\\\\');\n}\n\n/**\n * Applies an async function to each element of a list, in order.\n */\nexport function asyncForEach<T>(\n      lst: Array<T>,\n      fn: (elem: T, next_item: (err?: any) => void) => void,\n      done_cb: (err?: any) => void\n  ): void {\n  var i = -1;\n  function processItem(err?: any): void {\n    if (err) {\n      done_cb(err);\n    } else {\n      i++;\n      if (i < lst.length) {\n        fn(lst[i], processItem);\n      } else {\n        done_cb();\n      }\n    }\n  }\n  processItem();\n}\n\n/**\n * Runs the specified tasks in series.\n */\nexport function asyncSeries(tasks: {(next: (err?: any) => void): void}[], doneCb: (err?: any) => void) {\n  var i = -1;\n  function processItem(err?: any): void {\n    if (err) {\n      doneCb(err);\n    } else {\n      i++;\n      if (i < tasks.length) {\n        tasks[i](processItem);\n      } else {\n        doneCb();\n      }\n    }\n  }\n  processItem();\n}\n\n/**\n * Applies the function to each element of the list in order in series.\n * The first element that returns success halts the process, and triggers\n * done_cb. If no elements return success, done_cb is triggered with no\n * arguments.\n *\n * I wrote this specifically for classloading, but it may have uses elsewhere.\n */\nexport function asyncFind<T>(\n    lst: Array<T>,\n    fn: (elem: T, nextItem: (success: boolean) => void) => void,\n    done_cb: (elem?: T) => void\n  ): void {\n  var i = -1;\n  function processItem(success: boolean): void {\n    if (success) {\n      done_cb(lst[i]);\n    } else {\n      i++;\n      if (i < lst.length) {\n        fn(lst[i], processItem);\n      } else {\n        done_cb();\n      }\n    }\n  }\n  processItem(false);\n}\n\nif (!(<any> Math)['imul']) {\n  (<any> Math)['imul'] = function(a: number, b: number) {\n    // polyfill from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/imul\n    var ah = (a >>> 16) & 0xffff;\n    var al = a & 0xffff;\n    var bh = (b >>> 16) & 0xffff;\n    var bl = b & 0xffff;\n    // the shift by 0 fixes the sign on the high part\n    // the final |0 converts the unsigned value into a signed value\n    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n  };\n}\n\nif (!(<any> Math)['expm1']) {\n  (<any> Math)['expm1'] = function(x: number): number {\n    if (Math.abs(x) < 1e-5) {\n      return x + 0.5*x*x;\n    } else {\n      return Math.exp(x) - 1.0;\n    }\n  };\n}\n\nif (!(<any> Math)['sinh']){\n  (<any> Math)['sinh'] = function(a: number): number {\n    var exp = Math.exp(a);\n    return (exp - 1 / exp) / 2;\n  }\n}\n\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (searchElement, fromIndex?) {\n    if (this == null) {\n      throw new TypeError();\n    }\n    var t = Object(this);\n    var len = t.length >>> 0;\n\n    if (len === 0) {\n      return -1;\n    }\n    var n = 0;\n    if (fromIndex !== undefined) {\n      n = Number(fromIndex);\n      if (n != n) { // shortcut for verifying if it's NaN\n        n = 0;\n      } else if (n != 0 && n != Infinity && n != -Infinity) {\n        n = ((n > 0 ? 1 : 0) || -1) * Math.floor(Math.abs(n));\n      }\n    }\n    if (n >= len) {\n      return -1;\n    }\n    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n    for (; k < len; k++) {\n      if (k in t && t[k] === searchElement) {\n        return k;\n      }\n    }\n    return -1;\n  };\n}\n\n/**\n * Checks if accessingCls has permission to a field or method with the given\n * flags on owningCls.\n *\n * Modifier    | Class | Package | Subclass | World\n * ————————————+———————+—————————+——————————+———————\n * public      |  y    |    y    |    y     |   y\n * ————————————+———————+—————————+——————————+———————\n * protected   |  y    |    y    |    y     |   n\n * ————————————+———————+—————————+——————————+———————\n * no modifier |  y    |    y    |    n     |   n\n * ————————————+———————+—————————+——————————+———————\n * private     |  y    |    n    |    n     |   n\n *\n * y: accessible\n * n: not accessible\n */\nexport function checkAccess(accessingCls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, owningCls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, accessFlags: Flags): boolean {\n  if (accessFlags.isPublic()) {\n    return true;\n  } else if (accessFlags.isProtected()) {\n    return accessingCls.getPackageName() === owningCls.getPackageName() || accessingCls.isSubclass(owningCls);\n  } else if (accessFlags.isPrivate()) {\n    return accessingCls === owningCls;\n  } else {\n    return accessingCls.getPackageName() === owningCls.getPackageName();\n  }\n}\n\n/**\n * Truncates a floating point into an integer.\n */\nexport function float2int(a: number): number {\n  if (a > enums.Constants.INT_MAX) {\n    return enums.Constants.INT_MAX;\n  } else if (a < enums.Constants.INT_MIN) {\n    return enums.Constants.INT_MIN;\n  } else {\n    return a | 0;\n  }\n}\n\nvar supportsArrayBuffers = typeof(ArrayBuffer) !== 'undefined';\n\n/**\n * Converts a byte array to a buffer. **Copies.**\n */\nexport function byteArray2Buffer(bytes: number[] | Int8Array, offset: number = 0, len: number = bytes.length): NodeBuffer {\n  if (supportsArrayBuffers && ArrayBuffer.isView(bytes)) {\n    let offset = (<Int8Array> bytes).byteOffset;\n    return new Buffer(<any> (<Int8Array> bytes).buffer.slice(offset, offset + bytes.length));\n  } else {\n    var buff = new Buffer(len), i: number;\n    for (i = 0; i < len; i++) {\n      buff.writeInt8(bytes[offset + i], i);\n    }\n    return buff;\n  }\n}\n\nexport interface Arrayish {\n  [idx: number]: number;\n}\n\nexport function isUint8Array(arr: Arrayish): arr is Uint8Array {\n  if (arr && typeof(Uint8Array) !== \"undefined\" && arr instanceof Uint8Array) {\n    return true;\n  }\n  return false;\n}\n\nexport function isInt8Array(arr: Arrayish): arr is Int8Array {\n  if (arr && typeof(Int8Array) !== \"undefined\" && arr instanceof Int8Array) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Converts an Int8Array or an array of 8-bit signed ints into\n * a Uint8Array or an array of 8-bit unsigned ints.\n */\nexport function i82u8(arr: number[] | Int8Array, start: number, len: number): number[] | Uint8Array {\n  if (isInt8Array(arr)) {\n    return new Uint8Array(arr.buffer, arr.byteOffset + start, len);\n  } else if (Array.isArray(arr)) {\n    if (typeof(Uint8Array) !== \"undefined\") {\n      var i8arr = new Int8Array(len);\n      if (start === 0 && len === arr.length) {\n        i8arr.set(arr, 0);\n      } else {\n        i8arr.set(arr.slice(start, start + len), 0);\n      }\n      return new Uint8Array(i8arr.buffer);\n    } else {\n      // Slow way.\n      let rv = new Array<number>(len);\n      for (let i = 0; i < len; i++) {\n        rv[i] = arr[start + i] & 0xFF;\n      }\n      return rv;\n    }\n  } else {\n    throw new TypeError(`Invalid array.`);\n  }\n}\n\n/**\n * Converts an Uint8Array or an array of 8-bit unsigned ints into\n * an Int8Array or an array of 8-bit signed ints.\n */\nexport function u82i8(arr: number[] | Uint8Array, start: number, len: number): number[] | Int8Array {\n  if (isUint8Array(arr)) {\n    return new Int8Array(arr.buffer, arr.byteOffset + start, len);\n  } else if (Array.isArray(arr)) {\n    if (typeof(Int8Array) !== \"undefined\") {\n      var u8arr = new Uint8Array(len);\n      if (start === 0 && len === arr.length) {\n        u8arr.set(arr, 0);\n      } else {\n        u8arr.set(arr.slice(start, start + len), 0);\n      }\n      return new Int8Array(u8arr.buffer);\n    } else {\n      // Slow way.\n      let rv = new Array<number>(len);\n      for (let i = 0; i < len; i++) {\n        rv[i] = arr[start + i];\n        if (rv[i] > 127) {\n          // Sign extend.\n          rv[i] |= 0xFFFFFF80\n        }\n      }\n      return rv;\n    }\n  } else {\n    throw new TypeError(`Invalid array.`);\n  }\n}\n\n/**\n * Converts a buffer into either an Int8Array, or an array of signed 8-bit ints.\n */\nexport function buff2i8(buff: NodeBuffer): Int8Array | number[] {\n  let arrayish = BFSUtils.buffer2Arrayish(buff);\n  return u82i8(<any> arrayish, 0, arrayish.length);\n}\n\n// Call this ONLY on the result of two non-NaN numbers.\nexport function wrapFloat(a: number): number {\n  if (a > 3.40282346638528860e+38) {\n    return Number.POSITIVE_INFINITY;\n  }\n  if (0 < a && a < 1.40129846432481707e-45) {\n    return 0;\n  }\n  if (a < -3.40282346638528860e+38) {\n    return Number.NEGATIVE_INFINITY;\n  }\n  if (0 > a && a > -1.40129846432481707e-45) {\n    return 0;\n  }\n  return a;\n}\n\n// Convert :count chars starting from :offset in a Java character array into a JS string\nexport function chars2jsStr(jvmCarr: JVMTypes.JVMArray<number>, offset: number = 0, count: number = jvmCarr.array.length): string {\n  var i : number, carrArray = jvmCarr.array, rv = \"\", endOffset = offset + count;\n  for (i = offset; i < endOffset; i++) {\n    rv += String.fromCharCode(carrArray[i]);\n  }\n  return rv;\n}\n\n// TODO: Is this used anywhere where we are *not* inserting the bytestr into\n// a JVMArray object?\n// TODO: Could inject this as a static String method...\nexport function bytestr2Array(byteStr: string): number[] {\n  var rv : number[] = [];\n  for (var i = 0; i < byteStr.length; i++) {\n    rv.push(byteStr.charCodeAt(i));\n  }\n  return rv;\n}\n\nexport function array2bytestr(byteArray: number[]): string {\n  // XXX: We'd like to use String.fromCharCode(bytecode_array...)\n  //  but that fails on Webkit with arrays longer than 2^31. See issue #129 for details.\n  var rv = '';\n  for (var i = 0; i < byteArray.length; i++) {\n    rv += String.fromCharCode(byteArray[i]);\n  }\n  return rv;\n}\n\n/**\n * Bit masks for the flag byte.\n */\nexport enum FlagMasks {\n  PUBLIC = 0x1,\n  PRIVATE = 0x2,\n  PROTECTED = 0x4,\n  STATIC = 0x8,\n  FINAL = 0x10,\n  SYNCHRONIZED = 0x20,\n  SUPER = 0x20,\n  VOLATILE = 0x40,\n  TRANSIENT = 0x80,\n  VARARGS = 0x80,\n  NATIVE = 0x100,\n  INTERFACE = 0x200,\n  ABSTRACT = 0x400,\n  STRICT = 0x800\n}\n\n/**\n * Represents a 'flag byte'. See �4 of the JVM spec.\n * @todo Separate METHOD flags and CLASS flags.\n */\nexport class Flags {\n  private byte: number;\n  constructor(byte: number) {\n    this.byte = byte;\n  }\n\n  public isPublic(): boolean {\n    return (this.byte & FlagMasks.PUBLIC) > 0;\n  }\n\n  public isPrivate(): boolean {\n    return (this.byte & FlagMasks.PRIVATE) > 0;\n  }\n\n  public isProtected(): boolean {\n    return (this.byte & FlagMasks.PROTECTED) > 0;\n  }\n\n  public isStatic(): boolean {\n    return (this.byte & FlagMasks.STATIC) > 0;\n  }\n\n  public isFinal(): boolean {\n    return (this.byte & FlagMasks.FINAL) > 0;\n  }\n\n  public isSynchronized(): boolean {\n    return (this.byte & FlagMasks.SYNCHRONIZED) > 0;\n  }\n\n  public isSuper(): boolean {\n    return (this.byte & FlagMasks.SUPER) > 0;\n  }\n\n  public isVolatile(): boolean {\n    return (this.byte & FlagMasks.VOLATILE) > 0;\n  }\n\n  public isTransient(): boolean {\n    return (this.byte & FlagMasks.TRANSIENT) > 0;\n  }\n\n  public isNative(): boolean {\n    return (this.byte & FlagMasks.NATIVE) > 0;\n  }\n\n  public isInterface(): boolean {\n    return (this.byte & FlagMasks.INTERFACE) > 0;\n  }\n\n  public isAbstract(): boolean {\n    return (this.byte & FlagMasks.ABSTRACT) > 0;\n  }\n\n  public isStrict(): boolean {\n    return (this.byte & FlagMasks.STRICT) > 0;\n  }\n\n  /**\n   * Changes a function to native. Used for trapped methods.\n   */\n  public setNative(n: boolean): void {\n    if (n) {\n      this.byte = this.byte | FlagMasks.NATIVE;\n    } else {\n      this.byte = this.byte & (~FlagMasks.NATIVE);\n    }\n  }\n\n  public isVarArgs(): boolean {\n    return (this.byte & FlagMasks.VARARGS) > 0;\n  }\n\n  public getRawByte(): number {\n    return this.byte;\n  }\n}\n\nexport function initialValue(type_str: string): any {\n  if (type_str === 'J') return gLong.ZERO;\n  var c = type_str[0];\n  if (c === '[' || c === 'L') return null;\n  return 0;\n}\n\n/**\n * Java classes are represented internally using slashes as delimiters.\n * These helper functions convert between the two representations.\n * Ljava/lang/Class; => java.lang.Class\n */\nexport function ext_classname(str: string): string {\n  return descriptor2typestr(str).replace(/\\//g, '.');\n}\n\n/**\n * java.lang.Class => Ljava/lang/Class;\n */\nexport function int_classname(str: string): string {\n  return typestr2descriptor(str.replace(/\\./g, '/'));\n}\n\nexport function verify_int_classname(str: string): boolean {\n  var array_nesting = str.match(/^\\[*/)[0].length;\n  if (array_nesting > 255) {\n    return false;\n  }\n  if (array_nesting > 0) {\n    str = str.slice(array_nesting);\n  }\n  if (str[0] === 'L') {\n    if (str[str.length - 1] !== ';') {\n      return false;\n    }\n    str = str.slice(1, -1);\n  }\n  if (str in internal2external) {\n    return true;\n  }\n  if (str.match(/\\/{2,}/)) {\n    return false;\n  }\n  var parts = str.split('/');\n  for (var i = 0; i < parts.length; i++) {\n    if (parts[i].match(/[^$_a-z0-9]/i)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport var internal2external: { [internalType: string]: string } = {\n  B: 'byte',\n  C: 'char',\n  D: 'double',\n  F: 'float',\n  I: 'int',\n  J: 'long',\n  S: 'short',\n  V: 'void',\n  Z: 'boolean'\n};\n\nexport var external2internal: { [externalType: string]: string } = {};\nfor (var k in internal2external) {\n  external2internal[internal2external[k]] = k;\n}\n\n/**\n * Given a method descriptor, returns the typestrings for the return type\n * and the parameters.\n *\n * e.g. (Ljava/lang/Class;Z)Ljava/lang/String; =>\n *        [\"Ljava/lang/Class;\", \"Z\", \"Ljava/lang/String;\"]\n */\nexport function getTypes(methodDescriptor: string): string[] {\n  var i = 0, types: string[] = [], endIdx: number;\n  for (i = 0; i < methodDescriptor.length; i++) {\n    switch (methodDescriptor.charAt(i)) {\n      case '(':\n      case ')':\n        //Skip.\n        break;\n      case 'L':\n        // Reference type.\n        endIdx = methodDescriptor.indexOf(';', i);\n        types.push(methodDescriptor.slice(i, endIdx + 1));\n        i = endIdx;\n        break;\n      case '[':\n        endIdx = i + 1;\n        // Find the start of the component.\n        while (methodDescriptor.charAt(endIdx) === '[') {\n          endIdx++;\n        }\n        if (methodDescriptor.charAt(endIdx) === 'L') {\n          // Reference component. Read ahead to end.\n          endIdx = methodDescriptor.indexOf(';', endIdx);\n          types.push(methodDescriptor.slice(i, endIdx + 1));\n        } else {\n          // Primitive component.\n          types.push(methodDescriptor.slice(i, endIdx + 1));\n        }\n        i = endIdx;\n        break;\n      default:\n        // Primitive type.\n        types.push(methodDescriptor.charAt(i));\n        break;\n    }\n  }\n  return types;\n}\n\n// Get the component type of an array type string.\n// Cut off the [L and ; for arrays of classes.\nexport function get_component_type(type_str: string): string {\n  return type_str.slice(1);\n}\n\nexport function is_array_type(type_str: string): boolean {\n  return type_str[0] === '[';\n}\n\nexport function is_primitive_type(type_str: string): boolean {\n  return type_str in internal2external;\n}\n\nexport function is_reference_type(type_str: string): boolean {\n  return type_str[0] === 'L';\n}\n\n/**\n * Converts type descriptors into standardized internal type strings.\n * Ljava/lang/Class; => java/lang/Class   Reference types\n * [Ljava/lang/Class; is unchanged        Array types\n * C => char                              Primitive types\n */\nexport function descriptor2typestr(type_str: string): string {\n  var c = type_str[0];\n  if (c in internal2external) return internal2external[c];\n  if (c === 'L') return type_str.slice(1, -1);\n  if (c === '[') return type_str;\n  // no match\n  throw new Error(\"Unrecognized type string: \" + type_str);\n}\n\n// Takes a character array of concatenated type descriptors and returns/removes the first one.\nexport function carr2descriptor(carr: string[]): string {\n  var c = carr.shift();\n  if (c == null) return null;\n  if (internal2external[c] !== void 0) return c;\n  if (c === 'L') {\n    var rv = 'L';\n    while ((c = carr.shift()) !== ';') {\n      rv += c;\n    }\n    return rv + ';';\n  }\n  if (c === '[') return \"[\" + carr2descriptor(carr);\n  // no match\n  carr.unshift(c);\n  throw new Error(\"Unrecognized descriptor: \" + carr.join(''));\n}\n\n// Converts internal type strings into type descriptors. Reverse of descriptor2typestr.\nexport function typestr2descriptor(type_str: string): string {\n  if (external2internal[type_str] !== void 0) {\n    return external2internal[type_str];\n  } else if (type_str[0] === '[') {\n    return type_str;\n  } else {\n    return \"L\" + type_str + \";\";\n  }\n}\n\n/**\n * Java's reflection APIs need to unbox primitive arguments to function calls,\n * as they are boxed in an Object array. This utility function converts\n * an array of arguments into the appropriate form prior to function invocation.\n * Note that this includes padding category 2 primitives, which consume two\n * slots in the array (doubles/longs).\n */\nexport function unboxArguments(thread: threading.JVMThread, paramTypes: string[], args: JVMTypes.java_lang_Object[]): any[] {\n  var rv: any[] = [], i: number, type: string, arg: JVMTypes.java_lang_Object;\n  for (i = 0; i < paramTypes.length; i++) {\n    type = paramTypes[i];\n    arg = args[i];\n    if (is_primitive_type(type)) {\n      // Unbox the primitive type.\n      // TODO: Precisely type this better. Once TypeScript lets you import\n      // union types, we can define a \"JVMPrimitive\" type...\n      rv.push((<JVMTypes.java_lang_Integer> arg).unbox());\n      if (type === 'J' || type === 'D') {\n        // 64-bit primitives take up two argument slots. Doppio uses a NULL for the second slot.\n        rv.push(null);\n      }\n    } else {\n      // Reference type; do not change.\n      rv.push(arg);\n    }\n  }\n  return rv;\n}\n\n/**\n * Given a method descriptor as a JS string, returns a corresponding MethodType\n * object.\n */\nexport function createMethodType(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, descriptor: string, cb: (e: JVMTypes.java_lang_Throwable, type: JVMTypes.java_lang_invoke_MethodType) => void) {\n  cl.initializeClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;', (cdata: ClassData.ReferenceClassData<JVMTypes.java_lang_invoke_MethodHandleNatives>) => {\n    if (cdata !== null) {\n      var jsCons = <typeof JVMTypes.java_lang_invoke_MethodHandleNatives> cdata.getConstructor(thread), classes = getTypes(descriptor);\n      classes.push('[Ljava/lang/Class;');\n      // Need the return type and parameter types.\n      cl.resolveClasses(thread, classes, (classMap: { [name: string]: ClassData.ClassData }) => {\n        var types = classes.map((cls: string) => classMap[cls].getClassObject(thread));\n        types.pop(); // Discard '[Ljava/lang/Class;'\n        var rtype = types.pop(), // Return type.\n          clsArrCons = (<ClassData.ArrayClassData<JVMTypes.java_lang_Class>> classMap['[Ljava/lang/Class;']).getConstructor(thread),\n          ptypes = new clsArrCons(thread, types.length);\n        ptypes.array = types;\n\n        jsCons['java/lang/invoke/MethodHandleNatives/findMethodHandleType(Ljava/lang/Class;[Ljava/lang/Class;)Ljava/lang/invoke/MethodType;'](thread, [rtype, ptypes], cb);\n      });\n    }\n  });\n}\n\n/**\n * Given a method descriptor, returns the number of words required to store\n * its arguments.\n * Does not include considerations for e.g. the 'this' argument, since the\n * descriptor does not specify if the method is static or not.\n */\nexport function getMethodDescriptorWordSize(descriptor: string): number {\n  var parsedDescriptor = getTypes(descriptor),\n    words = parsedDescriptor.length - 1, i: number, p: string;\n  // Remove return type.\n  parsedDescriptor.pop();\n\n  // Double count doubles / longs.\n  for (i = 0; i < parsedDescriptor.length; i++) {\n    p = parsedDescriptor[i];\n    if (p === 'D' || p === 'J') {\n      words++;\n    }\n  }\n\n  return words;\n}\n\n/**\n * Given a return type as a Class object, and an array of class objects for\n * parameter types, returns the descriptor string for the method type.\n */\nexport function getDescriptorString(rtype: JVMTypes.java_lang_Class, ptypes?: JVMTypes.JVMArray<JVMTypes.java_lang_Class>): string {\n  var rv = \"(\";\n  if (ptypes !== undefined && ptypes !== null) {\n    ptypes.array.forEach((ptype: JVMTypes.java_lang_Class) => {\n      rv += ptype.$cls.getInternalName();\n    });\n  }\n  rv += \")\" + rtype.$cls.getInternalName();\n  return rv;\n}\n\n\n/**\n * Have a JavaClassLoaderObject and need its ClassLoader object? Use this method!\n * @todo Install on Java ClassLoader objects.\n */\nexport function getLoader(thread: threading.JVMThread, jclo: JVMTypes.java_lang_ClassLoader): ClassLoader.ClassLoader {\n  if ((jclo != null) && (jclo.$loader != null)) {\n    return jclo.$loader;\n  }\n  return thread.getBsCl();\n}\n\n/**\n * \"Fast\" array copy; does not have to check every element for illegal\n * assignments. You can do tricks here (if possible) to copy chunks of the array\n * at a time rather than element-by-element.\n * This function *cannot* access any attribute other than 'array' on src due to\n * the special case when src == dest (see code for System.arraycopy below).\n */\nexport function arraycopyNoCheck(src: JVMTypes.JVMArray<any>, srcPos: number, dest: JVMTypes.JVMArray<any>, destPos: number, length: number): void {\n  var j = destPos;\n  var end = srcPos + length;\n  for (var i = srcPos; i < end; i++) {\n    dest.array[j++] = src.array[i];\n  }\n}\n\n/**\n * \"Slow\" array copy; has to check every element for illegal assignments.\n * You cannot do any tricks here; you must copy element by element until you\n * have either copied everything, or encountered an element that cannot be\n * assigned (which causes an exception).\n * Guarantees: src and dest are two different reference types. They cannot be\n *             primitive arrays.\n */\nexport function arraycopyCheck(thread: threading.JVMThread, src: JVMTypes.JVMArray<JVMTypes.java_lang_Object>, srcPos: number, dest: JVMTypes.JVMArray<JVMTypes.java_lang_Object>, destPos: number, length: number): void {\n  var j = destPos;\n  var end = srcPos + length;\n  var destCompCls = dest.getClass().getComponentClass();\n  for (var i = srcPos; i < end; i++) {\n    // Check if null or castable.\n    if (src.array[i] === null || src.array[i].getClass().isCastable(destCompCls)) {\n      dest.array[j] = src.array[i];\n    } else {\n      thread.throwNewException('Ljava/lang/ArrayStoreException;', 'Array element in src cannot be cast to dest array type.');\n      return;\n    }\n    j++;\n  }\n}\n\nexport function initString(cl: ClassLoader.ClassLoader, str: string): JVMTypes.java_lang_String {\n  var carr = initCarr(cl, str);\n  var strCons = (<ClassData.ReferenceClassData<JVMTypes.java_lang_String>> cl.getResolvedClass('Ljava/lang/String;')).getConstructor(null);\n  var strObj = new strCons(null);\n  strObj['java/lang/String/value'] = carr;\n  return strObj;\n}\n\nexport function initCarr(cl: ClassLoader.ClassLoader, str: string): JVMTypes.JVMArray<number> {\n  var arrClsCons = (<ClassData.ArrayClassData<number>> cl.getInitializedClass(null, '[C')).getConstructor(null),\n    carr = new arrClsCons(null, str.length),\n    carrArray = carr.array;\n\n  for (var i = 0; i < str.length; i++) {\n    carrArray[i] = str.charCodeAt(i);\n  }\n\n  return carr;\n}\n\nexport function newArrayFromClass<T>(thread: threading.JVMThread, clazz: ClassData.ArrayClassData<T>, length: number): JVMTypes.JVMArray<T> {\n  return new (clazz.getConstructor(thread))(thread, length);\n}\n\nexport function newArray<T>(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, desc: string, length: number): JVMTypes.JVMArray<T> {\n  var cls = <ClassData.ArrayClassData<T>> cl.getInitializedClass(thread, desc);\n  return newArrayFromClass(thread, cls, length);\n}\n\n/**\n * Separate from newArray to avoid programming mistakes where newArray and newArrayFromData are conflated.\n */\nexport function multiNewArray<T>(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, desc: string, lengths: number[]): JVMTypes.JVMArray<T> {\n  var cls = <ClassData.ArrayClassData<T>> cl.getInitializedClass(thread, desc);\n  return new (cls.getConstructor(thread))(thread, lengths);\n}\n\nexport function newObjectFromClass<T extends JVMTypes.java_lang_Object>(thread: threading.JVMThread, clazz: ClassData.ReferenceClassData<T>) {\n  return new (clazz.getConstructor(thread))(thread);\n}\n\nexport function newObject<T extends JVMTypes.java_lang_Object>(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, desc: string): T {\n  var cls = <ClassData.ReferenceClassData<T>> cl.getInitializedClass(thread, desc);\n  return newObjectFromClass(thread, cls);\n}\n\nexport function getStaticFields<T>(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, desc: string): T {\n  return <T> <any> (<ClassData.ReferenceClassData<JVMTypes.java_lang_Object>> cl.getInitializedClass(thread, desc)).getConstructor(thread);\n}\n\nexport function newArrayFromDataWithClass<T>(thread: threading.JVMThread, cls: ClassData.ArrayClassData<T>, data: T[]): JVMTypes.JVMArray<T> {\n  var arr = newArrayFromClass<T>(thread, cls, 0);\n  arr.array = data;\n  return arr;\n}\n\nexport function newArrayFromData<T>(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, desc: string, data: T[]): JVMTypes.JVMArray<T> {\n  var arr = newArray<T>(thread, cl, desc, 0);\n  arr.array = data;\n  return arr;\n}\n\n/**\n * Returns the boxed class name of the given primitive type.\n */\nexport function boxClassName(primType: string): string {\n  switch (primType) {\n    case 'B':\n      return 'Ljava/lang/Byte;';\n    case 'C':\n      return 'Ljava/lang/Character;';\n    case 'D':\n      return 'Ljava/lang/Double;';\n    case 'F':\n      return 'Ljava/lang/Float;';\n    case 'I':\n      return 'Ljava/lang/Integer;';\n    case 'J':\n      return 'Ljava/lang/Long;';\n    case 'S':\n      return 'Ljava/lang/Short;';\n    case 'Z':\n      return 'Ljava/lang/Boolean;';\n    case 'V':\n      return 'Ljava/lang/Void;';\n    default:\n      throw new Error(`Tried to box a non-primitive class: ${this.className}`);\n  }\n}\n\n/**\n * Boxes the given primitive value.\n */\nexport function boxPrimitiveValue(thread: threading.JVMThread, type: string, val: any): JVMTypes.java_lang_Integer {\n  // XXX: We assume Integer for typing purposes only; avoids a huge union type.\n  var primCls = <ClassData.ReferenceClassData<JVMTypes.java_lang_Integer>> thread.getBsCl().getInitializedClass(thread, boxClassName(type)),\n   primClsCons = <typeof JVMTypes.java_lang_Integer> primCls.getConstructor(thread);\n  return primClsCons.box(val);\n}\n\n/**\n * Boxes the given arguments into an Object[].\n *\n * @param descriptor The descriptor at the *call site*.\n * @param data The actual arguments for this function call.\n * @param isStatic If false, disregard the first type in the descriptor, as it is the 'this' argument.\n */\nexport function boxArguments(thread: threading.JVMThread, objArrCls: ClassData.ArrayClassData<JVMTypes.java_lang_Object>, descriptor: string, data: any[], isStatic: boolean, skipArgs: number = 0): JVMTypes.JVMArray<JVMTypes.java_lang_Object> {\n  var paramTypes = getTypes(descriptor),\n    boxedArgs = newArrayFromClass(thread, objArrCls, paramTypes.length - (isStatic ? 1 : 2) - skipArgs),\n    i: number, j: number = 0, boxedArgsArr = boxedArgs.array, type: string;\n\n  // Ignore return value.\n  paramTypes.pop();\n  if (!isStatic) {\n    // Ignore 'this' argument.\n    paramTypes.shift();\n  }\n\n  if (skipArgs > 0) {\n    // Ignore regular arguments\n    paramTypes = paramTypes.slice(skipArgs);\n    data = data.slice(skipArgs);\n  }\n\n  for (i = 0; i < paramTypes.length; i++) {\n    type = paramTypes[i];\n    switch(type[0]) {\n      case '[':\n      case 'L':\n        // Single argument slot, no boxing required.\n        boxedArgsArr[i] = data[j];\n        break;\n      case 'J':\n      case 'D':\n        boxedArgsArr[i] = boxPrimitiveValue(thread, type, data[j]);\n        j++;\n        break;\n      default:\n        boxedArgsArr[i] = boxPrimitiveValue(thread, type, data[j]);\n        break;\n    }\n    j++;\n  }\n\n  return boxedArgs;\n}\n\nexport function forwardResult<T extends JVMTypes.java_lang_Object>(thread: threading.JVMThread): (e?: JVMTypes.java_lang_Throwable, rv?: T) => void {\n  return (e?: JVMTypes.java_lang_Throwable, rv?: T): void => {\n    if (e) {\n      thread.throwException(e);\n    } else {\n      thread.asyncReturn(rv);\n    }\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/util.ts\n **/","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Defines a Long class for representing a 64-bit two's-complement\n * integer value, which faithfully simulates the behavior of a Java \"long\". This\n * implementation is derived from LongLib in GWT.\n *\n */\nclass gLong {\n  private low_ : number\n  private high_ : number\n  // A cache of the Long representations of small integer values.\n  private static IntCache_: { [val: number]: gLong } = {}\n  // Commonly used constant values.\n  private static TWO_PWR_16_DBL_ = 1 << 16;\n  private static TWO_PWR_24_DBL_ = 1 << 24;\n  private static TWO_PWR_32_DBL_ = gLong.TWO_PWR_16_DBL_ * gLong.TWO_PWR_16_DBL_;\n  private static TWO_PWR_31_DBL_ = gLong.TWO_PWR_32_DBL_ / 2;\n  private static TWO_PWR_48_DBL_ = gLong.TWO_PWR_32_DBL_ * gLong.TWO_PWR_16_DBL_;\n  private static TWO_PWR_64_DBL_ = gLong.TWO_PWR_32_DBL_ * gLong.TWO_PWR_32_DBL_;\n  private static TWO_PWR_63_DBL_ = gLong.TWO_PWR_64_DBL_ / 2;\n\n  public static ZERO = gLong.fromInt(0);\n  public static ONE = gLong.fromInt(1);\n  public static NEG_ONE = gLong.fromInt(-1);\n  public static MAX_VALUE = gLong.fromBits(0xFFFFFFFF, 0x7FFFFFFF);\n  public static MIN_VALUE = gLong.fromBits(0, 0x80000000);\n  private static TWO_PWR_24_ = gLong.fromInt(gLong.TWO_PWR_24_DBL_);\n\n  /**\n   * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n   * values as *signed* integers.  See the from* functions below for more\n   * convenient ways of constructing Longs.\n   *\n   * The internal representation of a long is the two given signed, 32-bit values.\n   * We use 32-bit pieces because these are the size of integers on which\n   * Javascript performs bit-operations.  For operations like addition and\n   * multiplication, we split each number into 16-bit pieces, which can easily be\n   * multiplied within Javascript's floating-point representation without overflow\n   * or change in sign.\n   *\n   * In the algorithms below, we frequently reduce the negative case to the\n   * positive case by negating the input(s) and then post-processing the result.\n   * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n   * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n   * a positive number, it overflows back into a negative).  Not handling this\n   * case would often result in infinite recursion.\n   *\n   * @param {number} low  The low (signed) 32 bits of the long.\n   * @param {number} high  The high (signed) 32 bits of the long.\n   * @constructor\n   */\n  constructor(low: number, high: number) {\n    this.low_ = low | 0;  // force into 32 signed bits.\n    this.high_ = high | 0;  // force into 32 signed bits.\n  }\n\n  /**\n   * Returns a Long representing the given (32-bit) integer value.\n   * @param {number} value The 32-bit integer in question.\n   * @return {!gLong} The corresponding Long value.\n   */\n  public static fromInt(value: number): gLong {\n    if (-128 <= value && value < 128) {\n      var cachedObj = gLong.IntCache_[value];\n      if (cachedObj) {\n        return cachedObj;\n      }\n    }\n\n    var obj = new gLong(value, value < 0 ? -1 : 0);\n    if (-128 <= value && value < 128) {\n      gLong.IntCache_[value] = obj;\n    }\n    return obj;\n  }\n\n  /**\n   * Returns a Long representing the given value, provided that it is a finite\n   * number.  Otherwise, zero is returned.\n   * @param {number} value The number in question.\n   * @return {!gLong} The corresponding Long value.\n   */\n  public static fromNumber(value: number): gLong {\n    if (isNaN(value) || !isFinite(value)) {\n      return gLong.ZERO;\n    } else if (value <= -gLong.TWO_PWR_63_DBL_) {\n      return gLong.MIN_VALUE;\n    } else if (value + 1 >= gLong.TWO_PWR_63_DBL_) {\n      return gLong.MAX_VALUE;\n    } else if (value < 0) {\n      return gLong.fromNumber(-value).negate();\n    } else {\n      return new gLong(\n          (value % gLong.TWO_PWR_32_DBL_) | 0,\n          (value / gLong.TWO_PWR_32_DBL_) | 0);\n    }\n  }\n\n  /**\n   * Returns a Long representing the 64-bit integer that comes by concatenating\n   * the given high and low bits.  Each is assumed to use 32 bits.\n   * @param {number} lowBits The low 32-bits.\n   * @param {number} highBits The high 32-bits.\n   * @return {!gLong} The corresponding Long value.\n   */\n  public static fromBits(lowBits: number, highBits: number): gLong {\n    return new gLong(lowBits, highBits);\n  }\n\n  /**\n   * Returns a Long representation of the given string, written using the given\n   * radix.\n   * @param {string} str The textual representation of the Long.\n   * @param {number=} opt_radix The radix in which the text is written.\n   * @return {!gLong} The corresponding Long value.\n   */\n  public static fromString(str: string, opt_radix?: number): gLong {\n    if (str.length == 0) {\n      throw Error('number format error: empty string');\n    }\n\n    var radix = opt_radix || 10;\n    if (radix < 2 || 36 < radix) {\n      throw Error('radix out of range: ' + radix);\n    }\n\n    if (str.charAt(0) == '-') {\n      return gLong.fromString(str.substring(1), radix).negate();\n    } else if (str.indexOf('-') >= 0) {\n      throw Error('number format error: interior \"-\" character: ' + str);\n    }\n\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = gLong.fromNumber(Math.pow(radix, 8));\n\n    var result = gLong.ZERO;\n    for (var i = 0; i < str.length; i += 8) {\n      var size = Math.min(8, str.length - i);\n      var value = parseInt(str.substring(i, i + size), radix);\n      if (size < 8) {\n        var power = gLong.fromNumber(Math.pow(radix, size));\n        result = result.multiply(power).add(gLong.fromNumber(value));\n      } else {\n        result = result.multiply(radixToPower);\n        result = result.add(gLong.fromNumber(value));\n      }\n    }\n    return result;\n  }\n\n  /** @return {number} The value, assuming it is a 32-bit integer. */\n  public toInt(): number {\n    return this.low_;\n  }\n\n  /** @return {number} The closest floating-point representation to this value. */\n  public toNumber(): number {\n    return this.high_ * gLong.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();\n  }\n\n  /**\n   * @param {number=} opt_radix The radix in which the text should be written.\n   * @return {string} The textual representation of this value.\n   */\n  public toString(opt_radix?: number): string {\n    var radix = opt_radix || 10;\n    if (radix < 2 || 36 < radix) {\n      throw Error('radix out of range: ' + radix);\n    }\n\n    if (this.isZero()) {\n      return '0';\n    }\n\n    if (this.isNegative()) {\n      if (this.equals(gLong.MIN_VALUE)) {\n        // We need to change the Long value before it can be negated, so we remove\n        // the bottom-most digit in this base and then recurse to do the rest.\n        var radixLong = gLong.fromNumber(radix);\n        var div = this.div(radixLong);\n        var rem = div.multiply(radixLong).subtract(this);\n        return div.toString(radix) + rem.toInt().toString(radix);\n      } else {\n        return '-' + this.negate().toString(radix);\n      }\n    }\n\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = gLong.fromNumber(Math.pow(radix, 6));\n    var rem: gLong = this;\n    var result = '';\n    while (true) {\n      var remDiv = rem.div(radixToPower);\n      var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n      var digits = intval.toString(radix);\n\n      rem = remDiv;\n      if (rem.isZero()) {\n        return digits + result;\n      } else {\n        while (digits.length < 6) {\n          digits = '0' + digits;\n        }\n        result = '' + digits + result;\n      }\n    }\n  }\n\n  /** @return {number} The high 32-bits as a signed value. */\n  public getHighBits(): number {\n    return this.high_;\n  }\n\n  /** @return {number} The low 32-bits as a signed value. */\n  public getLowBits(): number {\n    return this.low_;\n  }\n\n  /** @return {number} The low 32-bits as an unsigned value. */\n  public getLowBitsUnsigned(): number {\n    return (this.low_ >= 0) ? this.low_ : gLong.TWO_PWR_32_DBL_ + this.low_;\n  }\n\n  /**\n   * @return {number} Returns the number of bits needed to represent the absolute\n   *     value of this Long.\n   */\n  public getNumBitsAbs(): number {\n    if (this.isNegative()) {\n      if (this.equals(gLong.MIN_VALUE)) {\n        return 64;\n      } else {\n        return this.negate().getNumBitsAbs();\n      }\n    } else {\n      var val = this.high_ != 0 ? this.high_ : this.low_;\n      for (var bit = 31; bit > 0; bit--) {\n        if ((val & (1 << bit)) != 0) {\n          break;\n        }\n      }\n      return this.high_ != 0 ? bit + 33 : bit + 1;\n    }\n  }\n\n  /** @return {boolean} Whether this value is zero. */\n  public isZero(): boolean {\n    return this.high_ == 0 && this.low_ == 0;\n  }\n\n  /** @return {boolean} Whether this value is negative. */\n  public isNegative(): boolean {\n    return this.high_ < 0;\n  }\n\n  /** @return {boolean} Whether this value is odd. */\n  public isOdd(): boolean {\n    return (this.low_ & 1) == 1;\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long equals the other.\n   */\n  public equals(other: gLong): boolean {\n    return (this.high_ == other.high_) && (this.low_ == other.low_);\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long does not equal the other.\n   */\n  public notEquals(other: gLong): boolean {\n    return (this.high_ != other.high_) || (this.low_ != other.low_);\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long is less than the other.\n   */\n  public lessThan(other: gLong): boolean {\n    return this.compare(other) < 0;\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long is less than or equal to the other.\n   */\n  public lessThanOrEqual(other: gLong): boolean {\n    return this.compare(other) <= 0;\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long is greater than the other.\n   */\n  public greaterThan(other: gLong): boolean {\n    return this.compare(other) > 0;\n  }\n\n  /**\n   * @param {gLong} other Long to compare against.\n   * @return {boolean} Whether this Long is greater than or equal to the other.\n   */\n  public greaterThanOrEqual(other: gLong): boolean {\n    return this.compare(other) >= 0;\n  }\n\n  /**\n   * Compares this Long with the given one.\n   * @param {gLong} other Long to compare against.\n   * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n   *     if the given one is greater.\n   */\n  public compare(other: gLong): number {\n    if (this.equals(other)) {\n      return 0;\n    }\n\n    var thisNeg = this.isNegative();\n    var otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) {\n      return -1;\n    }\n    if (!thisNeg && otherNeg) {\n      return 1;\n    }\n\n    // at this point, the signs are the same, so subtraction will not overflow\n    if (this.subtract(other).isNegative()) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n\n  /** @return {!gLong} The negation of this value. */\n  public negate(): gLong {\n    if (this.equals(gLong.MIN_VALUE)) {\n      return gLong.MIN_VALUE;\n    } else {\n      return this.not().add(gLong.ONE);\n    }\n  }\n\n  /**\n   * Returns the sum of this and the given Long.\n   * @param {gLong} other Long to add to this one.\n   * @return {!gLong} The sum of this and the given Long.\n   */\n  public add(other: gLong): gLong {\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n    var a48 = this.high_ >>> 16;\n    var a32 = this.high_ & 0xFFFF;\n    var a16 = this.low_ >>> 16;\n    var a00 = this.low_ & 0xFFFF;\n\n    var b48 = other.high_ >>> 16;\n    var b32 = other.high_ & 0xFFFF;\n    var b16 = other.low_ >>> 16;\n    var b00 = other.low_ & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return gLong.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n  }\n\n  /**\n   * Returns the difference of this and the given Long.\n   * @param {gLong} other Long to subtract from this.\n   * @return {!gLong} The difference of this and the given Long.\n   */\n  public subtract(other: gLong): gLong {\n    return this.add(other.negate());\n  }\n\n  /**\n   * Returns the product of this and the given long.\n   * @param {gLong} other Long to multiply with this.\n   * @return {!gLong} The product of this and the other.\n   */\n  public multiply(other: gLong): gLong {\n    if (this.isZero()) {\n      return gLong.ZERO;\n    } else if (other.isZero()) {\n      return gLong.ZERO;\n    }\n\n    if (this.equals(gLong.MIN_VALUE)) {\n      return other.isOdd() ? gLong.MIN_VALUE : gLong.ZERO;\n    } else if (other.equals(gLong.MIN_VALUE)) {\n      return this.isOdd() ? gLong.MIN_VALUE : gLong.ZERO;\n    }\n\n    if (this.isNegative()) {\n      if (other.isNegative()) {\n        return this.negate().multiply(other.negate());\n      } else {\n        return this.negate().multiply(other).negate();\n      }\n    } else if (other.isNegative()) {\n      return this.multiply(other.negate()).negate();\n    }\n\n    // If both longs are small, use float multiplication\n    if (this.lessThan(gLong.TWO_PWR_24_) &&\n        other.lessThan(gLong.TWO_PWR_24_)) {\n      return gLong.fromNumber(this.toNumber() * other.toNumber());\n    }\n\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n\n    var a48 = this.high_ >>> 16;\n    var a32 = this.high_ & 0xFFFF;\n    var a16 = this.low_ >>> 16;\n    var a00 = this.low_ & 0xFFFF;\n\n    var b48 = other.high_ >>> 16;\n    var b32 = other.high_ & 0xFFFF;\n    var b16 = other.low_ >>> 16;\n    var b00 = other.low_ & 0xFFFF;\n\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return gLong.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n  }\n\n  /**\n   * Returns this Long divided by the given one.\n   * @param {gLong} other Long by which to divide.\n   * @return {!gLong} This Long divided by the given one.\n   */\n  public div(other: gLong): gLong {\n    if (other.isZero()) {\n      throw Error('division by zero');\n    } else if (this.isZero()) {\n      return gLong.ZERO;\n    }\n\n    if (this.equals(gLong.MIN_VALUE)) {\n      if (other.equals(gLong.ONE) ||\n          other.equals(gLong.NEG_ONE)) {\n        return gLong.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n      } else if (other.equals(gLong.MIN_VALUE)) {\n        return gLong.ONE;\n      } else {\n        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n        var halfThis = this.shiftRight(1);\n        var l_approx = halfThis.div(other).shiftLeft(1);\n        if (l_approx.equals(gLong.ZERO)) {\n          return other.isNegative() ? gLong.ONE : gLong.NEG_ONE;\n        } else {\n          var rem = this.subtract(other.multiply(l_approx));\n          var result = l_approx.add(rem.div(other));\n          return result;\n        }\n      }\n    } else if (other.equals(gLong.MIN_VALUE)) {\n      return gLong.ZERO;\n    }\n\n    if (this.isNegative()) {\n      if (other.isNegative()) {\n        return this.negate().div(other.negate());\n      } else {\n        return this.negate().div(other).negate();\n      }\n    } else if (other.isNegative()) {\n      return this.div(other.negate()).negate();\n    }\n\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    var res = gLong.ZERO;\n    var rem: gLong = this;\n    while (rem.greaterThanOrEqual(other)) {\n      // Approximate the result of division. This may be a little greater or\n      // smaller than the actual value.\n      var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n      // We will tweak the approximate result by changing it in the 48-th digit or\n      // the smallest non-fractional digit, whichever is larger.\n      var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n      var delta = 1;\n      if (log2 > 48)\n        delta = Math.pow(2, log2 - 48);\n\n      // Decrease the approximation until it is smaller than the remainder.  Note\n      // that if it is too large, the product overflows and is negative.\n      var approxRes = gLong.fromNumber(approx);\n      var approxRem = approxRes.multiply(other);\n      while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n        approx -= delta;\n        approxRes = gLong.fromNumber(approx);\n        approxRem = approxRes.multiply(other);\n      }\n\n      // We know the answer can't be zero... and actually, zero would cause\n      // infinite recursion since we would make no progress.\n      if (approxRes.isZero()) {\n        approxRes = gLong.ONE;\n      }\n\n      res = res.add(approxRes);\n      rem = rem.subtract(approxRem);\n    }\n    return res;\n  }\n\n  /**\n   * Returns this Long modulo the given one.\n   * @param {gLong} other Long by which to mod.\n   * @return {!gLong} This Long modulo the given one.\n   */\n  public modulo(other: gLong): gLong {\n    return this.subtract(this.div(other).multiply(other));\n  }\n\n  /** @return {!gLong} The bitwise-NOT of this value. */\n  public not(): gLong {\n    return gLong.fromBits(~this.low_, ~this.high_);\n  }\n\n  /**\n   * Returns the bitwise-AND of this Long and the given one.\n   * @param {gLong} other The Long with which to AND.\n   * @return {!gLong} The bitwise-AND of this and the other.\n   */\n  public and(other: gLong): gLong {\n    return gLong.fromBits(this.low_ & other.low_,\n                          this.high_ & other.high_);\n  }\n\n  /**\n   * Returns the bitwise-OR of this Long and the given one.\n   * @param {gLong} other The Long with which to OR.\n   * @return {!gLong} The bitwise-OR of this and the other.\n   */\n  public or(other: gLong): gLong {\n    return gLong.fromBits(this.low_ | other.low_,\n                          this.high_ | other.high_);\n  }\n\n  /**\n   * Returns the bitwise-XOR of this Long and the given one.\n   * @param {gLong} other The Long with which to XOR.\n   * @return {!gLong} The bitwise-XOR of this and the other.\n   */\n  public xor(other: gLong): gLong {\n    return gLong.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);\n  }\n\n  /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!gLong} This shifted to the left by the given amount.\n   */\n  public shiftLeft(numBits: number): gLong {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var low = this.low_;\n      if (numBits < 32) {\n        var high = this.high_;\n        return gLong.fromBits(low << numBits,\n                              (high << numBits) | (low >>> (32 - numBits)));\n      } else {\n        return gLong.fromBits(0, low << (numBits - 32));\n      }\n    }\n  }\n\n  /**\n   * Returns this Long with bits shifted to the right by the given amount.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!gLong} This shifted to the right by the given amount.\n   */\n  public shiftRight(numBits: number): gLong {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var high = this.high_;\n      if (numBits < 32) {\n        var low = this.low_;\n        return gLong.fromBits(\n            (low >>> numBits) | (high << (32 - numBits)),\n            high >> numBits);\n      } else {\n        return gLong.fromBits(\n            high >> (numBits - 32),\n            high >= 0 ? 0 : -1);\n      }\n    }\n  }\n\n  /**\n   * Returns this Long with bits shifted to the right by the given amount, with\n   * the new top bits matching the current sign bit.\n   * @param {number} numBits The number of bits by which to shift.\n   * @return {!gLong} This shifted to the right by the given amount, with\n   *     zeros placed into the new leading bits.\n   */\n  public shiftRightUnsigned(numBits: number): gLong {\n    numBits &= 63;\n    if (numBits == 0) {\n      return this;\n    } else {\n      var high = this.high_;\n      if (numBits < 32) {\n        var low = this.low_;\n        return gLong.fromBits(\n            (low >>> numBits) | (high << (32 - numBits)),\n            high >>> numBits);\n      } else if (numBits == 32) {\n        return gLong.fromBits(high, 0);\n      } else {\n        return gLong.fromBits(high >>> (numBits - 32), 0);\n      }\n    }\n  }\n}\n// Export only the class.\nexport = gLong\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/gLong.ts\n **/","\"use strict\";\n\n/**\n * A class can be in one of these states at any given point in time.\n */\nexport enum ClassState {\n  // The class has yet to be loaded.\n  NOT_LOADED,\n  // The class's definition has been downloaded and parsed.\n  LOADED,\n  // This class and its super classes' definitions have been downloaded and\n  // parsed.\n  RESOLVED,\n  // This class, its super classes', and its interfaces have been downloaded,\n  // parsed, and statically initialized.\n  INITIALIZED\n}\n\n/**\n * A thread can be in one of these states at any given point in time.\n *\n * NOTE: When altering ThreadStatus, remember to update the following things.\n *\n * - Thread.validTransitions: Describes each valid thread transition.\n * - sun.misc.VM.getThreadStateValues: Maps ThreadStatus values to Thread.State\n *   values.\n * - Assertion statements in Thread regarding its status.\n */\nexport enum ThreadStatus {\n  // A thread that has not yet started is in this state.\n  NEW,\n  // A thread that is able to be run. The thread may actually be running.\n  // Query the ThreadPool to determine if this is the case.\n  RUNNABLE,\n  // A thread that is blocked waiting for a monitor lock is in this state.\n  BLOCKED,\n  // A thread that is blocked waiting for a monitor lock that was previously\n  // interrupted from waiting on a monitor is in this state.\n  // Why? Well, the thread has *already* been interrupted once, but cannot\n  // process the interruption until it regains the lock.\n  UNINTERRUPTABLY_BLOCKED,\n  // A thread that is waiting indefinitely for another thread to perform a\n  // particular action is in this state.\n  WAITING,\n  // A thread that is waiting for another thread to perform an action for up to\n  // a specified waiting time is in this state.\n  TIMED_WAITING,\n  // A thread that is waiting for an asynchronous browser operation to complete.\n  ASYNC_WAITING,\n  // A thread that is parked.\n  PARKED,\n  // A thread that has exited is in this state.\n  TERMINATED\n}\n\n/**\n * Java-visible thread state values.\n */\nexport enum JVMTIThreadState {\n  ALIVE = 0x0001,\n  TERMINATED = 0x0002,\n  RUNNABLE = 0x0004,\n  BLOCKED_ON_MONITOR_ENTER = 0x0400,\n  WAITING_INDEFINITELY = 0x0010,\n  WAITING_WITH_TIMEOUT = 0x0020\n}\n\n/**\n * Three-state boolean.\n */\nexport enum TriState {\n  TRUE,\n  FALSE,\n  INDETERMINATE\n}\n\n/**\n * The current status of the JVM.\n */\nexport enum JVMStatus {\n  // The JVM is booting up.\n  BOOTING,\n  // The JVM is booted, and waiting for a class to run.\n  BOOTED,\n  // The JVM is running.\n  RUNNING,\n  // The JVM has completed running, and is performing termination steps.\n  TERMINATING,\n  // The JVM is completely finished executing.\n  TERMINATED\n}\n\n/**\n * Indicates the type of a stack frame.\n */\nexport enum StackFrameType {\n  /**\n   * A JVM internal stack frame. These should be completely invisible to the\n   * JVM program.\n   */\n  INTERNAL,\n  /**\n   * A bytecode method's stack frame. These have an actual stack.\n   */\n  BYTECODE,\n  /**\n   * A native method's stack frame. These typically consist of just a JavaScript\n   * function and a method association.\n   */\n  NATIVE\n}\n\n/**\n * Various constant values. Enum'd so they are inlined by the TypeScript\n * compiler.\n */\nexport enum Constants {\n  INT_MAX = Math.pow(2, 31) - 1,\n  INT_MIN = -INT_MAX - 1,\n  FLOAT_POS_INFINITY = Math.pow(2, 128),\n  FLOAT_NEG_INFINITY = -1 * FLOAT_POS_INFINITY,\n  FLOAT_POS_INFINITY_AS_INT = 0x7F800000,\n  FLOAT_NEG_INFINITY_AS_INT = -8388608,\n  // We use the JavaScript NaN as our NaN value, and convert it to\n  // a NaN value in the SNaN range when an int equivalent is requested.\n  FLOAT_NaN_AS_INT = 0x7fc00000\n}\n\n/**\n * Integer indicating the type of a constant pool item.\n * @url https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4-140\n */\nexport enum ConstantPoolItemType {\n  CLASS = 7,\n  FIELDREF = 9,\n  METHODREF = 10,\n  INTERFACE_METHODREF = 11,\n  STRING = 8,\n  INTEGER = 3,\n  FLOAT = 4,\n  LONG = 5,\n  DOUBLE = 6,\n  NAME_AND_TYPE = 12,\n  UTF8 = 1,\n  METHOD_HANDLE = 15,\n  METHOD_TYPE = 16,\n  INVOKE_DYNAMIC = 18\n}\n\n/**\n * Integer indicating the type of a StackMapTable entry.\n * @see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.4\n */\nexport enum StackMapTableEntryType {\n  SAME_FRAME,\n  SAME_LOCALS_1_STACK_ITEM_FRAME,\n  SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED,\n  CHOP_FRAME,\n  SAME_FRAME_EXTENDED,\n  APPEND_FRAME,\n  FULL_FRAME\n}\n\n/**\n * Integer indicating the reference type of a MethodHandle item in the constant\n * pool.\n * @see https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8\n */\nexport enum MethodHandleReferenceKind {\n  GETFIELD = 1,\n  GETSTATIC = 2,\n  PUTFIELD = 3,\n  PUTSTATIC = 4,\n  INVOKEVIRTUAL = 5,\n  INVOKESTATIC = 6,\n  INVOKESPECIAL = 7,\n  NEWINVOKESPECIAL = 8,\n  INVOKEINTERFACE = 9\n}\n\n/**\n * JVM op codes. The enum value corresponds to that opcode's value.\n */\nexport enum OpCode {\n  AALOAD = 0x32,\n  AASTORE = 0x53,\n  ACONST_NULL = 0x01,\n  ALOAD = 0x19,\n  ALOAD_0 = 0x2a,\n  ALOAD_1 = 0x2b,\n  ALOAD_2 = 0x2c,\n  ALOAD_3 = 0x2d,\n  ANEWARRAY = 0xbd,\n  ARETURN = 0xb0,\n  ARRAYLENGTH = 0xbe,\n  ASTORE = 0x3a,\n  ASTORE_0 = 0x4b,\n  ASTORE_1 = 0x4c,\n  ASTORE_2 = 0x4d,\n  ASTORE_3 = 0x4e,\n  ATHROW = 0xbf,\n  BALOAD = 0x33,\n  BASTORE = 0x54,\n  BIPUSH = 0x10,\n  BREAKPOINT = 0xca,\n  CALOAD = 0x34,\n  CASTORE = 0x55,\n  CHECKCAST = 0xc0,\n  D2F = 0x90,\n  D2I = 0x8e,\n  D2L = 0x8f,\n  DADD = 0x63,\n  DALOAD = 0x31,\n  DASTORE = 0x52,\n  DCMPG = 0x98,\n  DCMPL = 0x97,\n  DCONST_0 = 0x0e,\n  DCONST_1 = 0x0f,\n  DDIV = 0x6f,\n  DLOAD = 0x18,\n  DLOAD_0 = 0x26,\n  DLOAD_1 = 0x27,\n  DLOAD_2 = 0x28,\n  DLOAD_3 = 0x29,\n  DMUL = 0x6b,\n  DNEG = 0x77,\n  DREM = 0x73,\n  DRETURN = 0xaf,\n  DSTORE = 0x39,\n  DSTORE_0 = 0x47,\n  DSTORE_1 = 0x48,\n  DSTORE_2 = 0x49,\n  DSTORE_3 = 0x4a,\n  DSUB = 0x67,\n  DUP = 0x59,\n  DUP_X1 = 0x5a,\n  DUP_X2 = 0x5b,\n  DUP2 = 0x5c,\n  DUP2_X1 = 0x5d,\n  DUP2_X2 = 0x5e,\n  F2D = 0x8d,\n  F2I = 0x8b,\n  F2L = 0x8c,\n  FADD = 0x62,\n  FALOAD = 0x30,\n  FASTORE = 0x51,\n  FCMPG = 0x96,\n  FCMPL = 0x95,\n  FCONST_0 = 0x0b,\n  FCONST_1 = 0x0c,\n  FCONST_2 = 0x0d,\n  FDIV = 0x6e,\n  FLOAD = 0x17,\n  FLOAD_0 = 0x22,\n  FLOAD_1 = 0x23,\n  FLOAD_2 = 0x24,\n  FLOAD_3 = 0x25,\n  FMUL = 0x6a,\n  FNEG = 0x76,\n  FREM = 0x72,\n  FRETURN = 0xae,\n  FSTORE = 0x38,\n  FSTORE_0 = 0x43,\n  FSTORE_1 = 0x44,\n  FSTORE_2 = 0x45,\n  FSTORE_3 = 0x46,\n  FSUB = 0x66,\n  GETFIELD = 0xb4,\n  GETSTATIC = 0xb2,\n  GOTO = 0xa7,\n  GOTO_W = 0xc8,\n  I2B = 0x91,\n  I2C = 0x92,\n  I2D = 0x87,\n  I2F = 0x86,\n  I2L = 0x85,\n  I2S = 0x93,\n  IADD  = 0x60,\n  IALOAD = 0x2e,\n  IAND = 0x7e,\n  IASTORE = 0x4f,\n  ICONST_M1 = 0x2,\n  ICONST_0 = 3,\n  ICONST_1 = 4,\n  ICONST_2 = 5,\n  ICONST_3 = 6,\n  ICONST_4 = 7,\n  ICONST_5 = 8,\n  IDIV  = 0x6c,\n  IF_ACMPEQ = 0xa5,\n  IF_ACMPNE = 0xa6,\n  IF_ICMPEQ = 0x9f,\n  IF_ICMPGE = 0xa2,\n  IF_ICMPGT = 0xa3,\n  IF_ICMPLE = 0xa4,\n  IF_ICMPLT = 0xa1,\n  IF_ICMPNE = 0xa0,\n  IFEQ  = 0x99,\n  IFGE  = 0x9c,\n  IFGT  = 0x9d,\n  IFLE  = 0x9e,\n  IFLT  = 0x9b,\n  IFNE  = 0x9a,\n  IFNONNULL = 0xc7,\n  IFNULL = 0xc6,\n  IINC  = 0x84,\n  ILOAD = 0x15,\n  ILOAD_0 = 0x1a,\n  ILOAD_1 = 0x1b,\n  ILOAD_2 = 0x1c,\n  ILOAD_3 = 0x1d,\n  // IMPDEP1 = 0xfe,\n  // IMPDEP2 = 0xff,\n  IMUL  = 0x68,\n  INEG  = 0x74,\n  INSTANCEOF = 0xc1,\n  INVOKEDYNAMIC = 0xba,\n  INVOKEINTERFACE = 0xb9,\n  INVOKESPECIAL = 0xb7,\n  INVOKESTATIC = 0xb8,\n  INVOKEVIRTUAL = 0xb6,\n  IOR   = 0x80,\n  IREM  = 0x70,\n  IRETURN = 0xac,\n  ISHL  = 0x78,\n  ISHR  = 0x7a,\n  ISTORE = 0x36,\n  ISTORE_0 = 0x3b,\n  ISTORE_1 = 0x3c,\n  ISTORE_2 = 0x3d,\n  ISTORE_3 = 0x3e,\n  ISUB = 0x64,\n  IUSHR = 0x7c,\n  IXOR = 0x82,\n  JSR = 0xa8,\n  JSR_W = 0xc9,\n  L2D = 0x8a,\n  L2F = 0x89,\n  L2I = 0x88,\n  LADD = 0x61,\n  LALOAD = 0x2f,\n  LAND = 0x7f,\n  LASTORE = 0x50,\n  LCMP = 0x94,\n  LCONST_0 = 0x09,\n  LCONST_1 = 0x0a,\n  LDC = 0x12,\n  LDC_W = 0x13,\n  LDC2_W = 0x14,\n  LDIV = 0x6d,\n  LLOAD = 0x16,\n  LLOAD_0 = 0x1e,\n  LLOAD_1 = 0x1f,\n  LLOAD_2 = 0x20,\n  LLOAD_3 = 0x21,\n  LMUL = 0x69,\n  LNEG = 0x75,\n  LOOKUPSWITCH = 0xab,\n  LOR = 0x81,\n  LREM = 0x71,\n  LRETURN = 0xad,\n  LSHL = 0x79,\n  LSHR = 0x7b,\n  LSTORE = 0x37,\n  LSTORE_0 = 0x3f,\n  LSTORE_1 = 0x40,\n  LSTORE_2 = 0x41,\n  LSTORE_3 = 0x42,\n  LSUB = 0x65,\n  LUSHR = 0x7d,\n  LXOR = 0x83,\n  MONITORENTER = 0xc2,\n  MONITOREXIT = 0xc3,\n  MULTIANEWARRAY = 0xc5,\n  NEW = 0xbb,\n  NEWARRAY = 0xbc,\n  NOP = 0x00,\n  POP = 0x57,\n  POP2 = 0x58,\n  PUTFIELD = 0xb5,\n  PUTSTATIC = 0xb3,\n  RET = 0xa9,\n  RETURN = 0xb1,\n  SALOAD = 0x35,\n  SASTORE = 0x56,\n  SIPUSH = 0x11,\n  SWAP = 0x5f,\n  TABLESWITCH = 0xaa,\n  WIDE = 0xc4,\n\n  // Special Doppio 'fast' opcodes\n  GETSTATIC_FAST32 = 0xd0,\n  GETSTATIC_FAST64 = 0xd1,\n  NEW_FAST = 0xd2,\n  ANEWARRAY_FAST = 0xd5,\n  CHECKCAST_FAST = 0xd6,\n  INSTANCEOF_FAST = 0xd7,\n  MULTIANEWARRAY_FAST = 0xd8,\n  PUTSTATIC_FAST32 = 0xd9,\n  PUTSTATIC_FAST64 = 0xda,\n  GETFIELD_FAST32 = 0xdb,\n  GETFIELD_FAST64 = 0xdc,\n  PUTFIELD_FAST32 = 0xdd,\n  PUTFIELD_FAST64 = 0xde,\n  INVOKENONVIRTUAL_FAST = 0xdf,\n  INVOKESTATIC_FAST = 0xf0,\n  INVOKEVIRTUAL_FAST = 0xf1,\n  INVOKEINTERFACE_FAST = 0xf2,\n  INVOKEHANDLE = 0xf3,\n  INVOKEBASIC = 0xf4,\n  LINKTOSPECIAL = 0xf5,\n  LINKTOVIRTUAL = 0xf7,\n  INVOKEDYNAMIC_FAST = 0xf8\n}\n\nexport enum OpcodeLayoutType {\n  OPCODE_ONLY,\n  CONSTANT_POOL_UINT8,\n  CONSTANT_POOL,\n  CONSTANT_POOL_AND_UINT8_VALUE,\n  UINT8_VALUE,\n  UINT8_AND_INT8_VALUE,\n  INT8_VALUE,\n  INT16_VALUE,\n  INT32_VALUE,\n  // LOOKUPSWITCH,\n  // TABLESWITCH,\n  ARRAY_TYPE,\n  WIDE\n}\n\n// Contains the opcode layout types for each valid opcode.\n// To conserve code space, it's assumed all opcodes not in the table\n// are OPCODE_ONLY.\nvar olt: OpcodeLayoutType[] = new Array(0xff);\n(() => {\n  for (var i = 0; i < 0xff; i++) {\n    olt[i] = OpcodeLayoutType.OPCODE_ONLY;\n  }\n})();\nfunction assignOpcodeLayout(layoutType: OpcodeLayoutType, opcodes: OpCode[]): void {\n  opcodes.forEach((opcode) => {\n    olt[opcode] = layoutType;\n  });\n}\n\nassignOpcodeLayout(OpcodeLayoutType.UINT8_VALUE,\n  [OpCode.ALOAD, OpCode.ASTORE, OpCode.DLOAD, OpCode.DSTORE,\n   OpCode.FLOAD, OpCode.FSTORE, OpCode.ILOAD, OpCode.ISTORE,\n   OpCode.LLOAD, OpCode.LSTORE, OpCode.RET]);\nassignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_UINT8, [OpCode.LDC]);\nassignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL,\n  [OpCode.LDC_W, OpCode.LDC2_W,\n   OpCode.ANEWARRAY, OpCode.CHECKCAST, OpCode.GETFIELD,\n   OpCode.GETSTATIC, OpCode.INSTANCEOF, OpCode.INVOKEDYNAMIC,\n   OpCode.INVOKESPECIAL, OpCode.INVOKESTATIC, OpCode.INVOKEVIRTUAL,\n   OpCode.NEW, OpCode.PUTFIELD, OpCode.PUTSTATIC, OpCode.MULTIANEWARRAY_FAST,\n   OpCode.INVOKENONVIRTUAL_FAST, OpCode.INVOKESTATIC_FAST, OpCode.CHECKCAST_FAST,\n   OpCode.NEW_FAST,\n   OpCode.ANEWARRAY_FAST, OpCode.INSTANCEOF_FAST, OpCode.GETSTATIC_FAST32,\n   OpCode.GETSTATIC_FAST64, OpCode.PUTSTATIC_FAST32, OpCode.PUTSTATIC_FAST64,\n   OpCode.PUTFIELD_FAST32, OpCode.PUTFIELD_FAST64,\n   OpCode.GETFIELD_FAST32, OpCode.GETFIELD_FAST64, OpCode.INVOKEVIRTUAL_FAST\n]);\nassignOpcodeLayout(OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE,\n  [OpCode.INVOKEINTERFACE, OpCode.INVOKEINTERFACE_FAST, OpCode.MULTIANEWARRAY]);\nassignOpcodeLayout(OpcodeLayoutType.INT8_VALUE, [OpCode.BIPUSH]);\nassignOpcodeLayout(OpcodeLayoutType.INT16_VALUE,\n  [OpCode.SIPUSH, OpCode.GOTO, OpCode.IFGT, OpCode.IFEQ, OpCode.IFGE, OpCode.IFLE,\n   OpCode.IFLT, OpCode.IFNE, OpCode.IFNULL, OpCode.IFNONNULL, OpCode.IF_ICMPLE,\n   OpCode.IF_ACMPEQ, OpCode.IF_ACMPNE, OpCode.IF_ICMPEQ, OpCode.IF_ICMPGE,\n   OpCode.IF_ICMPGT, OpCode.IF_ICMPLT, OpCode.IF_ICMPNE, OpCode.JSR]);\nassignOpcodeLayout(OpcodeLayoutType.INT32_VALUE, [OpCode.GOTO_W, OpCode.JSR_W]);\nassignOpcodeLayout(OpcodeLayoutType.UINT8_AND_INT8_VALUE, [OpCode.IINC]);\nassignOpcodeLayout(OpcodeLayoutType.ARRAY_TYPE, [OpCode.NEWARRAY]);\n\nexport var OpcodeLayouts = olt;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/enums.ts\n **/","﻿/**\n * A safe to use key value map.\n * \n * JavaScript objects cannot be used as general-purpose key value maps, as they\n * contain a number of default fields. This class avoids those issues.\n */\nclass SafeMap<T> {\n  private cache: { [key: string]: T };\n\n  constructor() {\n    this.cache = Object.create(null);  // has no defined properties aside from __proto__\n  }\n\n  /**\n   * Mutates the key so that it cannot possibly conflict with existing object\n   * properties.\n   */\n  private fixKey(key: string): string {\n    return ';' + key;\n  }\n\n  public get(key: string): T {\n    key = this.fixKey(key);\n    if (this.cache[key] !== undefined) {\n      return this.cache[key];\n    }\n    return undefined;\n  }\n\n  public has(key: string): boolean {\n    return this.get(key) !== undefined;\n  }\n\n  public set(key: string, value: T): void {\n    this.cache[this.fixKey(key)] = value;\n  }\n}\n\nexport = SafeMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/SafeMap.ts\n **/","\"use strict\";\nimport util = require('./util');\nimport ByteStream = require('./ByteStream');\nimport attributes = require('./attributes');\nimport JVM = require('./jvm');\nimport ConstantPool = require('./ConstantPool');\nimport ClassData = require('./ClassData');\nimport threading = require('./threading');\nimport gLong = require('./gLong');\nimport ClassLoader = require('./ClassLoader');\nimport assert = require('./assert');\nimport enums = require('./enums');\nimport Monitor = require('./Monitor');\nimport StringOutputStream = require('./StringOutputStream');\nimport JVMTypes = require('../includes/JVMTypes');\nimport global = require('./global');\nimport {JitInfo, opJitInfo} from './jit';\n\ndeclare var RELEASE: boolean;\nif (typeof RELEASE === 'undefined') global.RELEASE = false;\n\nvar trapped_methods: { [clsName: string]: { [methodName: string]: Function } } = {\n  'java/lang/ref/Reference': {\n    // NOP, because we don't do our own GC and also this starts a thread?!?!?!\n    '<clinit>()V': function (thread: threading.JVMThread): void { }\n  },\n  'java/lang/System': {\n    'loadLibrary(Ljava/lang/String;)V': function (thread: threading.JVMThread, libName: JVMTypes.java_lang_String): void {\n      // Some libraries test if native libraries are available,\n      // and expect an exception if they are not.\n      // List all of the native libraries we support.\n      var lib = libName.toString();\n      switch (lib) {\n        case 'zip':\n        case 'net':\n        case 'nio':\n        case 'awt':\n        case 'fontmanager':\n        case 'management':\n          return;\n        default:\n          thread.throwNewException('Ljava/lang/UnsatisfiedLinkError;', `no ${lib} in java.library.path`);\n          break;\n      }\n    }\n  },\n  'java/lang/Terminator': {\n    'setup()V': function (thread: threading.JVMThread): void {\n      // XXX: We should probably fix this; we support threads now.\n      // Historically: NOP'd because we didn't support threads.\n    }\n  },\n  'java/nio/charset/Charset$3': {\n    // this is trapped and NOP'ed for speed\n    'run()Ljava/lang/Object;': function (thread: threading.JVMThread, javaThis: JVMTypes.java_nio_charset_Charset$3): JVMTypes.java_lang_Object {\n      return null;\n    }\n  },\n  'sun/nio/fs/DefaultFileSystemProvider': {\n    // OpenJDK doesn't know what the \"Doppio\" platform is. Tell it to use the Linux file system.\n    'create()Ljava/nio/file/spi/FileSystemProvider;': function(thread: threading.JVMThread): void {\n      thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);\n      var dfsp: ClassData.ReferenceClassData<JVMTypes.sun_nio_fs_DefaultFileSystemProvider> = <any> thread.getBsCl().getInitializedClass(thread, 'Lsun/nio/fs/DefaultFileSystemProvider;'),\n       dfspCls: typeof JVMTypes.sun_nio_fs_DefaultFileSystemProvider = <any> dfsp.getConstructor(thread);\n      dfspCls['createProvider(Ljava/lang/String;)Ljava/nio/file/spi/FileSystemProvider;'](thread, [thread.getJVM().internString('sun.nio.fs.LinuxFileSystemProvider')], util.forwardResult(thread));\n    }\n  }\n};\n\nfunction getTrappedMethod(clsName: string, methSig: string): Function {\n  clsName = util.descriptor2typestr(clsName);\n  if (trapped_methods.hasOwnProperty(clsName) && trapped_methods[clsName].hasOwnProperty(methSig)) {\n    return trapped_methods[clsName][methSig];\n  }\n  return null;\n}\n\n/**\n * Shared functionality between Method and Field objects, as they are\n * represented similarly in class files.\n */\nexport class AbstractMethodField {\n  /**\n   * The declaring class of this method or field.\n   */\n  public cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>;\n  /**\n   * The method / field's index in its defining class's method/field array.\n   */\n  public slot: number;\n  /**\n   * The method / field's flags (e.g. static).\n   */\n  public accessFlags: util.Flags;\n  /**\n   * The name of the field, without the descriptor or owning class.\n   */\n  public name: string;\n  /**\n   * The method/field's type descriptor.\n   * e.g.:\n   * public String foo; => Ljava/lang/String;\n   * public void foo(String bar); => (Ljava/lang/String;)V\n   */\n  public rawDescriptor: string;\n  /**\n   * Any attributes on this method or field.\n   */\n  public attrs: attributes.IAttribute[];\n\n  /**\n   * Constructs a field or method object from raw class data.\n   */\n  constructor(cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, constantPool: ConstantPool.ConstantPool, slot: number, byteStream: ByteStream) {\n    this.cls = cls;\n    this.slot = slot;\n    this.accessFlags = new util.Flags(byteStream.getUint16());\n    this.name = (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value;\n    this.rawDescriptor = (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value;\n    this.attrs = attributes.makeAttributes(byteStream, constantPool);\n  }\n\n  public getAttribute(name: string): attributes.IAttribute {\n    for (var i = 0; i < this.attrs.length; i++) {\n      var attr = this.attrs[i];\n      if (attr.getName() === name) {\n        return attr;\n      }\n    }\n    return null;\n  }\n\n  public getAttributes(name: string): attributes.IAttribute[] {\n    return this.attrs.filter((attr) => attr.getName() === name);\n  }\n\n  /**\n   * Get the particular type of annotation as a JVM byte array. Returns null\n   * if the annotation does not exist.\n   */\n  protected getAnnotationType(thread: threading.JVMThread, name: string): JVMTypes.JVMArray<number> {\n    var annotation = <{ rawBytes: Buffer }> <any> this.getAttribute(name);\n    if (annotation === null) {\n      return null;\n    }\n    var byteArrCons = (<ClassData.ArrayClassData<number>> thread.getBsCl().getInitializedClass(thread, '[B')).getConstructor(thread),\n      rv = new byteArrCons(thread, 0);\n\n    // TODO: Convert to typed array.\n    var i: number, len = annotation.rawBytes.length, arr = new Array(len);\n    for (i = 0; i < len; i++) {\n      arr[i] = annotation.rawBytes.readInt8(i);\n    }\n    rv.array = arr;\n    return rv;\n  }\n\n  // To satiate TypeScript. Consider it an 'abstract' method.\n  public parseDescriptor(raw_descriptor: string): void {\n    throw new Error(\"Unimplemented error.\");\n  }\n}\n\nexport class Field extends AbstractMethodField {\n  /**\n   * The field's full name, which includes the defining class\n   * (e.g. java/lang/String/value).\n   */\n  public fullName: string;\n\n  constructor(cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, constantPool: ConstantPool.ConstantPool, slot: number, byteStream: ByteStream) {\n    super(cls, constantPool, slot, byteStream);\n    this.fullName = `${util.descriptor2typestr(cls.getInternalName())}/${this.name}`;\n  }\n\n  /**\n   * Calls cb with the reflectedField if it succeeds. Calls cb with null if it\n   * fails.\n   */\n  public reflector(thread: threading.JVMThread, cb: (reflectedField: JVMTypes.java_lang_reflect_Field) => void): void {\n    var signatureAttr = <attributes.Signature> this.getAttribute(\"Signature\"),\n      jvm = thread.getJVM(),\n      bsCl = thread.getBsCl();\n    var createObj = (typeObj: JVMTypes.java_lang_Class): JVMTypes.java_lang_reflect_Field => {\n      var fieldCls = <ClassData.ReferenceClassData<JVMTypes.java_lang_reflect_Field>> bsCl.getInitializedClass(thread, 'Ljava/lang/reflect/Field;'),\n        fieldObj = new (fieldCls.getConstructor(thread))(thread);\n\n      fieldObj['java/lang/reflect/Field/clazz'] = this.cls.getClassObject(thread);\n      fieldObj['java/lang/reflect/Field/name'] = jvm.internString(this.name);\n      fieldObj['java/lang/reflect/Field/type'] = typeObj;\n      fieldObj['java/lang/reflect/Field/modifiers'] = this.accessFlags.getRawByte();\n      fieldObj['java/lang/reflect/Field/slot'] = this.slot;\n      fieldObj['java/lang/reflect/Field/signature'] = signatureAttr !== null ? util.initString(bsCl, signatureAttr.sig) : null;\n      fieldObj['java/lang/reflect/Field/annotations'] = this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');\n\n      return fieldObj;\n    };\n    // Our field's type may not be loaded, so we asynchronously load it here.\n    // In the future, we can speed up reflection by having a synchronous_reflector\n    // method that we can try first, and which may fail.\n    this.cls.getLoader().resolveClass(thread, this.rawDescriptor, (cdata: ClassData.ClassData) => {\n      if (cdata != null) {\n        cb(createObj(cdata.getClassObject(thread)));\n      } else {\n        cb(null);\n      }\n    });\n  }\n\n  private getDefaultFieldValue(): string {\n    var desc = this.rawDescriptor;\n    if (desc === 'J') return 'gLongZero';\n    var c = desc[0];\n    if (c === '[' || c === 'L') return 'null';\n    return '0';\n  }\n\n  /**\n   * Outputs a JavaScript field assignment for this field.\n   */\n  public outputJavaScriptField(jsConsName: string, outputStream: StringOutputStream): void {\n    if (this.accessFlags.isStatic()) {\n      outputStream.write(`${jsConsName}[\"${util.reescapeJVMName(this.fullName)}\"] = cls._getInitialStaticFieldValue(thread, \"${util.reescapeJVMName(this.name)}\");\\n`);\n    } else {\n      outputStream.write(`this[\"${util.reescapeJVMName(this.fullName)}\"] = ${this.getDefaultFieldValue()};\\n`);\n    }\n  }\n}\n\nconst opcodeSize: number[] = function() {\n  const table:number[] = [];\n  const layoutType = enums.OpcodeLayoutType;\n\n  table[layoutType.OPCODE_ONLY] = 1;\n  table[layoutType.CONSTANT_POOL_UINT8] = 2;\n  table[layoutType.CONSTANT_POOL] = 3;\n  table[layoutType.CONSTANT_POOL_AND_UINT8_VALUE] = 4;\n  table[layoutType.UINT8_VALUE] = 2;\n  table[layoutType.UINT8_AND_INT8_VALUE] = 3;\n  table[layoutType.INT8_VALUE] = 2;\n  table[layoutType.INT16_VALUE] = 3;\n  table[layoutType.INT32_VALUE] = 5;\n  table[layoutType.ARRAY_TYPE] = 2;\n  table[layoutType.WIDE] = 1;\n\n  return table;\n}();\n\nclass TraceInfo {\n  pops: string[] = [];\n  pushes: string[] = [];\n  prefixEmit: string = \"\";\n  onErrorPushes: string[];\n\n  constructor(public pc: number, public jitInfo: JitInfo) {\n  }\n}\n\nclass Trace {\n  private infos: TraceInfo[] = [];\n  private endPc: number = -1;\n\n  constructor(public startPC: number, private code: Buffer, private method: Method) {\n  }\n\n  /**\n   * Emits a PC update statement at the end of the trace.\n   */\n  public emitEndPC(pc: number): void {\n    this.endPc = pc;\n  }\n\n  public addOp(pc: number, jitInfo: JitInfo) {\n    this.infos.push(new TraceInfo(pc, jitInfo));\n  }\n\n  public close(thread: threading.JVMThread): Function {\n    if (this.infos.length > 1) {\n      const symbolicStack: string[] = [];\n      let symbolCount = 0;\n      // Ensure that the last statement sets the PC if the\n      // last opcode doesn't.\n      let emitted = this.endPc > -1 ? `f.pc=${this.endPc};` : \"\";\n      for (let i = 0; i < this.infos.length; i++) {\n        const info = this.infos[i];\n        const jitInfo = info.jitInfo;\n\n        const pops = info.pops;\n        const normalizedPops = jitInfo.pops < 0 ? Math.min(-jitInfo.pops, symbolicStack.length) : jitInfo.pops;\n        for (let j = 0; j < normalizedPops; j++) {\n          if (symbolicStack.length > 0) {\n            pops.push(symbolicStack.pop());\n          } else {\n            const symbol = \"s\" + symbolCount++;\n            info.prefixEmit += `var ${symbol} = f.opStack.pop();`;\n            pops.push(symbol);\n          }\n        }\n\n        info.onErrorPushes = symbolicStack.slice();\n\n        const pushes = info.pushes;\n        for (let j = 0; j < jitInfo.pushes; j++) {\n          const symbol = \"s\" + symbolCount++;\n          symbolicStack.push(symbol);\n          pushes.push(symbol);\n        }\n\n      }\n\n      if (symbolicStack.length === 1) {\n        emitted += `f.opStack.push(${symbolicStack[0]});`;\n      } else if (symbolicStack.length > 1) {\n        emitted += `f.opStack.pushAll(${symbolicStack.join(',')});`;\n      }\n\n      for (let i = this.infos.length-1; i >= 0; i--) {\n        const info = this.infos[i];\n        const jitInfo = info.jitInfo;\n        emitted = info.prefixEmit + jitInfo.emit(info.pops, info.pushes, \"\"+i, emitted, this.code, info.pc, info.onErrorPushes, this.method);\n      }\n\n      if (!RELEASE && thread.getJVM().shouldPrintJITCompilation()) {\n        console.log(`Emitted trace of ${this.infos.length} ops: ` + emitted);\n      }\n      // f = frame, t = thread, u = util\n      return new Function(\"f\", \"t\", \"u\", emitted);\n    } else {\n      if (!RELEASE && thread.getJVM().shouldPrintJITCompilation()) {\n        console.log(`Trace was cancelled`);\n      }\n      return null;\n    }\n  }\n}\n\nexport class Method extends AbstractMethodField {\n  /**\n   * The method's parameters, if any, in descriptor form.\n   */\n  public parameterTypes: string[];\n  /**\n   * The method's return type in descriptor form.\n   */\n  public returnType: string;\n  /**\n   * The method's signature, e.g. bar()V\n   */\n  public signature: string;\n  /**\n   * The method's signature, including defining class; e.g. java/lang/String/bar()V\n   */\n  public fullSignature: string;\n  /**\n   * The number of JVM words required to store the parameters (e.g. longs/doubles take up 2 words).\n   * Does not include the \"this\" argument to non-static functions.\n   */\n  private parameterWords: number;\n  /**\n   * Code is either a function, or a CodeAttribute.\n   * TODO: Differentiate between NativeMethod objects and BytecodeMethod objects.\n   */\n  private code: any;\n\n  /**\n   * number of basic block entries\n   */\n  private numBBEntries = 0;\n\n  private compiledFunctions: Function[] = [];\n  private failedCompile: boolean[] = [];\n\n  constructor(cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, constantPool: ConstantPool.ConstantPool, slot: number, byteStream: ByteStream) {\n    super(cls, constantPool, slot, byteStream);\n    var parsedDescriptor = util.getTypes(this.rawDescriptor), i: number,\n      p: string;\n    this.signature = this.name + this.rawDescriptor;\n    this.fullSignature = `${util.descriptor2typestr(this.cls.getInternalName())}/${this.signature}`;\n    this.returnType = parsedDescriptor.pop();\n    this.parameterTypes = parsedDescriptor;\n    this.parameterWords = parsedDescriptor.length;\n\n    // Double count doubles / longs.\n    for (i = 0; i < this.parameterTypes.length; i++) {\n      p = this.parameterTypes[i];\n      if (p === 'D' || p === 'J') {\n        this.parameterWords++;\n      }\n    }\n\n    // Initialize 'code' property.\n    var clsName = this.cls.getInternalName();\n    if (getTrappedMethod(clsName, this.signature) !== null) {\n      this.code = getTrappedMethod(clsName, this.signature);\n      this.accessFlags.setNative(true);\n    } else if (this.accessFlags.isNative()) {\n      if (this.signature.indexOf('registerNatives()V', 0) < 0 && this.signature.indexOf('initIDs()V', 0) < 0) {\n        // The first version of the native method attempts to fetch itself and\n        // rewrite itself.\n        var self = this;\n        this.code = function(thread: threading.JVMThread) {\n          // Try to fetch the native method.\n          var jvm = thread.getJVM(),\n            c = jvm.getNative(clsName, self.signature);\n          if (c == null) {\n            thread.throwNewException('Ljava/lang/UnsatisfiedLinkError;', `Native method '${self.getFullSignature()}' not implemented.\\nPlease fix or file a bug at https://github.com/plasma-umass/doppio/issues`);\n          } else {\n            self.code = c;\n            return c.apply(self, arguments);\n          }\n        };\n      } else {\n        // Stub out initIDs and registerNatives.\n        this.code = () => { };\n      }\n    } else if (!this.accessFlags.isAbstract()) {\n      this.code = this.getAttribute('Code');\n      const codeLength = this.code.code.length;\n\n      // jit threshold. we countdown to zero from here.\n      this.numBBEntries = codeLength > 3 ? 200 : 1000 * codeLength;\n    }\n  }\n\n  public incrBBEntries() {\n    // Optimisiation: we countdown to zero, instead of storing a positive limit in a separate variable\n    this.numBBEntries--;\n  }\n\n  /**\n   * Checks if the method is a default method.\n   * A default method is a public non-abstract instance method, that\n   * is, a non-static method with a body, declared in an interface\n   * type.\n   */\n  public isDefault(): boolean {\n    return (this.accessFlags.isPublic() && !this.accessFlags.isAbstract() && !this.accessFlags.isStatic() && this.cls.accessFlags.isInterface());\n  }\n\n  public getFullSignature(): string {\n    return `${this.cls.getExternalName()}.${this.name}${this.rawDescriptor}`;\n  }\n\n  /**\n   * Checks if this particular method should be hidden in stack frames.\n   * Used by OpenJDK's lambda implementation to hide lambda boilerplate.\n   */\n  public isHidden(): boolean {\n    var rva: attributes.RuntimeVisibleAnnotations = <any> this.getAttribute('RuntimeVisibleAnnotations');\n    return rva !== null && rva.isHidden;\n  }\n\n  /**\n   * Checks if this particular method has the CallerSensitive annotation.\n   */\n  public isCallerSensitive(): boolean {\n    var rva: attributes.RuntimeVisibleAnnotations = <any> this.getAttribute('RuntimeVisibleAnnotations');\n    return rva !== null && rva.isCallerSensitive;\n  }\n\n  /**\n   * Get the number of machine words (32-bit words) required to store the\n   * parameters to this function. Includes adding in a machine word for 'this'\n   * for non-static functions.\n   */\n  public getParamWordSize(): number {\n    return this.parameterWords;\n  }\n\n  public getCodeAttribute(): attributes.Code {\n    assert(!this.accessFlags.isNative() && !this.accessFlags.isAbstract());\n    return this.code;\n  }\n\n  public getOp(pc: number, codeBuffer: Buffer, thread: threading.JVMThread): any {\n    if (this.numBBEntries <= 0) {\n      if (!this.failedCompile[pc]) {\n        const cachedCompiledFunction = this.compiledFunctions[pc];\n        if (!cachedCompiledFunction) {\n          const compiledFunction = this.jitCompileFrom(pc, thread);\n          if (compiledFunction) {\n            return compiledFunction;\n          } else {\n            this.failedCompile[pc] = true;\n          }\n        } else {\n          return cachedCompiledFunction;\n        }\n      }\n    }\n    return codeBuffer.readUInt8(pc);\n  }\n\n  private makeInvokeStaticJitInfo(code: Buffer, pc: number) : JitInfo {\n    const index = code.readUInt16BE(pc + 1);\n    const methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> this.cls.constantPool.get(index);\n    const paramSize = methodReference.paramWordSize;\n    const method = methodReference.jsConstructor[methodReference.fullSignature];\n\n    return {hasBranch: true, pops: -paramSize, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n      const argInitialiser = paramSize > pops.length ? `f.opStack.sliceAndDropFromTop(${paramSize - pops.length});` : `[${pops.reduce((a,b) => b + ',' + a, '')}];`;\n      let argMaker = `var args${suffix}=` + argInitialiser;\n      if ((paramSize > pops.length) && (pops.length > 0)) {\n        argMaker += `args${suffix}.push(${pops.slice().reverse().join(',')});`;\n      }\n      return argMaker + `\nvar methodReference${suffix}=f.method.cls.constantPool.get(${index});\nf.pc=${pc};\nmethodReference${suffix}.jsConstructor[methodReference${suffix}.fullSignature](t,args${suffix});\nf.returnToThreadLoop=true;\n${onSuccess}`;\n    }};\n\n  }\n\n  private makeInvokeVirtualJitInfo(code: Buffer, pc: number) : JitInfo {\n    const index = code.readUInt16BE(pc + 1);\n    const methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> this.cls.constantPool.get(index);\n    const paramSize = methodReference.paramWordSize;\n    return {hasBranch: true, pops: -(paramSize + 1), pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n      const onError = makeOnError(onErrorPushes);\n      const argInitialiser = paramSize > pops.length ? `f.opStack.sliceAndDropFromTop(${paramSize - pops.length});` : `[${pops.slice(0, paramSize).reduce((a,b) => b + ',' + a, '')}];`;\n      let argMaker = `var args${suffix}=` + argInitialiser;\n      if ((paramSize > pops.length) && (pops.length > 0)) {\n        argMaker += `args${suffix}.push(${pops.slice().reverse().join(',')});`;\n      }\n      return argMaker + `var obj${suffix}=${(paramSize+1)===pops.length?pops[paramSize]:\"f.opStack.pop()\"};f.pc=${pc};\nif(!u.isNull(t,f,obj${suffix})){obj${suffix}['${methodReference.signature}'](t,args${suffix});f.returnToThreadLoop=true;${onSuccess}}else{${onError}}`;\n    }};\n\n  }\n\n  private makeInvokeNonVirtualJitInfo(code: Buffer, pc: number) : JitInfo {\n    const index = code.readUInt16BE(pc + 1);\n    const methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> this.cls.constantPool.get(index);\n    const paramSize = methodReference.paramWordSize;\n    return {hasBranch: true, pops: -(paramSize + 1), pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n      const onError = makeOnError(onErrorPushes);\n      const argInitialiser = paramSize > pops.length ? `f.opStack.sliceAndDropFromTop(${paramSize - pops.length});` : `[${pops.slice(0, paramSize).reduce((a,b) => b + ',' + a, '')}];`;\n      let argMaker = `var args${suffix}=` + argInitialiser;\n      if ((paramSize > pops.length) && (pops.length > 0)) {\n        argMaker += `args${suffix}.push(${pops.slice().reverse().join(',')});`;\n      }\n      return argMaker + `var obj${suffix}=${(paramSize+1)===pops.length?pops[paramSize]:\"f.opStack.pop()\"};f.pc=${pc};\nif(!u.isNull(t,f,obj${suffix})){obj${suffix}['${methodReference.fullSignature}'](t, args${suffix});f.returnToThreadLoop=true;${onSuccess}}else{${onError}}`;\n    }};\n  }\n\n  private jitCompileFrom(startPC: number, thread: threading.JVMThread) {\n    if (!RELEASE && thread.getJVM().shouldPrintJITCompilation()) {\n      console.log(`Planning to JIT: ${this.fullSignature} from ${startPC}`);\n    }\n    const code = this.getCodeAttribute().getCode();\n    let trace: Trace = null;\n    const _this = this;\n    let done = false;\n\n    function closeCurrentTrace() {\n      if (trace !== null) {\n        // console.log(\"Tracing method: \" + _this.fullSignature);\n        const compiledFunction = trace.close(thread);\n        if (compiledFunction) {\n          _this.compiledFunctions[trace.startPC] = compiledFunction;\n          if (!RELEASE && thread.getJVM().shouldDumpCompiledCode()) {\n            thread.getJVM().dumpCompiledMethod(_this.fullSignature, trace.startPC, compiledFunction.toString());\n          }\n        }\n        trace = null;\n      }\n      done = true;\n    }\n\n    for (let i = startPC; i < code.length && !done;) {\n      const op = code.readUInt8(i);\n      // TODO: handle wide()\n      if (!RELEASE && thread.getJVM().shouldPrintJITCompilation()) {\n        console.log(`${i}: ${threading.annotateOpcode(op, this, code, i)}`);\n      }\n      const jitInfo = opJitInfo[op];\n      if (jitInfo) {\n        if (trace === null) {\n          trace = new Trace(i, code, _this);\n        }\n        trace.addOp(i, jitInfo);\n        if (jitInfo.hasBranch) {\n          this.failedCompile[i] = true;\n          closeCurrentTrace();\n        }\n      } else if (op === enums.OpCode.INVOKESTATIC_FAST && trace !== null) {\n        const invokeJitInfo: JitInfo = this.makeInvokeStaticJitInfo(code, i);\n        trace.addOp(i, invokeJitInfo);\n\n        this.failedCompile[i] = true;\n        closeCurrentTrace();\n\n      } else if (((op === enums.OpCode.INVOKEVIRTUAL_FAST) || (op === enums.OpCode.INVOKEINTERFACE_FAST)) && trace !== null) {\n        const invokeJitInfo: JitInfo = this.makeInvokeVirtualJitInfo(code, i);\n        trace.addOp(i, invokeJitInfo);\n\n        this.failedCompile[i] = true;\n        closeCurrentTrace();\n      } else if ((op === enums.OpCode.INVOKENONVIRTUAL_FAST) && trace !== null) {\n        const invokeJitInfo: JitInfo = this.makeInvokeNonVirtualJitInfo(code, i);\n        trace.addOp(i, invokeJitInfo);\n\n        this.failedCompile[i] = true;\n        closeCurrentTrace();\n      } else {\n        if (!RELEASE) {\n          if (trace !== null) {\n            statTraceCloser[op]++;\n          }\n        }\n        this.failedCompile[i] = true;\n        if (trace) {\n          trace.emitEndPC(i);\n        }\n        closeCurrentTrace();\n      }\n      i += opcodeSize[enums.OpcodeLayouts[op]];\n    }\n\n    return _this.compiledFunctions[startPC];\n  }\n\n  public getNativeFunction(): Function {\n    assert(this.accessFlags.isNative() && typeof (this.code) === 'function');\n    return this.code;\n  }\n\n  /**\n   * Resolves all of the classes referenced through this method. Required in\n   * order to create its reflection object.\n   */\n  private _resolveReferencedClasses(thread: threading.JVMThread, cb: (classes: {[ className: string ]: ClassData.ClassData}) => void): void {\n    // Start with the return type + parameter types + reflection object types.\n    var toResolve: string[] = this.parameterTypes.concat(this.returnType),\n      code: attributes.Code = this.code,\n      exceptionAttribute = <attributes.Exceptions> this.getAttribute(\"Exceptions\");\n    // Exception handler types.\n    if (!this.accessFlags.isNative() && !this.accessFlags.isAbstract() && code.exceptionHandlers.length > 0) {\n      toResolve.push('Ljava/lang/Throwable;'); // Mimic native Java (in case <any> is the only handler).\n      // Filter out the <any> handlers.\n      toResolve = toResolve.concat(code.exceptionHandlers.filter((handler) => handler.catchType !== '<any>').map((handler) => handler.catchType));\n    }\n    // Resolve checked exception types.\n    if (exceptionAttribute !== null) {\n      toResolve = toResolve.concat(exceptionAttribute.exceptions);\n    }\n\n    this.cls.getLoader().resolveClasses(thread, toResolve, (classes: {[className: string]: ClassData.ClassData}) => {\n      // Use bootstrap classloader for reflection classes.\n      thread.getBsCl().resolveClasses(thread, ['Ljava/lang/reflect/Method;', 'Ljava/lang/reflect/Constructor;'], (classes2: {[className: string]: ClassData.ClassData}) => {\n        if (classes === null || classes2 === null) {\n          cb(null);\n        } else {\n          classes['Ljava/lang/reflect/Method;'] = classes2['Ljava/lang/reflect/Method;'];\n          classes['Ljava/lang/reflect/Constructor;'] = classes2['Ljava/lang/reflect/Constructor;'];\n          cb(classes);\n        }\n      });\n    });\n  }\n\n  /**\n   * Get a reflection object representing this method.\n   */\n  public reflector(thread: threading.JVMThread, cb: (reflectedMethod: JVMTypes.java_lang_reflect_Executable) => void): void {\n    var bsCl = thread.getBsCl(),\n      // Grab the classes required to construct the needed arrays.\n      clazzArray = (<ClassData.ArrayClassData<JVMTypes.java_lang_Class>> bsCl.getInitializedClass(thread, '[Ljava/lang/Class;')).getConstructor(thread),\n      jvm = thread.getJVM(),\n      // Grab the needed attributes.\n      signatureAttr = <attributes.Signature> this.getAttribute(\"Signature\"),\n      exceptionAttr = <attributes.Exceptions> this.getAttribute(\"Exceptions\");\n\n    // Retrieve all of the required class references.\n    this._resolveReferencedClasses(thread, (classes: { [className: string ]: ClassData.ClassData }) => {\n      if (classes === null) {\n        return cb(null);\n      }\n\n      // Construct the needed objects for the reflection object.\n      var clazz = this.cls.getClassObject(thread),\n        name = jvm.internString(this.name),\n        parameterTypes = new clazzArray(thread, 0),\n        returnType = classes[this.returnType].getClassObject(thread),\n        exceptionTypes = new clazzArray(thread, 0),\n        modifiers = this.accessFlags.getRawByte(),\n        signature = signatureAttr !== null ? jvm.internString(signatureAttr.sig) : null;\n\n      // Prepare the class arrays.\n      parameterTypes.array = this.parameterTypes.map((ptype: string) => classes[ptype].getClassObject(thread));\n      if (exceptionAttr !== null) {\n        exceptionTypes.array = exceptionAttr.exceptions.map((eType: string) => classes[eType].getClassObject(thread));\n      }\n\n      if (this.name === '<init>') {\n        // Constructor object.\n        var consCons = (<ClassData.ReferenceClassData<JVMTypes.java_lang_reflect_Constructor>> classes['Ljava/lang/reflect/Constructor;']).getConstructor(thread),\n          consObj = new consCons(thread);\n        consObj['java/lang/reflect/Constructor/clazz'] = clazz;\n        consObj['java/lang/reflect/Constructor/parameterTypes'] = parameterTypes;\n        consObj['java/lang/reflect/Constructor/exceptionTypes'] = exceptionTypes;\n        consObj['java/lang/reflect/Constructor/modifiers'] = modifiers;\n        consObj['java/lang/reflect/Constructor/slot'] = this.slot;\n        consObj['java/lang/reflect/Constructor/signature'] = signature;\n        consObj['java/lang/reflect/Constructor/annotations'] = this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');\n        consObj['java/lang/reflect/Constructor/parameterAnnotations'] = this.getAnnotationType(thread, 'RuntimeVisibleParameterAnnotations');\n        cb(consObj);\n      } else {\n        // Method object.\n        var methodCons = (<ClassData.ReferenceClassData<JVMTypes.java_lang_reflect_Method>>  classes['Ljava/lang/reflect/Method;']).getConstructor(thread),\n          methodObj = new methodCons(thread);\n        methodObj['java/lang/reflect/Method/clazz'] = clazz;\n        methodObj['java/lang/reflect/Method/name'] = name;\n        methodObj['java/lang/reflect/Method/parameterTypes'] = parameterTypes;\n        methodObj['java/lang/reflect/Method/returnType'] = returnType;\n        methodObj['java/lang/reflect/Method/exceptionTypes'] = exceptionTypes;\n        methodObj['java/lang/reflect/Method/modifiers'] = modifiers;\n        methodObj['java/lang/reflect/Method/slot'] = this.slot;\n        methodObj['java/lang/reflect/Method/signature'] = signature;\n        methodObj['java/lang/reflect/Method/annotations'] = this.getAnnotationType(thread, 'RuntimeVisibleAnnotations');\n        methodObj['java/lang/reflect/Method/annotationDefault'] = this.getAnnotationType(thread, 'AnnotationDefault');\n        methodObj['java/lang/reflect/Method/parameterAnnotations'] = this.getAnnotationType(thread, 'RuntimeVisibleParameterAnnotations');\n        cb(methodObj);\n      }\n    });\n  }\n\n  /**\n   * Convert the arguments to this method into a form suitable for a native\n   * implementation.\n   *\n   * The JVM uses two parameter slots for double and long values, since they\n   * consist of two JVM machine words (32-bits). Doppio stores the entire value\n   * in one slot, and stores a NULL in the second.\n   *\n   * This function strips out these NULLs so the arguments are in a more\n   * consistent form. The return value is the arguments to this function without\n   * these NULL values. It also adds the 'thread' object to the start of the\n   * arguments array.\n   */\n  public convertArgs(thread: threading.JVMThread, params: any[]): any[] {\n    if (this.isSignaturePolymorphic()) {\n      // These don't need any conversion, and have arbitrary arguments.\n      // Just append the thread object.\n      params.unshift(thread);\n      return params;\n    }\n    var convertedArgs = [thread], argIdx = 0, i: number;\n    if (!this.accessFlags.isStatic()) {\n      convertedArgs.push(params[0]);\n      argIdx = 1;\n    }\n    for (i = 0; i < this.parameterTypes.length; i++) {\n      var p = this.parameterTypes[i];\n      convertedArgs.push(params[argIdx]);\n      argIdx += (p === 'J' || p === 'D') ? 2 : 1;\n    }\n    return convertedArgs;\n  }\n\n  /**\n   * Lock this particular method.\n   */\n  public methodLock(thread: threading.JVMThread, frame: threading.BytecodeStackFrame): Monitor {\n    if (this.accessFlags.isStatic()) {\n      // Static methods lock the class.\n      return this.cls.getClassObject(thread).getMonitor();\n    } else {\n      // Non-static methods lock the instance.\n      return (<JVMTypes.java_lang_Object> frame.locals[0]).getMonitor();\n    }\n  }\n\n  /**\n   * Check if this is a signature polymorphic method.\n   * From S2.9:\n   * A method is signature polymorphic if and only if all of the following conditions hold :\n   * * It is declared in the java.lang.invoke.MethodHandle class.\n   * * It has a single formal parameter of type Object[].\n   * * It has a return type of Object.\n   * * It has the ACC_VARARGS and ACC_NATIVE flags set.\n   */\n  public isSignaturePolymorphic(): boolean {\n    return this.cls.getInternalName() === 'Ljava/lang/invoke/MethodHandle;' &&\n      this.accessFlags.isNative() && this.accessFlags.isVarArgs() &&\n      this.rawDescriptor === '([Ljava/lang/Object;)Ljava/lang/Object;';\n  }\n\n  /**\n   * Retrieve the MemberName/invokedynamic JavaScript \"bridge method\" that\n   * encapsulates the logic required to call this particular method.\n   */\n  public getVMTargetBridgeMethod(thread: threading.JVMThread, refKind: number): (thread: threading.JVMThread, descriptor: string, args: any[], cb?: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void) => void {\n    // TODO: Could cache these in the Method object if desired.\n    var outStream = new StringOutputStream(),\n      virtualDispatch = !(refKind === enums.MethodHandleReferenceKind.INVOKESTATIC || refKind === enums.MethodHandleReferenceKind.INVOKESPECIAL);\n    // Args: thread, cls, util\n    if (this.accessFlags.isStatic()) {\n      assert(!virtualDispatch, \"Can't have static virtual dispatch.\");\n      outStream.write(`var jsCons = cls.getConstructor(thread);\\n`);\n    }\n    outStream.write(`function bridgeMethod(thread, descriptor, args, cb) {\\n`);\n    if (!this.accessFlags.isStatic()) {\n      outStream.write(`  var obj = args.shift();\\n`);\n      outStream.write(`  if (obj === null) { return thread.throwNewException('Ljava/lang/NullPointerException;', ''); }\\n`);\n      outStream.write(`  obj[\"${util.reescapeJVMName(virtualDispatch ? this.signature : this.fullSignature)}\"](thread, `);\n    } else {\n      outStream.write(`  jsCons[\"${util.reescapeJVMName(this.fullSignature)}\"](thread, `);\n    }\n    // TODO: Is it ever appropriate to box arguments for varargs functions? It appears not.\n    outStream.write(`args`);\n    outStream.write(`, cb);\n  }\n  return bridgeMethod;`);\n\n    var evalText = outStream.flush();\n    if (!RELEASE && thread !== null && thread.getJVM().shouldDumpCompiledCode()) {\n      thread.getJVM().dumpBridgeMethod(this.fullSignature, evalText);\n    }\n    return new Function(\"thread\", \"cls\", \"util\", evalText)(thread, this.cls, util);\n  }\n\n  /**\n   * Generates JavaScript code for this particular method.\n   * TODO: Move lock logic and such into this function! And other specialization.\n   * TODO: Signature polymorphic functions...?\n   */\n  public outputJavaScriptFunction(jsConsName: string, outStream: StringOutputStream, nonVirtualOnly: boolean = false): void {\n    var i: number;\n    if (this.accessFlags.isStatic()) {\n      outStream.write(`${jsConsName}[\"${util.reescapeJVMName(this.fullSignature)}\"] = ${jsConsName}[\"${util.reescapeJVMName(this.signature)}\"] = `);\n    } else {\n      if (!nonVirtualOnly) {\n        outStream.write(`${jsConsName}.prototype[\"${util.reescapeJVMName(this.signature)}\"] = `);\n      }\n      outStream.write(`${jsConsName}.prototype[\"${util.reescapeJVMName(this.fullSignature)}\"] = `);\n    }\n    // cb check is boilerplate, required for natives calling into JVM land.\n    outStream.write(`(function(method) {\n  return function(thread, args, cb) {\n    if (typeof cb === 'function') {\n      thread.stack.push(new InternalStackFrame(cb));\n    }\n    thread.stack.push(new ${this.accessFlags.isNative() ? \"NativeStackFrame\" : \"BytecodeStackFrame\"}(method, `);\n    if (!this.accessFlags.isStatic()) {\n      // Non-static functions need to add the implicit 'this' variable to the\n      // local variables.\n      outStream.write(`[this`);\n      // Give the JS engine hints about the size, type, and contents of the array\n      // by making it a literal.\n      for (i = 0; i < this.parameterWords; i++) {\n        outStream.write(`, args[${i}]`);\n      }\n      outStream.write(`]`);\n    } else {\n      // Static function doesn't need to mutate the arguments.\n      if (this.parameterWords > 0) {\n        outStream.write(`args`);\n      } else {\n        outStream.write(`[]`);\n      }\n    }\n    outStream.write(`));\n    thread.setStatus(${enums.ThreadStatus.RUNNABLE});\n  };\n})(cls.getSpecificMethod(\"${util.reescapeJVMName(this.cls.getInternalName())}\", \"${util.reescapeJVMName(this.signature)}\"));\\n`);\n  }\n}\n\nfunction makeOnError(onErrorPushes: string[]) {\n  return onErrorPushes.length > 0 ? `f.opStack.pushAll(${onErrorPushes.join(',')});` : '';\n}\n\nconst statTraceCloser: number[] = new Array(256);\n\nif (!RELEASE) {\n  for (let i = 0; i < 256; i++) {\n    statTraceCloser[i] = 0;\n  }\n}\n\nexport function dumpStats() {\n  const range = new Array(256);\n  for (let i = 0; i < 256; i++) {\n    range[i] = i;\n  }\n  range.sort((x, y) => statTraceCloser[y] - statTraceCloser[x]);\n  const top = range.slice(0, 24);\n  console.log(\"Opcodes that closed a trace (number of times encountered):\");\n  for (let i = 0; i < top.length; i++) {\n    const op = top[i];\n    if (statTraceCloser[op] > 0) {\n      console.log(enums.OpCode[op], statTraceCloser[op]);\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/methods.ts\n **/","\"use strict\";\nimport util = require('./util');\nimport ByteStream = require('./ByteStream');\nimport ConstantPool = require('./ConstantPool');\nimport enums = require('./enums');\nimport assert = require('./assert');\nimport global = require('./global');\n\ndeclare var RELEASE: boolean;\n\nexport interface IAttributeClass {\n  parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool, attrLen: number, name: string): IAttribute;\n}\n\nexport interface IAttribute {\n  getName(): string;\n}\n\nexport interface IInnerClassInfo {\n  innerInfoIndex: number;\n  outerInfoIndex: number;\n  innerNameIndex: number;\n  innerAccessFlags: number;\n}\n\nexport class ExceptionHandler implements IAttribute {\n  public startPC: number;\n  public endPC: number;\n  public handlerPC: number;\n  public catchType: string;\n  constructor(startPC: number, endPC: number, handlerPC: number, catchType: string) {\n    this.startPC = startPC;\n    this.endPC = endPC;\n    this.handlerPC = handlerPC;\n    this.catchType = catchType;\n  }\n  public getName() {\n    return 'ExceptionHandler';\n  }\n  public static parse(bytesArray: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var startPC = bytesArray.getUint16(),\n      endPC = bytesArray.getUint16(),\n      handlerPC = bytesArray.getUint16(),\n      cti = bytesArray.getUint16(),\n      catchType = cti === 0 ? \"<any>\" : (<ConstantPool.ClassReference> constantPool.get(cti)).name;\n    return new this(startPC, endPC, handlerPC, catchType);\n  }\n}\n\nexport class Code implements IAttribute {\n  private maxStack: number;\n  private maxLocals: number;\n  public exceptionHandlers: ExceptionHandler[];\n  private attrs: IAttribute[];\n  private code: Buffer;\n\n  constructor(maxStack: number, maxLocals: number, exceptionHandlers: ExceptionHandler[], attrs: IAttribute[], code: Buffer) {\n    this.maxStack = maxStack;\n    this.maxLocals = maxLocals;\n    this.exceptionHandlers = exceptionHandlers;\n    this.attrs = attrs;\n    this.code = code;\n  }\n\n  public getName() {\n    return 'Code';\n  }\n\n  public getMaxStack(): number {\n    return this.maxStack;\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var maxStack = byteStream.getUint16(),\n      maxLocals = byteStream.getUint16(),\n      codeLen = byteStream.getUint32();\n    if (codeLen === 0) {\n      throw \"Error parsing code: Code length is zero\";\n    }\n    var code = byteStream.slice(codeLen).getBuffer(),\n      exceptLen = byteStream.getUint16(),\n      exceptionHandlers: ExceptionHandler[] = [];\n    for (var i = 0; i < exceptLen; i++) {\n      exceptionHandlers.push(<ExceptionHandler> ExceptionHandler.parse(byteStream, constantPool));\n    }\n    // yes, there are even attrs on attrs. BWOM... BWOM...\n    var attrs = makeAttributes(byteStream, constantPool);\n    return new this(maxStack, maxLocals, exceptionHandlers, attrs, code);\n  }\n\n  public getCode(): NodeBuffer {\n    return this.code;\n  }\n\n  public getAttribute(name: string): IAttribute {\n    for (var i = 0; i < this.attrs.length; i++) {\n      var attr = this.attrs[i];\n      if (attr.getName() === name) {\n        return attr;\n      }\n    }\n    return null;\n  }\n}\n\nexport interface ILineNumberTableEntry {\n  startPC: number;\n  lineNumber: number;\n}\n\nexport class LineNumberTable implements IAttribute {\n  private entries: ILineNumberTableEntry[];\n\n  constructor(entries: ILineNumberTableEntry[]) {\n    this.entries = entries;\n  }\n\n  public getName() {\n    return 'LineNumberTable';\n  }\n\n  /**\n   * Returns the relevant source code line number for the specified program\n   * counter.\n   */\n  public getLineNumber(pc: number): number {\n    var j: number, lineNumber = -1;\n    // get the last line number before the stack frame's pc\n    for (j = 0; j < this.entries.length; j++) {\n      var entry = this.entries[j];\n      if (entry.startPC <= pc) {\n        lineNumber = entry.lineNumber;\n      } else {\n        // Further entries are past the PC.\n        break;\n      }\n    }\n    return lineNumber;\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var entries: ILineNumberTableEntry[] = [];\n    var lntLen = byteStream.getUint16();\n    for (var i = 0; i < lntLen; i++) {\n      var spc = byteStream.getUint16();\n      var ln = byteStream.getUint16();\n      entries.push({\n        'startPC': spc,\n        'lineNumber': ln\n      });\n    }\n    return new this(entries);\n  }\n}\n\nexport class SourceFile implements IAttribute {\n  public filename: string;\n\n  constructor(filename: string) {\n    this.filename = filename;\n  }\n\n  public getName() {\n    return 'SourceFile';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    return new this((<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value);\n  }\n}\n\nexport interface IStackMapTableEntry {\n  type: enums.StackMapTableEntryType;\n  offsetDelta: number;\n  numLocals?: number;\n  locals?: string[];\n  numStackItems?: number;\n  stack?: string[];\n  k?: number;\n}\n\nexport class StackMapTable implements IAttribute {\n  private entries: IStackMapTableEntry[];\n\n  constructor(entries: IStackMapTableEntry[]) {\n    this.entries = entries;\n  }\n\n  public getName() {\n    return 'StackMapTable';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var numEntries = byteStream.getUint16(),\n      entries: IStackMapTableEntry[] = [];\n    for (var i = 0; i < numEntries; i++) {\n      entries.push(this.parseEntry(byteStream, constantPool));\n    }\n    return new this(entries);\n  }\n\n  private static parseEntry(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IStackMapTableEntry {\n    var frameType = byteStream.getUint8(), locals: string[],\n      offsetDelta: number, i: number;\n    if (frameType < 64) {\n      return {\n        type: enums.StackMapTableEntryType.SAME_FRAME,\n        offsetDelta: frameType\n      };\n    } else if (frameType < 128) {\n      return {\n        type: enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME,\n        offsetDelta: frameType - 64,\n        stack: [this.parseVerificationTypeInfo(byteStream, constantPool)]\n      };\n    } else if (frameType < 247) {\n      // reserved for future use\n    } else if (frameType === 247) {\n      return {\n        type: enums.StackMapTableEntryType.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED,\n        offsetDelta: byteStream.getUint16(),\n        stack: [this.parseVerificationTypeInfo(byteStream, constantPool)]\n      };\n    } else if (frameType < 251) {\n      return {\n        type: enums.StackMapTableEntryType.CHOP_FRAME,\n        offsetDelta: byteStream.getUint16(),\n        k: 251 - frameType\n      };\n    } else if (frameType === 251) {\n      return {\n        type: enums.StackMapTableEntryType.SAME_FRAME_EXTENDED,\n        offsetDelta: byteStream.getUint16()\n      };\n    } else if (frameType < 255) {\n      offsetDelta = byteStream.getUint16();\n      locals = [];\n      for (i = 0; i < frameType - 251; i++) {\n        locals.push(this.parseVerificationTypeInfo(byteStream, constantPool));\n      }\n      return {\n        type: enums.StackMapTableEntryType.APPEND_FRAME,\n        offsetDelta: offsetDelta,\n        locals: locals\n      };\n    } else if (frameType === 255) {\n      offsetDelta = byteStream.getUint16();\n      var numLocals = byteStream.getUint16();\n      locals = [];\n      for (i = 0; i < numLocals; i++) {\n        locals.push(this.parseVerificationTypeInfo(byteStream, constantPool));\n      }\n      var numStackItems = byteStream.getUint16();\n      var stack: string[] = [];\n      for (i = 0; i < numStackItems; i++) {\n        stack.push(this.parseVerificationTypeInfo(byteStream, constantPool));\n      }\n      return {\n        type: enums.StackMapTableEntryType.FULL_FRAME,\n        offsetDelta: offsetDelta,\n        numLocals: numLocals,\n        locals: locals,\n        numStackItems: numStackItems,\n        stack: stack\n      };\n    }\n  }\n\n  private static parseVerificationTypeInfo(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): string {\n    var tag = byteStream.getUint8();\n    if (tag === 7) {\n      var cls = (<ConstantPool.ClassReference> constantPool.get(byteStream.getUint16())).name;\n      return 'class ' + (/\\w/.test(cls[0]) ? util.descriptor2typestr(cls) : \"\\\"\" + cls + \"\\\"\");\n    } else if (tag === 8) {\n      return 'uninitialized ' + byteStream.getUint16();\n    } else {\n      var tagToType = ['bogus', 'int', 'float', 'double', 'long', 'null', 'this', 'object', 'uninitialized'];\n      return tagToType[tag];\n    }\n  }\n}\n\nexport interface ILocalVariableTableEntry {\n  startPC: number;\n  length: number;\n  name: string;\n  descriptor: string;\n  ref: number;\n}\n\nexport class LocalVariableTable implements IAttribute {\n  private entries: ILocalVariableTableEntry[];\n\n  constructor(entries: ILocalVariableTableEntry[]) {\n    this.entries = entries;\n  }\n\n  public getName() {\n    return 'LocalVariableTable';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var numEntries = byteStream.getUint16(),\n      entries: ILocalVariableTableEntry[] = [];\n    for (var i = 0; i < numEntries; i++) {\n      entries.push(this.parseEntries(byteStream, constantPool));\n    }\n    return new this(entries);\n  }\n\n  private static parseEntries(bytes_array: ByteStream, constant_pool: ConstantPool.ConstantPool): ILocalVariableTableEntry {\n    return {\n      startPC: bytes_array.getUint16(),\n      length: bytes_array.getUint16(),\n      name: (<ConstantPool.ConstUTF8> constant_pool.get(bytes_array.getUint16())).value,\n      descriptor: (<ConstantPool.ConstUTF8> constant_pool.get(bytes_array.getUint16())).value,\n      ref: bytes_array.getUint16()\n    };\n  }\n}\n\nexport interface ILocalVariableTypeTableEntry {\n  startPC: number;\n  length: number;\n  name: string;\n  signature: string;\n  index: number;\n}\n\nexport class LocalVariableTypeTable implements IAttribute {\n  public entries: ILocalVariableTypeTableEntry[];\n  constructor(entries: ILocalVariableTypeTableEntry[]) {\n    this.entries = entries;\n  }\n  public getName(): string {\n    return 'LocalVariableTypeTable';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var numEntries = byteStream.getUint16(), i: number,\n      entries: ILocalVariableTypeTableEntry[] = [];\n    for (i = 0; i < numEntries; i++) {\n      entries.push(this.parseTableEntry(byteStream, constantPool));\n    }\n    return new this(entries);\n  }\n\n  private static parseTableEntry(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): ILocalVariableTypeTableEntry {\n    return {\n      startPC: byteStream.getUint16(),\n      length: byteStream.getUint16(),\n      name: (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value,\n      signature: (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value,\n      index: byteStream.getUint16()\n    };\n  }\n}\n\nexport class Exceptions implements IAttribute {\n  public exceptions: string[];\n\n  constructor(exceptions: string[]) {\n    this.exceptions = exceptions;\n  }\n\n  public getName() {\n    return 'Exceptions';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var numExceptions = byteStream.getUint16();\n    var excRefs: number[] = [];\n    for (var i = 0; i < numExceptions; i++) {\n      excRefs.push(byteStream.getUint16());\n    }\n    return new this(excRefs.map((ref: number) => (<ConstantPool.ClassReference> constantPool.get(ref)).name));\n  }\n}\n\nexport class InnerClasses implements IAttribute {\n  public classes: IInnerClassInfo[];\n\n  constructor(classes: IInnerClassInfo[]) {\n    this.classes = classes;\n  }\n\n  public getName() {\n    return 'InnerClasses';\n  }\n\n  public static parse(bytes_array: ByteStream, constant_pool: ConstantPool.ConstantPool): IAttribute {\n    var numClasses = bytes_array.getUint16(),\n      classes: IInnerClassInfo[] = [];\n    for (var i = 0; i < numClasses; i++) {\n      classes.push(this.parseClass(bytes_array, constant_pool));\n    }\n    return new this(classes);\n  }\n\n  public static parseClass(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IInnerClassInfo {\n    return {\n      innerInfoIndex: byteStream.getUint16(),\n      outerInfoIndex: byteStream.getUint16(),\n      innerNameIndex: byteStream.getUint16(),\n      innerAccessFlags: byteStream.getUint16()\n    };\n  }\n}\n\nexport class ConstantValue implements IAttribute {\n  public value: ConstantPool.IConstantPoolItem;\n\n  constructor(value: ConstantPool.IConstantPoolItem) {\n    this.value = value;\n  }\n\n  public getName() {\n    return 'ConstantValue';\n  }\n\n  public static parse(bytes_array: ByteStream, constant_pool: ConstantPool.ConstantPool): IAttribute {\n    var ref = bytes_array.getUint16();\n    return new this(constant_pool.get(ref));\n  }\n}\n\nexport class Synthetic implements IAttribute {\n  public getName() {\n    return 'Synthetic';\n  }\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    return new this();\n  }\n}\n\nexport class Deprecated implements IAttribute {\n  public getName() {\n    return 'Deprecated';\n  }\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    return new this();\n  }\n}\n\nexport class Signature implements IAttribute {\n  public sig: string;\n\n  constructor(sig: string) {\n    this.sig = sig;\n  }\n\n  public getName() {\n    return 'Signature';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    return new this((<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value);\n  }\n}\n\nexport class RuntimeVisibleAnnotations implements IAttribute {\n  public rawBytes: Buffer;\n  public isHidden: boolean;\n  public isCallerSensitive: boolean;\n  public isCompiled: boolean;\n\n  constructor(rawBytes: Buffer, isHidden: boolean, isCallerSensitive: boolean, isCompiled: boolean) {\n    this.rawBytes = rawBytes;\n    this.isHidden = isHidden;\n    this.isCallerSensitive = isCallerSensitive;\n    this.isCompiled = isCompiled;\n  }\n\n  public getName() {\n    return 'RuntimeVisibleAnnotations';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool, attrLen: number): IAttribute {\n    // No need to parse; OpenJDK parses these from within Java code from\n    // the raw bytes.\n    // ...but we need to look for the 'Hidden' annotation, which specifies if\n    // the method should be omitted from stack frames.\n    // And the 'compiled' annotation, which specifies if the method was\n    // compiled.\n    // And the 'CallerSensitive' annotation, which specifies that the function's\n    // behavior differs depending on the caller.\n\n    /**\n     * Skip the current RuntimeVisibleAnnotation.\n     */\n    function skipAnnotation() {\n      byteStream.skip(2); // type index\n      var numValuePairs = byteStream.getUint16(),\n        i: number;\n      for (i = 0; i < numValuePairs; i++) {\n        byteStream.skip(2); // element name index\n        skipElementValue();\n      }\n    }\n\n    /**\n     * Skip this particular element value.\n     */\n    function skipElementValue() {\n      var tag = String.fromCharCode(byteStream.getUint8());\n      switch(tag) {\n        case 'e':\n          // Fall-through.\n          byteStream.skip(2);\n        case 'Z':\n        case 'B':\n        case 'C':\n        case 'S':\n        case 'I':\n        case 'F':\n        case 'J':\n        case 'D':\n        case 's':\n        case 'c':\n          byteStream.skip(2);\n          break;\n        case '@':\n          skipAnnotation();\n          break;\n        case '[':\n          var numValues = byteStream.getUint16(), i: number;\n          for (i = 0; i < numValues; i++) {\n            skipElementValue();\n          }\n          break;\n\n      }\n    }\n\n    var rawBytes = byteStream.read(attrLen),\n      isHidden = false, isCompiled = false, isCallerSensitive = false;\n    byteStream.seek(byteStream.pos() - rawBytes.length);\n    var numAttributes = byteStream.getUint16(), i: number;\n    for (i = 0; i < numAttributes; i++) {\n      var typeName = (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16()));\n      // Rewind.\n      byteStream.seek(byteStream.pos() - 2);\n      skipAnnotation();\n      switch (typeName.value) {\n        case 'Ljava/lang/invoke/LambdaForm$Hidden;':\n          isHidden = true;\n          break;\n        case 'Lsig/sun/reflect/CallerSensitive;':\n          isCallerSensitive = true;\n          break;\n        case 'Lsig/java/lang/invoke/LambdaForm$Compiled':\n          isCompiled = true;\n          break;\n      }\n    }\n\n    return new this(rawBytes, isHidden, isCallerSensitive, isCompiled);\n  }\n}\n\nexport class AnnotationDefault implements IAttribute {\n  public rawBytes: Buffer;\n  constructor(rawBytes: Buffer) {\n    this.rawBytes = rawBytes;\n  }\n\n  public getName() {\n    return 'AnnotationDefault';\n  }\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool, attrLen?: number): IAttribute {\n    return new this(byteStream.read(attrLen));\n  }\n}\n\nexport class EnclosingMethod implements IAttribute {\n  public encClass: ConstantPool.ClassReference;\n  /**\n   * Note: Is NULL if the current class is not immediately enclosed by a method\n   * or a constructor.\n   */\n  public encMethod: ConstantPool.NameAndTypeInfo;\n  constructor(encClass: ConstantPool.ClassReference, encMethod: ConstantPool.NameAndTypeInfo) {\n    this.encClass = encClass;\n    this.encMethod = encMethod;\n  }\n\n  public getName() {\n    return 'EnclosingMethod';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var encClass = (<ConstantPool.ClassReference> constantPool.get(byteStream.getUint16())),\n      methodRef = byteStream.getUint16(), encMethod: ConstantPool.NameAndTypeInfo = null;\n    if (methodRef > 0) {\n      encMethod = <ConstantPool.NameAndTypeInfo> constantPool.get(methodRef);\n      assert(encMethod.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE, \"Enclosing method must be a name and type info.\");\n    }\n    return new this(encClass, encMethod);\n  }\n}\n\nexport class BootstrapMethods implements IAttribute {\n  public bootstrapMethods: Array<[ConstantPool.MethodHandle, ConstantPool.IConstantPoolItem[]]>;\n  constructor(bootstrapMethods: Array<[ConstantPool.MethodHandle, ConstantPool.IConstantPoolItem[]]>) {\n    this.bootstrapMethods = bootstrapMethods;\n  }\n\n  public getName() {\n    return 'BootstrapMethods';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute {\n    var numBootstrapMethods = byteStream.getUint16(),\n      bootstrapMethods: Array<[ConstantPool.MethodHandle, ConstantPool.IConstantPoolItem[]]> = [];\n    for (var i = 0; i < numBootstrapMethods; i++) {\n      var methodHandle = <ConstantPool.MethodHandle> constantPool.get(byteStream.getUint16());\n      var numArgs = byteStream.getUint16();\n      var args: ConstantPool.IConstantPoolItem[] = [];\n      for (var j = 0; j < numArgs; j++) {\n        args.push(constantPool.get(byteStream.getUint16()));\n      }\n      bootstrapMethods.push([methodHandle, args]);\n    }\n    return new this(bootstrapMethods);\n  }\n}\n\nexport class RuntimeVisibleParameterAnnotations implements IAttribute {\n  public rawBytes: Buffer;\n  constructor(rawBytes: Buffer) {\n    this.rawBytes = rawBytes;\n  }\n\n  public getName() {\n    return 'RuntimeVisibleParameterAnnotations';\n  }\n\n  public static parse(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool, attrLen: number): IAttribute {\n    return new this(byteStream.read(attrLen));\n  }\n}\n\nexport function makeAttributes(byteStream: ByteStream, constantPool: ConstantPool.ConstantPool): IAttribute[]{\n  var attrTypes: { [name: string]: IAttributeClass } = {\n    'Code': Code,\n    'LineNumberTable': LineNumberTable,\n    'SourceFile': SourceFile,\n    'StackMapTable': StackMapTable,\n    'LocalVariableTable': LocalVariableTable,\n    'LocalVariableTypeTable': LocalVariableTypeTable,\n    'ConstantValue': ConstantValue,\n    'Exceptions': Exceptions,\n    'InnerClasses': InnerClasses,\n    'Synthetic': Synthetic,\n    'Deprecated': Deprecated,\n    'Signature': Signature,\n    'RuntimeVisibleAnnotations': RuntimeVisibleAnnotations,\n    'AnnotationDefault': AnnotationDefault,\n    'EnclosingMethod': EnclosingMethod,\n    'BootstrapMethods': BootstrapMethods,\n    'RuntimeVisibleParameterAnnotations': RuntimeVisibleParameterAnnotations\n  };\n  var numAttrs = byteStream.getUint16();\n  var attrs : IAttribute[] = [];\n  for (var i = 0; i < numAttrs; i++) {\n    var name = (<ConstantPool.ConstUTF8> constantPool.get(byteStream.getUint16())).value;\n    var attrLen = byteStream.getUint32();\n    if (attrTypes[name] != null) {\n      var oldLen = byteStream.size();\n      var attr = attrTypes[name].parse(byteStream, constantPool, attrLen, name);\n      var newLen = byteStream.size();\n      assert((oldLen - newLen) <= attrLen, `A parsed attribute read beyond its data! ${name}`);\n      if (oldLen - newLen !== attrLen) {\n        byteStream.skip(attrLen - oldLen + newLen);\n      }\n      attrs.push(attr);\n    } else {\n      // we must silently ignore other attrs\n      byteStream.skip(attrLen);\n    }\n  }\n  return attrs;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/attributes.ts\n **/","import threading = require('./threading');\n\n/**\n * Checks the given assertion. Throws an error if it fails.\n */\nfunction assert(assertion: boolean, msg?: string, thread?: threading.JVMThread) {\n  if (!assertion) {\n    throw new Error(`Assertion failed: ${msg}\\n${thread ? thread.getPrintableStackTrace() : ''}`);\n  }\n}\n\nexport = assert;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/assert.ts\n **/","import ClassData = require('./ClassData');\nimport ClassLoader = require('./ClassLoader');\nimport methods = require('./methods');\nimport enums = require('./enums');\nimport assert = require('./assert');\nimport gLong = require('./gLong');\nimport opcodes = require('./opcodes');\nimport attributes = require('./attributes');\nimport logging = require('./logging');\nimport JVM = require('./jvm');\nimport util = require('./util');\nimport ConstantPool = require('./ConstantPool');\nimport JVMTypes = require('../includes/JVMTypes');\nimport Monitor = require('./Monitor');\nimport ThreadStatus = enums.ThreadStatus;\nimport {default as ThreadPool, Thread} from './threadpool';\nimport global = require('./global');\n\ndeclare var RELEASE: boolean;\n\nvar debug = logging.debug, vtrace = logging.vtrace, trace = logging.trace,\n  // The number of method resumes we should allow before yielding for\n  // responsiveness. Updated using a cumulative moving average to ensure\n  // Doppio is responsive.\n  maxMethodResumes: number = 10000,\n  // The number of method resumes until Doppio should yield again.\n  methodResumesLeft: number = maxMethodResumes,\n  // Used for the CMA.\n  numSamples: number = 1;\n\n/**\n * Represents a stack frame.\n */\nexport interface IStackFrame {\n  /**\n   * Runs or resumes the method, as configured.\n   */\n  run: (thread: JVMThread) => void;\n  /**\n   * Configures the method to resume after a method call.\n   * @rv The return value from the method call, if applicable.\n   * @rv2 The second return value, which will always be null if applicable.\n   */\n  scheduleResume: (thread: JVMThread, rv?: any, rv2?: any) => void;\n  /**\n   * Checks if the method can handle the given exception. If so,\n   * configures the stack frame to handle the exception.\n   * @return True if the method can handle the exception.\n   */\n  scheduleException: (thread: JVMThread, e: JVMTypes.java_lang_Throwable) => boolean;\n  /**\n   * This stack frame's type.\n   */\n  type: enums.StackFrameType;\n  /**\n   * Retrieve a stack trace frame from this stack trace. If this stack frame\n   * should not be language-visible, return null.\n   */\n  getStackTraceFrame(): IStackTraceFrame;\n  /**\n   * Retrieve the classloader for this method.\n   */\n  getLoader(): ClassLoader.ClassLoader;\n}\n\nexport class PreAllocatedStack {\n  private store: any[];\n  private curr: number = 0;\n\n  constructor(initialSize: number) {\n    this.store = new Array(initialSize);\n  }\n\n  push(x: any) {\n    this.store[this.curr++] = x;\n  }\n\n  pushAll() {\n    const n = arguments.length;\n    for (let i = 0; i < n; i++) {\n      this.store[this.curr++] = arguments[i];\n    }\n  }\n\n  pushWithNull(x: any) {\n    this.store[this.curr] = x;\n\n    // XXX: Although setting `null` is required in theory, it has no functional impact in practice.\n    // Performance is improved when commented.\n    // this.store[this.curr + 1] = null;\n\n    this.curr += 2;\n  }\n\n  push6(x: any, y: any, z: any, z1: any, z2: any, z3: any) {\n    this.store[this.curr++] = x;\n    this.store[this.curr++] = y;\n    this.store[this.curr++] = z;\n    this.store[this.curr++] = z1;\n    this.store[this.curr++] = z2;\n    this.store[this.curr++] = z3;\n  }\n\n  swap() {\n    const tmp = this.store[this.curr - 1];\n    this.store[this.curr - 1] = this.store[this.curr - 2];\n    this.store[this.curr - 2] = tmp;\n  }\n\n  dup() {\n    this.store[this.curr] = this.store[this.curr - 1];\n    this.curr++;\n  }\n\n  dup2() {\n    this.store[this.curr] = this.store[this.curr - 2];\n    this.store[this.curr + 1] = this.store[this.curr - 1];\n    this.curr += 2;\n  }\n\n  dup_x1() {\n    const v1 = this.store[this.curr - 1];\n\n    this.store[this.curr - 1] = this.store[this.curr - 2];\n    this.store[this.curr] = v1;\n    this.store[this.curr - 2] = v1;\n\n    this.curr++;\n  }\n\n  dup_x2() {\n    const v1 = this.store[this.curr - 1];\n\n    this.store[this.curr - 1] = this.store[this.curr - 2];\n    this.store[this.curr - 2] = this.store[this.curr - 3];\n    this.store[this.curr] = v1;\n    this.store[this.curr - 3] = v1;\n\n    this.curr++;\n  }\n\n  dup2_x1() {\n    const v1 = this.store[this.curr - 1];\n    const v2 = this.store[this.curr - 2];\n\n    this.store[this.curr] = v2;\n    this.store[this.curr + 1] = v1;\n    this.store[this.curr - 1] = this.store[this.curr - 3];\n    this.store[this.curr - 2] = v1;\n    this.store[this.curr - 3] = v2;\n\n    this.curr += 2;\n  }\n\n  pop(): any {\n    return this.store[--this.curr];\n  }\n\n  pop2(): any {\n    this.curr -= 2;\n    return this.store[this.curr];\n  }\n\n  bottom(): any {\n    return this.store[0];\n  }\n\n  top(): any {\n    return this.store[this.curr - 1];\n  }\n\n  fromTop(n: number): any {\n    return this.store[this.curr - (n + 1)];\n  }\n\n  sliceFromBottom(n: number): any {\n    return this.store.slice(n, this.curr);\n  }\n\n  sliceFromTop(n: number): any {\n    return this.store.slice(this.curr - n, this.curr);\n  }\n\n  dropFromTop(n: number) {\n    this.curr -= n;\n  }\n\n  sliceAndDropFromTop(n: number): any {\n    const curr = this.curr;\n    this.curr -= n;\n    return this.store.slice(curr - n, curr);\n  }\n\n  getRaw(): any[] {\n    return this.store.slice(0, this.curr);\n  }\n\n  clear() {\n    this.curr = 0;\n  }\n}\n\nconst jitUtil = {\n  isNull: opcodes.isNull,\n  resolveCPItem: opcodes.resolveCPItem,\n  throwException: opcodes.throwException,\n  gLong: gLong,\n  float2int: util.float2int,\n  wrapFloat: util.wrapFloat,\n  Constants: enums.Constants\n};\n\n/**\n * Represents a stack frame for a bytecode method.\n */\nexport class BytecodeStackFrame implements IStackFrame {\n  public pc: number = 0;\n  public locals: any[];\n  public opStack: PreAllocatedStack;\n  public returnToThreadLoop: boolean = false;\n  public lockedMethodLock: boolean = false;\n  public method: methods.Method;\n\n  /**\n   * Constructs a bytecode method's stack frame.\n   * @param method The bytecode method to run.\n   * @param args The arguments to pass to the bytecode method.\n   */\n  constructor(method: methods.Method, args: any[]) {\n    this.method = method;\n    method.incrBBEntries();\n    assert(!method.accessFlags.isNative(), 'Cannot run a native method using a BytecodeStackFrame.');\n    // @todo This should be a runtime error, since reflection can cause you to\n    // try to do this.\n    assert(!method.accessFlags.isAbstract(), 'Cannot run an abstract method!');\n    this.locals = args;\n    this.opStack = new PreAllocatedStack(method.getCodeAttribute().getMaxStack());\n  }\n\n  public run(thread: JVMThread): void {\n    var method = this.method, code = this.method.getCodeAttribute().getCode(),\n      opcodeTable = opcodes.LookupTable;\n    if (!RELEASE && logging.log_level >= logging.TRACE) {\n      if (this.pc === 0) {\n        trace(`\\nT${thread.getRef()} D${thread.getStackTrace().length} Running ${this.method.getFullSignature()} [Bytecode]:`);\n      } else {\n        trace(`\\nT${thread.getRef()} D${thread.getStackTrace().length} Resuming ${this.method.getFullSignature()}:${this.pc} [Bytecode]:`);\n      }\n      vtrace(`  S: [${logging.debug_vars(this.opStack.getRaw())}], L: [${logging.debug_vars(this.locals)}]`);\n    }\n\n    if (method.accessFlags.isSynchronized() && !this.lockedMethodLock) {\n      // We are starting a synchronized method! These must implicitly enter\n      // their respective locks.\n      this.lockedMethodLock = method.methodLock(thread, this).enter(thread, () => {\n        // Lock succeeded. Set the flag so we don't attempt to reacquire it\n        // when this method reruns.\n        this.lockedMethodLock = true;\n      });\n      if (!this.lockedMethodLock) {\n        // Failed. Thread is automatically blocked. Return.\n        assert(thread.getStatus() === ThreadStatus.BLOCKED, \"Failed to enter a monitor. Thread must be BLOCKED.\");\n        return;\n      }\n    }\n\n    // Reset the returnToThreadLoop switch. The current value is leftover\n    // from the previous time this method was run, and is meaningless.\n    this.returnToThreadLoop = false;\n\n    if (thread.getJVM().isJITDisabled()) {\n      // Interpret until we get the signal to return to the thread loop.\n      while (!this.returnToThreadLoop) {\n        var opCode = code.readUInt8(this.pc);\n        if (!RELEASE && logging.log_level === logging.VTRACE) {\n          vtrace(`  ${this.pc} ${annotateOpcode(op, method, code, this.pc)}`);\n        }\n        opcodeTable[opCode](thread, this, code);\n        if (!RELEASE && !this.returnToThreadLoop && logging.log_level === logging.VTRACE) {\n          vtrace(`    S: [${logging.debug_vars(this.opStack.getRaw())}], L: [${logging.debug_vars(this.locals)}]`);\n        }\n      }\n    } else {\n      // Run until we get the signal to return to the thread loop.\n      while (!this.returnToThreadLoop) {\n        var op = method.getOp(this.pc, code, thread);\n        if (typeof op === 'function') {\n          if (!RELEASE && logging.log_level === logging.VTRACE) {\n            vtrace(`  ${this.pc} running JIT compiled function:\\n${op.toString()}`);\n          }\n          op(this, thread, jitUtil);\n        } else {\n          if (!RELEASE && logging.log_level === logging.VTRACE) {\n            vtrace(`  ${this.pc} ${annotateOpcode(op, method, code, this.pc)}`);\n          }\n          opcodeTable[op](thread, this, code);\n        }\n        if (!RELEASE && !this.returnToThreadLoop && logging.log_level === logging.VTRACE) {\n          vtrace(`    S: [${logging.debug_vars(this.opStack.getRaw())}], L: [${logging.debug_vars(this.locals)}]`);\n        }\n      }\n    }\n  }\n\n  public scheduleResume(thread: JVMThread, rv?: any, rv2?: any): void {\n    // Advance to the next opcode.\n    var prevOp = this.method.getCodeAttribute().getCode().readUInt8(this.pc);\n    switch (prevOp) {\n      case enums.OpCode.INVOKEINTERFACE:\n      case enums.OpCode.INVOKEINTERFACE_FAST:\n        this.pc += 5;\n        break;\n      case enums.OpCode.INVOKESPECIAL:\n      case enums.OpCode.INVOKESTATIC:\n      case enums.OpCode.INVOKEVIRTUAL:\n      case enums.OpCode.INVOKESTATIC_FAST:\n      case enums.OpCode.INVOKENONVIRTUAL_FAST:\n      case enums.OpCode.INVOKEVIRTUAL_FAST:\n      case enums.OpCode.INVOKEHANDLE:\n      case enums.OpCode.INVOKEBASIC:\n      case enums.OpCode.LINKTOSPECIAL:\n      case enums.OpCode.LINKTOVIRTUAL:\n      case enums.OpCode.INVOKEDYNAMIC:\n      case enums.OpCode.INVOKEDYNAMIC_FAST:\n        this.pc += 3;\n        break;\n      default:\n        // Should be impossible.\n        assert(false, `Resuming from a non-invoke opcode! Opcode: ${enums.OpCode[prevOp]} [${prevOp}]`);\n        break;\n    }\n\n    if (rv !== undefined) {\n      this.opStack.push(rv);\n    }\n    if (rv2 !== undefined) {\n      this.opStack.push(rv2);\n    }\n  }\n\n  /**\n   * Checks if this method can handle the specified exception 'e'.\n   * Returns true if it can, or if it needs to asynchronously resolve some\n   * classes.\n   *\n   * In the latter case, scheduleException will handle rethrowing the exception\n   * in the event that it can't actually handle it.\n   */\n  public scheduleException(thread: JVMThread, e: JVMTypes.java_lang_Throwable): boolean {\n    var codeAttr = this.method.getCodeAttribute(),\n      pc = this.pc, method = this.method,\n      // STEP 1: See if we can find an appropriate handler for this exception!\n      exceptionHandlers = codeAttr.exceptionHandlers,\n      ecls = e.getClass(), handler: attributes.ExceptionHandler;\n    for (let i = 0; i < exceptionHandlers.length; i++) {\n      let eh = exceptionHandlers[i];\n      if (eh.startPC <= pc && pc < eh.endPC) {\n        if (eh.catchType === \"<any>\") {\n          handler = eh;\n          break;\n        } else {\n          let resolvedCatchType = method.cls.getLoader().getResolvedClass(eh.catchType);\n          if (resolvedCatchType != null) {\n            if (ecls.isCastable(resolvedCatchType)) {\n              handler = eh;\n              break;\n            }\n          } else {\n            // ASYNC PATH: We'll need to asynchronously resolve these handlers.\n            debug(`${method.getFullSignature()} needs to resolve some exception types...`);\n            let handlerClasses: string[] = [];\n            for (let i = 0; i < exceptionHandlers.length; i++) {\n              let handler = exceptionHandlers[i];\n              if (handler.catchType !== \"<any>\") {\n                handlerClasses.push(handler.catchType);\n              }\n            }\n            debug(`${method.getFullSignature()}: Has to resolve exception classes. Deferring scheduling...`);\n            thread.setStatus(ThreadStatus.ASYNC_WAITING);\n            method.cls.getLoader().resolveClasses(thread, handlerClasses, (classes: { [name: string]: ClassData.ClassData; }) => {\n              if (classes !== null) {\n                debug(`${method.getFullSignature()}: Rethrowing exception to handle!`);\n                // Rethrow the exception to trigger scheduleException again.\n                // @todo If the ClassLoader throws an exception during resolution,\n                // this could result in an infinite loop. Fix would be to sync check\n                // if class failed to load previously.\n                thread.throwException(e);\n              }\n            });\n            // Tell the thread we'll handle it.\n            return true;\n          }\n        }\n      }\n    }\n\n    // STEP 2: Either continue on if we could not find an appropriate handler,\n    // or set up the stack for appropriate resumption.\n    if (handler != null) {\n      // Found the handler.\n      debug(`${method.getFullSignature()}: Caught ${e.getClass().getInternalName()} as subclass of ${handler.catchType}`);\n\n      // clear out anything on the stack; it was made during the try block\n      this.opStack.clear();\n      this.opStack.push(e);\n\n      this.pc = handler.handlerPC;\n      return true;\n    } else {\n      // abrupt method invocation completion\n      debug(`${method.getFullSignature()}: Did not catch ${e.getClass().getInternalName()}.`);\n      // STEP 3: Synchronized method? Exit from the method's monitor.\n      if (method.accessFlags.isSynchronized()) {\n        method.methodLock(thread, this).exit(thread);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Returns the classloader for the stack frame.\n   */\n  public getLoader(): ClassLoader.ClassLoader {\n    return this.method.cls.getLoader();\n  }\n\n  /**\n   * Indicates the type of this stack frame.\n   */\n  public type: enums.StackFrameType = enums.StackFrameType.BYTECODE;\n\n  public getStackTraceFrame(): IStackTraceFrame {\n    return {\n      method: this.method,\n      pc: this.pc,\n      stack: this.opStack.sliceFromBottom(0),\n      locals: this.locals.slice(0)\n    };\n  }\n}\n\n/**\n * Represents a native method's stack frame.\n */\nexport class NativeStackFrame implements IStackFrame {\n  private nativeMethod: Function;\n  public method: methods.Method;\n  private args: any[];\n\n  /**\n   * Constructs a native method's stack frame.\n   * @param method The native method to run.\n   * @param args The arguments to pass to the native method.\n   */\n  constructor(method: methods.Method, args: any[]) {\n    this.method = method;\n    this.args = args;\n    assert(method.accessFlags.isNative());\n    this.nativeMethod = method.getNativeFunction();\n  }\n\n  /**\n   * Calls the native method.\n   * NOTE: Should only be called once.\n   */\n  public run(thread: JVMThread): void {\n    trace(`\\nT${thread.getRef()} D${thread.getStackTrace().length} Running ${this.method.getFullSignature()} [Native]:`);\n    var rv: any = this.nativeMethod.apply(null, this.method.convertArgs(thread, this.args));\n    // Ensure thread is running, and we are the running method.\n    if (thread.getStatus() === ThreadStatus.RUNNABLE && thread.currentMethod() === this.method) {\n      // Normal native method exit.\n      var returnType = this.method.returnType;\n      switch (returnType) {\n        case 'J':\n        case 'D':\n          // Two stack return values for methods that return a long or a double.\n          thread.asyncReturn(rv, null);\n          break;\n        case 'Z':\n          // Convert to a number.\n          thread.asyncReturn(rv ? 1 : 0);\n          break;\n        default:\n          thread.asyncReturn(rv);\n          break;\n      }\n    }\n  }\n\n  /**\n   * N/A\n   */\n  public scheduleResume(thread: JVMThread, rv?: any, rv2?: any): void {\n    // NOP\n  }\n\n  /**\n   * Not relevant; the first execution block of a native method will never\n   * receive an exception.\n   */\n  public scheduleException(thread: JVMThread, e: JVMTypes.java_lang_Throwable): boolean {\n    return false;\n  }\n\n  public type: enums.StackFrameType = enums.StackFrameType.NATIVE;\n\n  public getStackTraceFrame(): IStackTraceFrame {\n    return {\n      method: this.method,\n      pc: -1,\n      stack: [],\n      locals: []\n    };\n  }\n\n  /**\n   * Returns the classloader for the stack frame.\n   */\n  public getLoader(): ClassLoader.ClassLoader {\n    return this.method.cls.getLoader();\n  }\n}\n\n/**\n * InternalStackFrames are used by the JVM to launch JVM functions that\n * eventually call back into JavaScript code when they complete or throw a\n * fatal exception.\n */\nexport class InternalStackFrame implements IStackFrame {\n  private isException: boolean = false;\n  private val: any;\n  private cb: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void;\n\n  /**\n   * @param cb Callback function. Called with an exception if one occurs, or\n   *   the return value from the called method, if relevant.\n   */\n  constructor(cb: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void) {\n    this.cb = cb;\n  }\n\n  public run(thread: JVMThread): void {\n    // Pop myself off of the stack.\n    thread.framePop();\n    // Pause the thread before returning into native JavaScript code.\n    thread.setStatus(ThreadStatus.ASYNC_WAITING);\n    if (this.isException) {\n      this.cb(this.val);\n    } else {\n      this.cb(null, this.val);\n    }\n  }\n\n  /**\n   * Resumes the JavaScript code that created this stack frame.\n   */\n  public scheduleResume(thread: JVMThread, rv?: any): void {\n    this.isException = false;\n    this.val = rv;\n  }\n\n  /**\n   * Resumes the JavaScript code that created this stack frame with the given\n   * exception.\n   */\n  public scheduleException(thread: JVMThread, e: JVMTypes.java_lang_Throwable): boolean {\n    this.isException = true;\n    this.val = e;\n    return true;\n  }\n\n  public type: enums.StackFrameType = enums.StackFrameType.INTERNAL;\n\n  public getStackTraceFrame(): IStackTraceFrame {\n    // These should not be language visible.\n    return null;\n  }\n\n  public getLoader(): ClassLoader.ClassLoader {\n    throw new Error(\"Internal stack frames have no loader.\");\n  }\n}\n\nexport interface IStackTraceFrame {\n  method: methods.Method;\n  pc: number;\n  stack: any[];\n  locals: any[];\n}\n\n/**\n * Represents a single JVM thread.\n */\nexport class JVMThread implements Thread {\n  /**\n   * The current state of this thread, from the JVM level.\n   */\n  private status: ThreadStatus = ThreadStatus.NEW;\n\n  /**\n   * The call stack.\n   */\n  private stack: IStackFrame[] = [];\n\n  /**\n   * Whether or not this thread has been interrupted. It's a JVM thing.\n   */\n  private interrupted: boolean = false;\n\n  /**\n   * If the thread is WAITING, BLOCKED, or TIMED_WAITING, this field holds the\n   * monitor that is involved.\n   */\n  private monitor: Monitor = null;\n  private bsCl: ClassLoader.BootstrapClassLoader;\n  private tpool: ThreadPool<JVMThread>;\n  private jvmThreadObj: JVMTypes.java_lang_Thread;\n  private jvm: JVM;\n\n  /**\n   * Initializes a new JVM thread. Starts the thread in the NEW state.\n   */\n  constructor(jvm: JVM, tpool: ThreadPool<JVMThread>, threadObj: JVMTypes.java_lang_Thread) {\n    this.jvm = jvm;\n    this.bsCl = jvm.getBootstrapClassLoader();\n    this.tpool = tpool;\n    this.jvmThreadObj = threadObj;\n  }\n\n  /**\n   * Get the JVM thread object that represents this thread.\n   */\n  public getJVMObject(): JVMTypes.java_lang_Thread {\n    return this.jvmThreadObj;\n  }\n\n  /**\n   * Is this thread a daemon?\n   */\n  public isDaemon(): boolean {\n    return this.jvmThreadObj['java/lang/Thread/daemon'] !== 0;\n  }\n\n  /**\n   * Get the priority of this thread.\n   */\n  public getPriority(): number {\n    return this.jvmThreadObj['java/lang/Thread/priority'];\n  }\n\n  /**\n   * XXX: Used during bootstrapping to set the first thread's Thread object.\n   */\n  public setJVMObject(obj: JVMTypes.java_lang_Thread): void {\n    obj['java/lang/Thread/threadStatus'] = this.jvmThreadObj['java/lang/Thread/threadStatus'];\n    this.jvmThreadObj = obj;\n  }\n\n  /**\n   * Return the reference number for this thread.\n   */\n  public getRef(): number {\n    return this.jvmThreadObj.ref;\n  }\n\n  /**\n   * Check if this thread's interrupted flag is set.\n   */\n  public isInterrupted(): boolean {\n    return this.interrupted;\n  }\n\n  /**\n   * Returns the currently running method. Returns NULL if stack is empty.\n   */\n  public currentMethod(): methods.Method {\n    var stack = this.stack, idx = stack.length, method: methods.Method;\n    while (--idx >= 0) {\n      method = stack[idx].getStackTraceFrame().method;\n      if (method !== null) {\n        return method;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set or unset this thread's interrupted flag.\n   */\n  public setInterrupted(interrupted: boolean): void {\n    this.interrupted = interrupted;\n  }\n\n  /**\n   * Retrieve the bootstrap classloader.\n   */\n  public getBsCl(): ClassLoader.BootstrapClassLoader {\n    return this.bsCl;\n  }\n\n  /**\n   * Get the classloader for the current frame.\n   */\n  public getLoader(): ClassLoader.ClassLoader {\n    let loader = this.stack[this.stack.length - 1].getLoader();\n    if (loader) {\n      return loader;\n    } else {\n      // Crawl stack until we find one.\n      let len = this.stack.length;\n      for (let i = 2; i <= len; i++) {\n        loader = this.stack[len - i].getLoader();\n        if (loader) {\n          return loader;\n        }\n      }\n      throw new Error(`Unable to find loader.`);\n    }\n  }\n\n  /**\n   * Imports & initializes the given Java class or classes. Returns the JavaScript\n   * object that represents the class -- e.g. contains static methods\n   * and fields.\n   *\n   * If multiple names are specified, it returns an array of class objects.\n   *\n   * If there is an error resolving or initializing any class, it will\n   * throw an exception without invoking your callback.\n   */\n  public import<T>(name: string, cb: (rv?: T) => void, explicit?: boolean): void;\n  public import<T>(names: string[], cb: (rv?: T) => void, explicit?: boolean): void;\n  public import<T>(names: string | string[], cb: (rv?: T) => void, explicit: boolean = true): void {\n    let loader = this.getLoader();\n    this.setStatus(ThreadStatus.ASYNC_WAITING);\n    if (Array.isArray(names)) {\n      let rv: ClassData.IJVMConstructor<any>[] = [];\n      util.asyncForEach(names, (name, nextItem) => {\n        this._import(name, loader, (cons) => {\n          rv.push(cons);\n          nextItem();\n        }, explicit);\n      }, (e?: any) => {\n        cb(<T> <any> rv);\n      });\n    } else {\n      this._import(names, loader, <any> cb, explicit);\n    }\n  }\n\n  private _import(name: string, loader: ClassLoader.ClassLoader, cb: (rv?: ClassData.IJVMConstructor<any>) => void, explicit: boolean): void {\n    let cls = <ClassData.ReferenceClassData<any>> loader.getInitializedClass(this, name);\n    if (cls) {\n      setImmediate(() => cb(cls.getConstructor(this)));\n    } else {\n      loader.initializeClass(this, name, (cdata: ClassData.ReferenceClassData<any>) => {\n        if (cdata) {\n          cb(cdata.getConstructor(this));\n        }\n      }, explicit);\n    }\n  }\n\n  /**\n   * Retrieve the JVM instantiation that this thread belongs to.\n   */\n  public getJVM(): JVM {\n    return this.jvm;\n  }\n\n  /**\n   * Retrieve the thread pool that this thread belongs to.\n   */\n  public getThreadPool(): ThreadPool<JVMThread> {\n    return this.tpool;\n  }\n\n  /**\n   * Retrieves the current stack trace.\n   */\n  public getStackTrace(): IStackTraceFrame[] {\n    var trace: IStackTraceFrame[] = [], i: number,\n      frame: IStackTraceFrame;\n    for (i = 0; i < this.stack.length; i++) {\n      frame = this.stack[i].getStackTraceFrame();\n      if (frame != null) {\n        trace.push(frame);\n      }\n    }\n    return trace;\n  }\n\n  /**\n   * [DEBUG] Return a printable string of the thread's current stack trace.\n   */\n  public getPrintableStackTrace(): string {\n    var rv: string = \"\";\n    this.getStackTrace().reverse().forEach((trace: IStackTraceFrame) => {\n      rv += `\\tat ${util.ext_classname(trace.method.cls.getInternalName())}::${trace.method.name}(`;\n      if (trace.pc >= 0) {\n        // Bytecode method\n        var code = trace.method.getCodeAttribute();\n        var table = <attributes.LineNumberTable> code.getAttribute('LineNumberTable');\n        var srcAttr = <attributes.SourceFile> trace.method.cls.getAttribute('SourceFile');\n        if (srcAttr != null) {\n          rv += srcAttr.filename;\n        } else {\n          rv += 'unknown';\n        }\n        if (table != null) {\n          var lineNumber = table.getLineNumber(trace.pc);\n          rv += `:${lineNumber}`;\n          rv += ` Bytecode offset: ${trace.pc}`;\n        }\n      } else {\n        // Native method.\n        rv += \"native\";\n      }\n      rv += \")\\n\";\n    });\n    return rv;\n  }\n\n  /**\n   * The thread's main execution loop. Everything starts here!\n   *\n   * SHOULD ONLY BE INVOKED BY THE SCHEDULER.\n   */\n  public run(): void {\n    var stack = this.stack,\n      startTime: number = (new Date()).getTime();\n\n    // Reset counter. Threads always start from a fresh stack / yield.\n    methodResumesLeft = maxMethodResumes;\n    while (this.status === ThreadStatus.RUNNABLE && stack.length > 0) {\n      const sf = stack[stack.length - 1];\n      if (!RELEASE) {\n        if (sf.type === enums.StackFrameType.BYTECODE && this.jvm.shouldVtrace((<BytecodeStackFrame> sf).method.fullSignature)) {\n          var oldLevel = logging.log_level;\n          logging.log_level = logging.VTRACE;\n          sf.run(this);\n          logging.log_level = oldLevel;\n        } else {\n          sf.run(this);\n        }\n      } else {\n        sf.run(this);\n      }\n      if (--methodResumesLeft === 0) {\n        const endTime = (new Date()).getTime();\n        const duration = endTime - startTime;\n        // Estimated number of methods we can resume before needing to yield.\n        const estMaxMethodResumes = ((maxMethodResumes / duration) * this.jvm.getResponsiveness()) | 0;\n        // Update CMA.\n        maxMethodResumes = ((estMaxMethodResumes + numSamples * maxMethodResumes) / (numSamples + 1)) | 0;\n        if (maxMethodResumes <= 0) {\n          // Sanity check. Should never really occur.\n          maxMethodResumes = 10;\n        }\n        vtrace(`T${this.getRef()} Quantum over. Method resumes: Max ${maxMethodResumes} Est ${estMaxMethodResumes} Samples ${numSamples}`);\n        numSamples++;\n        // Tell the scheduler that our quantum is over.\n        this.tpool.quantumOver(this);\n        // Break out of while loop.\n        break;\n      }\n    }\n\n    if (stack.length === 0) {\n      // This thread has finished!\n      this.setStatus(ThreadStatus.TERMINATED);\n    }\n  }\n\n  /**\n   * [DEBUG] Performs a sanity check on the thread.\n   */\n  private sanityCheck(): boolean {\n    switch (this.status) {\n      case ThreadStatus.NEW:\n        return true;\n      case ThreadStatus.RUNNABLE:\n        assert(this.stack.length > 0, 'A runnable thread must not have an empty stack.');\n        return true;\n      case ThreadStatus.TIMED_WAITING:\n        assert(this.monitor != null && this.monitor.isTimedWaiting(this), 'A timed waiting thread must be waiting on a monitor.');\n        return true;\n      case ThreadStatus.WAITING:\n        assert(this.monitor != null && this.monitor.isWaiting(this), \"A waiting thread must be waiting on a monitor.\");\n        return true;\n      case ThreadStatus.BLOCKED:\n      case ThreadStatus.UNINTERRUPTABLY_BLOCKED:\n        assert(this.monitor != null && this.monitor.isBlocked(this), \"A blocked thread must be blocked on a monitor\");\n        return true;\n      case ThreadStatus.ASYNC_WAITING:\n        return true;\n      case ThreadStatus.TERMINATED:\n        assert(this.stack.length === 0, \"A terminated thread must have an empty stack.\");\n        return true;\n      case ThreadStatus.PARKED:\n        assert(this.jvm.getParker().isParked(this), \"A parked thread must be parked.\");\n        return true;\n      default:\n        // Invalid ThreadStatus.\n        return false;\n    }\n  }\n\n  /**\n   * Should only be called by setStatus.\n   * Updates both the JVMThread object and this object.\n   */\n  private rawSetStatus(newStatus: ThreadStatus): void {\n    var jvmNewStatus: number = 0, oldStatus = this.status;\n\n    if (logging.log_level === logging.VTRACE) {\n      vtrace(`\\nT${this.getRef()} ${ThreadStatus[oldStatus]} => ${ThreadStatus[newStatus]}`);\n    }\n    assert(validateThreadTransition(oldStatus, newStatus), `Invalid thread transition: ${ThreadStatus[oldStatus]} => ${ThreadStatus[newStatus]}`);\n\n    this.status = newStatus;\n    // Map our status value back to JVM's threadStatus value.\n    // Ensures that JVM code can introspect on our threads.\n    switch (newStatus) {\n      case ThreadStatus.NEW:\n        jvmNewStatus |= enums.JVMTIThreadState.ALIVE;\n        break;\n      case ThreadStatus.RUNNABLE:\n        jvmNewStatus |= enums.JVMTIThreadState.RUNNABLE;\n        break;\n      case ThreadStatus.BLOCKED:\n      case ThreadStatus.UNINTERRUPTABLY_BLOCKED:\n        jvmNewStatus |= enums.JVMTIThreadState.BLOCKED_ON_MONITOR_ENTER;\n        break;\n      case ThreadStatus.WAITING:\n      case ThreadStatus.ASYNC_WAITING:\n      case ThreadStatus.PARKED:\n        jvmNewStatus |= enums.JVMTIThreadState.WAITING_INDEFINITELY;\n        break;\n      case ThreadStatus.TIMED_WAITING:\n        jvmNewStatus |= enums.JVMTIThreadState.WAITING_WITH_TIMEOUT;\n        break;\n      case ThreadStatus.TERMINATED:\n        jvmNewStatus |= enums.JVMTIThreadState.TERMINATED;\n        break;\n      default:\n        jvmNewStatus = enums.JVMTIThreadState.RUNNABLE;\n        break;\n    }\n\n    this.jvmThreadObj['java/lang/Thread/threadStatus'] = jvmNewStatus;\n    this.tpool.statusChange(this, oldStatus, this.status);\n  }\n\n  /**\n   * Transitions the thread from one state to the next.\n   * Contains JVM-specific thread logic.\n   */\n  public setStatus(status: ThreadStatus, monitor: Monitor = null): void {\n    if (this.status !== status) {\n      let oldStatus = this.status;\n\n      // Update the monitor.\n      this.monitor = monitor;\n\n      if (status !== ThreadStatus.TERMINATED) {\n        // Actually change state.\n        this.rawSetStatus(status);\n      } else {\n        // Call exit() first.\n        this.exit();\n      }\n\n      // Validate current state (debug builds only)\n      assert(this.sanityCheck(), `Invalid thread status.`);\n    }\n  }\n\n  /**\n   * Called when a thread finishes executing.\n   */\n  private exit(): void {\n    var monitor: Monitor = this.jvmThreadObj.getMonitor();\n    if (monitor.isBlocked(this) || monitor.getOwner() === this || this.status === ThreadStatus.TERMINATED) {\n      // Thread is already shutting down.\n      return;\n    }\n\n    if (this.stack.length === 0) {\n      // De-schedule thread.\n      this.setStatus(ThreadStatus.ASYNC_WAITING);\n      // Only applicable if it's not an early death, e.g. before VM bootup.\n      if (this.jvm.hasVMBooted()) {\n        trace(`T${this.getRef()} Exiting.`);\n        var phase2 = () => {\n            trace(`T${this.getRef()} Entered exit monitor.`);\n            // Exit.\n            this.jvmThreadObj[\"exit()V\"](this, null, (e?) => {\n              // Notify everyone.\n              monitor.notifyAll(this);\n              // Exit monitor.\n              monitor.exit(this);\n              trace(`T${this.getRef()} Terminated.`);\n              // Actually become terminated.\n              this.rawSetStatus(ThreadStatus.TERMINATED);\n            });\n          };\n\n        // Acquire the monitor associated with our JavaObject.\n        if (monitor.enter(this, phase2)) {\n          phase2();\n        }\n      } else {\n        trace(`T${this.getRef()} Not exiting; VM is still booting.`);\n      }\n    } else {\n      // There are things on the stack. This exit is occuring before the stack has emptied.\n      // Clear the stack, set to terminated.\n      while (this.stack.length > 0) {\n        this.stack.pop();\n      }\n      trace(`T${this.getRef()} Terminated.`);\n      this.rawSetStatus(ThreadStatus.TERMINATED);\n    }\n  }\n\n  /**\n   * Called when the priority of the thread changes.\n   * Should only be called by java.lang.setPriority0.\n   */\n  public signalPriorityChange(): void {\n    this.tpool.priorityChange(this);\n  }\n\n  /**\n   * Get the monitor that this thread is waiting or blocked on.\n   */\n  public getMonitorBlock(): Monitor {\n    return this.monitor;\n  }\n\n  /**\n   * Get the thread's current state.\n   */\n  public getStatus(): ThreadStatus {\n    return this.status;\n  }\n\n  /**\n   * Returns from the currently executing method with the given return value.\n   * Used by asynchronous native methods.\n   *\n   * Causes the following state transition:\n   * * RUNNING => RUNNABLE\n   * * RUNNABLE => RUNNABLE\n   * * ASYNC_WAITING => RUNNABLE\n   *\n   * It is not valid to call this method if the thread is in any other state.\n   */\n  public asyncReturn(): void;\n  public asyncReturn(rv: number): void;\n  public asyncReturn(rv: JVMTypes.java_lang_Object): void;\n  public asyncReturn(rv: number, rv2: any): void;\n  public asyncReturn(rv: gLong, rv2: any): void;\n  public asyncReturn(rv?: any, rv2?: any): void {\n    var stack = this.stack;\n    assert(this.status === ThreadStatus.RUNNABLE || this.status === ThreadStatus.ASYNC_WAITING);\n    assert(typeof (rv) !== 'boolean' && rv2 == null);\n    // Pop off the current method.\n    var frame = stack.pop();\n    if (frame.type != enums.StackFrameType.INTERNAL) {\n      var frameCast = <BytecodeStackFrame> frame;\n      if (frame.type === enums.StackFrameType.BYTECODE) {\n        // This line will be preceded by a line that prints the method, so can be short n' sweet.\n        trace(`  Returning: ${logging.debug_var(rv)}`);\n      }\n\n      trace(`\\nT${this.getRef()} D${this.getStackTrace().length + 1} Returning value from ${frameCast.method.getFullSignature()} [${frameCast.method.accessFlags.isNative() ? 'Native' : 'Bytecode'}]: ${logging.debug_var(rv)}`);\n      assert(validateReturnValue(this, frameCast.method,\n        frameCast.method.returnType, this.bsCl,\n        frameCast.method.cls.getLoader(), rv, rv2), `Invalid return value for method ${frameCast.method.getFullSignature()}`);\n    }\n    // Tell the top of the stack that this RV is waiting for it.\n    var idx: number = stack.length - 1;\n    // If idx is 0, then the thread will TERMINATE next time it enters its main\n    // loop.\n    if (idx >= 0) {\n      stack[idx].scheduleResume(this, rv, rv2);\n    }\n\n    // Thread state transition.\n    this.setStatus(ThreadStatus.RUNNABLE);\n  }\n\n  /**\n   * Pops the top stackframe off of the call stack.\n   * WARNING: SHOULD ONLY BE CALLED BY InternalStackFrame.run()!\n   */\n  public framePop(): void {\n    this.stack.pop();\n  }\n\n  /**\n   * Throws the given JVM exception. Causes the thread to unwind the stack until\n   * it can find a stack frame that can handle the exception.\n   *\n   * Causes the following state transition:\n   * * RUNNING => RUNNABLE\n   * * RUNNABLE => RUNNABLE\n   * * ASYNC_WAITING => RUNNABLE\n   *\n   * Or, if the exception is uncaught, one of the following transitions:\n   * * RUNNING => TERMINATED\n   * * RUNNABLE => TERMINATED\n   * * ASYNC_WAITING => TERMINATED\n   *\n   * It is not valid to call this method if the thread is in any other state.\n   */\n  public throwException(exception: JVMTypes.java_lang_Throwable): void {\n    assert(this.status === ThreadStatus.RUNNABLE || this.status === ThreadStatus.ASYNC_WAITING,\n      `Tried to throw exception while thread was in state ${ThreadStatus[this.status]}`);\n    var stack = this.stack, idx: number = stack.length - 1;\n\n    // Stack may actually be empty, so guard against this.\n    if (idx >= 0) {\n      // An internal stack frame cannot process its own thrown exception.\n      if (stack[idx].type === enums.StackFrameType.INTERNAL) {\n        stack.pop();\n        idx--;\n      }\n\n      // Find a stack frame that can handle the exception.\n      // Set our status *before* scheduling the exception. Some exception handlers\n      // may want to do something asynchronous before resuming execution.\n      this.setStatus(ThreadStatus.RUNNABLE);\n      while (stack.length > 0 && !stack[idx].scheduleException(this, exception)) {\n        stack.pop();\n        idx--;\n      }\n    }\n\n    if (stack.length === 0) {\n      // Uncaught exception!\n      this.handleUncaughtException(exception);\n    }\n  }\n\n  /**\n   * Construct a new exception object of the given class with the given message.\n   * Convenience function for native JavaScript code.\n   * @param clsName Name of the class (e.g. \"Ljava/lang/Throwable;\")\n   * @param msg The message to include with the exception.\n   */\n  public throwNewException<T extends JVMTypes.java_lang_Throwable>(clsName: string, msg: string) {\n    var cls = <ClassData.ReferenceClassData<T>> this.getLoader().getInitializedClass(this, clsName),\n      throwException = () => {\n        var eCons = cls.getConstructor(this),\n          e = new eCons(this);\n\n        // Construct the exception, and throw it when done.\n        e['<init>(Ljava/lang/String;)V'](this, [util.initString(this.bsCl, msg)], (err?: JVMTypes.java_lang_Throwable) => {\n          if (err) {\n            this.throwException(err);\n          } else {\n            this.throwException(e);\n          }\n        });\n      };\n    if (cls != null) {\n      // No initialization required.\n      throwException();\n    } else {\n      // Initialization required.\n      this.setStatus(ThreadStatus.ASYNC_WAITING);\n      this.getLoader().initializeClass(this, clsName, (cdata: ClassData.ReferenceClassData<T>) => {\n        if (cdata != null) {\n          cls = cdata;\n          throwException();\n        }\n      }, false);\n    }\n  }\n\n  /**\n   * Handles an uncaught exception on a thread.\n   */\n  public handleUncaughtException(exception: JVMTypes.java_lang_Throwable) {\n    this.jvmThreadObj['dispatchUncaughtException(Ljava/lang/Throwable;)V'](this, [exception]);\n  }\n\n  public close() {\n    this.jvm = null;\n  }\n}\n\n/**\n * [DEBUG] Stores all of the valid thread transitions.\n * @todo Any way to make this smaller?\n * @todo Move into 'debug' module that we NOP out in release builds.\n */\nexport var validTransitions: { [oldStatus: number]: { [newStatus: number]: string } } = {};\nvalidTransitions[ThreadStatus.NEW] = {};\nvalidTransitions[ThreadStatus.NEW][ThreadStatus.RUNNABLE] = \"RunMethod invoked on new thread\";\nvalidTransitions[ThreadStatus.NEW][ThreadStatus.ASYNC_WAITING] = \"[JVM bootup only] Internal operation occurs on new thread\";\nvalidTransitions[ThreadStatus.NEW][ThreadStatus.TERMINATED] = \"[JVM halt0 only] When the JVM shuts down, it terminates all threads, including those that have never been run.\";\nvalidTransitions[ThreadStatus.ASYNC_WAITING] = {};\nvalidTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.RUNNABLE] = \"Async operation completes\";\nvalidTransitions[ThreadStatus.ASYNC_WAITING][ThreadStatus.TERMINATED] = \"RunMethod completes and callstack is empty\";\nvalidTransitions[ThreadStatus.BLOCKED] = {};\nvalidTransitions[ThreadStatus.BLOCKED][ThreadStatus.RUNNABLE] = \"Acquires monitor, or is interrupted\";\nvalidTransitions[ThreadStatus.BLOCKED][ThreadStatus.TERMINATED] = \"Thread is terminated whilst blocked.\";\nvalidTransitions[ThreadStatus.PARKED] = {};\nvalidTransitions[ThreadStatus.PARKED][ThreadStatus.ASYNC_WAITING] = \"Balancing unpark, or is interrupted\";\nvalidTransitions[ThreadStatus.PARKED][ThreadStatus.TERMINATED] = \"Thread is terminated whilst parked.\";\nvalidTransitions[ThreadStatus.RUNNABLE] = {};\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.ASYNC_WAITING] = \"Thread performs an asynchronous JavaScript operation\";\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TERMINATED] = \"Callstack is empty\";\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.BLOCKED] = \"Thread waits to acquire monitor\";\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.WAITING] = \"Thread waits on monitor (Object.wait)\";\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.TIMED_WAITING] = \"Thread waits on monitor with timeout (Object.wait)\";\nvalidTransitions[ThreadStatus.RUNNABLE][ThreadStatus.PARKED] = \"Thread parks itself\";\nvalidTransitions[ThreadStatus.TERMINATED] = {};\nvalidTransitions[ThreadStatus.TERMINATED][ThreadStatus.NEW] = \"Thread is resurrected for re-use\";\nvalidTransitions[ThreadStatus.TERMINATED][ThreadStatus.RUNNABLE] = \"Thread is resurrected for re-use\";\nvalidTransitions[ThreadStatus.TERMINATED][ThreadStatus.ASYNC_WAITING] = \"[JVM Bootup] Thread is resurrected for internal operation\";\nvalidTransitions[ThreadStatus.TIMED_WAITING] = {};\nvalidTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.RUNNABLE] = \"Timer expires, or thread is interrupted, and thread immediately acquires lock\";\nvalidTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED] = \"Thread is interrupted or notified, or timer expires, and lock already owned\";\nvalidTransitions[ThreadStatus.TIMED_WAITING][ThreadStatus.TERMINATED] = \"Thread is terminated whilst waiting.\";\nvalidTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED] = {};\nvalidTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.RUNNABLE] = \"Thread acquires monitor\";\nvalidTransitions[ThreadStatus.UNINTERRUPTABLY_BLOCKED][ThreadStatus.TERMINATED] = \"Thread is terminated whilst blocked.\";\nvalidTransitions[ThreadStatus.WAITING] = {};\nvalidTransitions[ThreadStatus.WAITING][ThreadStatus.RUNNABLE] = \"Thread is interrupted, and immediately acquires lock\";\nvalidTransitions[ThreadStatus.WAITING][ThreadStatus.UNINTERRUPTABLY_BLOCKED] = \"Thread is notified or interrupted, and does not immediately acquire lock\";\nvalidTransitions[ThreadStatus.WAITING][ThreadStatus.TERMINATED] = \"Thread is terminated whilst waiting.\";\n\n/**\n * [DEBUG] Ensures that a thread transition is legal.\n */\nfunction validateThreadTransition(oldStatus: ThreadStatus, newStatus: ThreadStatus): boolean {\n  var rv = validTransitions.hasOwnProperty(\"\" + oldStatus) &&\n    validTransitions[oldStatus].hasOwnProperty(\"\" + newStatus);\n  return rv;\n}\n\n/**\n * [DEBUG] Asserts that the return value of the function passes basic sanity\n * checks.\n */\nfunction validateReturnValue(thread: JVMThread, method: methods.Method, returnType: string, bsCl: ClassLoader.BootstrapClassLoader, cl: ClassLoader.ClassLoader, rv1: any, rv2: any): boolean {\n  // invokeBasic is typed with an Object return value, but it can return any\n  // damn type it wants, primitive or no.\n  if (method.fullSignature === \"java/lang/invoke/MethodHandle/invokeBasic([Ljava/lang/Object;)Ljava/lang/Object;\") {\n    return true;\n  }\n\n  var cls: ClassData.ClassData;\n  if (util.is_primitive_type(returnType)) {\n    switch (returnType) {\n      case 'Z': // Boolean\n        assert(rv2 === undefined, \"Second return value must be undefined for Boolean type.\");\n        assert(rv1 === 1 || rv1 === 0, \"Booleans must be 0 or 1.\");\n        break;\n      case 'B': // Byte\n        assert(rv2 === undefined, \"Second return value must be undefined for Byte type.\");\n        assert(rv1 <= 127 && rv1 >= -128, `Byte value for method ${method.name} is out of bounds: ${rv1}`);\n        break;\n      case 'C':\n        assert(rv2 === undefined, \"Second return value must be undefined for Character type.\");\n        assert(rv1 <= 65535 && rv1 >= 0, `Character value is out of bounds: ${rv1}`);\n        break;\n      case 'S':\n        assert(rv2 === undefined, \"Second return value must be undefined for Short type.\");\n        assert(rv1 <= 32767 && rv1 >= -32768, `Short value is out of bounds: ${rv1}`);\n        break;\n      case 'I': // int\n        assert(rv2 === undefined, \"Second return value must be undefined for Int type.\");\n        assert(rv1 <= 2147483647 && rv1 >= -2147483648, `Int value is out of bounds: ${rv1}`);\n        break;\n      case 'J': // long //-9223372036854775808 to 9223372036854775807\n        assert(rv2 === null, \"Second return value must be NULL for Long type.\");\n        assert((<gLong> rv1).lessThanOrEqual(gLong.MAX_VALUE) && (<gLong> rv1).greaterThanOrEqual(gLong.MIN_VALUE), `Long value is out of bounds: ${rv1}`);\n        break;\n      case 'F': // Float\n        assert(rv2 === undefined, \"Second return value must be undefined for Float type.\");\n        // NaN !== NaN, so we have to have a special case here.\n        assert(util.wrapFloat(rv1) === rv1 || (isNaN(rv1) && isNaN(util.wrapFloat(rv1))), `Float value is out of bounds: ${rv1}`);\n        break;\n      case 'D': // Double\n        assert(rv2 === null, \"Second return value must be NULL for Double type.\");\n        assert(typeof rv1 === 'number', `Invalid double value: ${rv1}`);\n        break;\n      case 'V':\n        assert(rv1 === undefined && rv2 === undefined, \"Return values must be undefined for Void type\");\n        break;\n    }\n  } else if (util.is_array_type(returnType)) {\n    assert(rv2 === undefined, \"Second return value must be undefined for array type.\");\n    assert(rv1 === null || (typeof rv1 === 'object' && typeof rv1['getClass'] === 'function'), `Invalid array object: ${rv1}`);\n    if (rv1 != null) {\n      cls = assertClassInitializedOrResolved(thread, cl, returnType, true);\n      assert(rv1.getClass().isCastable(cls), `Return value of type ${rv1.getClass().getInternalName()} unable to be cast to return type ${returnType}.`);\n    }\n  } else {\n    assert(util.is_reference_type(returnType), `Invalid reference type: ${returnType}`);\n    assert(rv2 === undefined, `Second return value must be undefined for reference type.`);\n    // All objects and arrays are instances of java/lang/Object.\n    assert(rv1 === null || rv1 instanceof (<ClassData.ReferenceClassData<JVMTypes.java_lang_Object>> bsCl.getInitializedClass(thread, 'Ljava/lang/Object;')).getConstructor(thread), `Reference return type must be an instance of Object; value: ${rv1}`);\n    if (rv1 != null) {\n      cls = assertClassInitializedOrResolved(thread, cl, returnType, false);\n      if (!cls.accessFlags.isInterface()) {\n        // You can return an interface type without initializing it,\n        // since they don't need to be initialized until you try to\n        // invoke one of their methods.\n        // NOTE: We don't check if the class is in the INITIALIZED state,\n        // since it is possible that it is currently in the process of being\n        // initialized. getInitializedClass handles this subtlety.\n        assertClassInitializedOrResolved(thread, cl, returnType, true);\n      }\n      assert(rv1.getClass().isCastable(cls), `Unable to cast ${rv1.getClass().getInternalName()} to ${returnType}.`);\n    }\n  }\n  return true;\n}\n\nfunction assertClassInitializedOrResolved(thread: JVMThread, cl: ClassLoader.ClassLoader, type: string, initialized: boolean): ClassData.ClassData {\n  var cls: ClassData.ClassData = null;\n  // Break out of loop once class is found.\n  while (cls === null) {\n    cls = initialized ? cl.getInitializedClass(thread, type) : cl.getResolvedClass(type);\n    if (cl.getLoaderObject() !== null) {\n      if (cl.getLoaderObject()['java/lang/ClassLoader/parent'] === null) {\n        cl = thread.getBsCl();\n      } else {\n        cl = cl.getLoaderObject()['java/lang/ClassLoader/parent'].$loader;\n      }\n    } else {\n      // We just checked the bootstrap classloader, so we reached the root.\n      assert(cls !== null, `Unable to get initialized class for type ${type}.`);\n    }\n  }\n  return cls;\n}\n\nfunction printConstantPoolItem(cpi: ConstantPool.IConstantPoolItem): string {\n  switch (cpi.getType()) {\n    case enums.ConstantPoolItemType.METHODREF:\n      var cpiMR = <ConstantPool.MethodReference> cpi;\n      return util.ext_classname(cpiMR.classInfo.name) + \".\" + cpiMR.signature;\n    case enums.ConstantPoolItemType.INTERFACE_METHODREF:\n      var cpiIM = <ConstantPool.InterfaceMethodReference> cpi;\n      return util.ext_classname(cpiIM.classInfo.name) + \".\" + cpiIM.signature;\n    case enums.ConstantPoolItemType.FIELDREF:\n      var cpiFR = <ConstantPool.FieldReference> cpi;\n      return util.ext_classname(cpiFR.classInfo.name) + \".\" + cpiFR.nameAndTypeInfo.name + \":\" + util.ext_classname(cpiFR.nameAndTypeInfo.descriptor);\n    case enums.ConstantPoolItemType.NAME_AND_TYPE:\n      var cpiNAT = <ConstantPool.NameAndTypeInfo> cpi;\n      return cpiNAT.name + \":\" + cpiNAT.descriptor;\n    case enums.ConstantPoolItemType.CLASS:\n      var cpiClass = <ConstantPool.ClassReference> cpi;\n      return util.ext_classname(cpiClass.name);\n    default:\n      return logging.debug_var((<any> cpi).value);\n  }\n}\n\n// TODO: Prefix behind DEBUG, cache lowercase opcode names.\nexport var OpcodeLayoutPrinters: {[layoutAtom: number]: (method: methods.Method, code: NodeBuffer, pc: number) => string} = {};\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.OPCODE_ONLY] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase();\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + printConstantPoolItem(method.cls.constantPool.get(code.readUInt16BE(pc + 1)));\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_UINT8] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + printConstantPoolItem(method.cls.constantPool.get(code.readUInt8(pc + 1)));\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.CONSTANT_POOL_AND_UINT8_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + printConstantPoolItem(method.cls.constantPool.get(code.readUInt16BE(pc + 1))) + \" \" + code.readUInt8(pc + 3);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + code.readUInt8(pc + 1);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.UINT8_AND_INT8_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + code.readUInt8(pc + 1) + \" \" + code.readInt8(pc + 2);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.INT8_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + code.readInt8(pc + 1);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.INT16_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + code.readInt16BE(pc + 1);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.INT32_VALUE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + code.readInt32BE(pc + 1);\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.ARRAY_TYPE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase() + \" \" + opcodes.ArrayTypes[code.readUInt8(pc + 1)];\nOpcodeLayoutPrinters[enums.OpcodeLayoutType.WIDE] = (method: methods.Method, code: NodeBuffer, pc: number) => enums.OpCode[code.readUInt8(pc)].toLowerCase();\n\nexport function annotateOpcode(op: number, method: methods.Method, code: NodeBuffer, pc: number): string {\n  return OpcodeLayoutPrinters[enums.OpcodeLayouts[op]](method, code, pc);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/threading.ts\n **/","/**\n * Contains JVM opcode implementations for the JVM interpreter.\n */\n// We use snake case for the opcode names so they match the JVM spec.\n// As for typedef:memberVariableDeclarator, we disable this so we can have\n// member variable opcodes without explicitly typing them as IOpcodeImplementation.\n/* tslint:disable:variable-name typedef:memberVariableDeclarator */\n\"use strict\";\nimport gLong = require('./gLong');\nimport util = require('./util');\nimport ConstantPool = require('./ConstantPool');\nimport ClassData = require('./ClassData');\nimport threading = require('./threading');\nimport ClassLoader = require('./ClassLoader');\nimport enums = require('./enums');\nimport assert = require('./assert');\nimport methods = require('./methods');\nimport JVMTypes = require('../includes/JVMTypes');\n\n/**\n * Interface for individual opcode implementations.\n */\nexport interface IOpcodeImplementation {\n  (thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code?: Buffer): void;\n}\n\n/**\n * Helper function: Checks if object is null. Throws a NullPointerException\n * if it is.\n * @return True if the object is null.\n */\nexport function isNull(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, obj: any): boolean {\n  if (obj == null) {\n    throwException(thread, frame, 'Ljava/lang/NullPointerException;', '');\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper function: Pops off two items, returns the second.\n */\nexport function pop2(opStack: any[]): any {\n  // Ignore NULL.\n  opStack.pop();\n  return opStack.pop();\n}\n\nexport function resolveCPItem(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, cpItem: ConstantPool.IConstantPoolItem): void {\n  thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);\n  cpItem.resolve(thread, frame.getLoader(), frame.method.cls, (status: boolean) => {\n    if (status) {\n      thread.setStatus(enums.ThreadStatus.RUNNABLE);\n    }\n  }, false);\n  frame.returnToThreadLoop = true;\n}\n\nexport function initializeClassFromClass(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, cls: ClassData.ClassData): void {\n  thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);\n  cls.initialize(thread, (cdata: ClassData.ClassData) => {\n    if (cdata != null) {\n      thread.setStatus(enums.ThreadStatus.RUNNABLE);\n    }\n  }, false);\n  frame.returnToThreadLoop = true;\n}\n\n/**\n * Helper function: Pauses the thread and initializes a class.\n */\nexport function initializeClass(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, clsRef: ConstantPool.ClassReference): void {\n  thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);\n\n  function initialize(cls: ClassData.ClassData) {\n    cls.initialize(thread, (cdata: ClassData.ClassData) => {\n      if (cdata != null) {\n        thread.setStatus(enums.ThreadStatus.RUNNABLE);\n      }\n    });\n  }\n\n  if (!clsRef.isResolved()) {\n    clsRef.resolve(thread, frame.getLoader(), frame.method.cls, (status: boolean) => {\n      if (status) {\n        initialize(clsRef.cls);\n      }\n    }, false);\n  } else {\n    initialize(clsRef.cls);\n  }\n  frame.returnToThreadLoop = true;\n}\n\n/**\n * Interrupts the current method's execution and throws an exception.\n *\n * NOTE: This does *not* interrupt JavaScript control flow, so any opcode\n * calling this function must *return* and not do anything else.\n */\nexport function throwException<T extends JVMTypes.java_lang_Throwable>(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, clsName: string, msg: string): void {\n  thread.throwNewException<T>(clsName, msg);\n  frame.returnToThreadLoop = true;\n}\n\nexport var ArrayTypes : {[t: number]: string; } = {\n  4: 'Z', 5: 'C', 6: 'F', 7: 'D', 8: 'B', 9: 'S', 10: 'I', 11: 'J'\n};\n\n/**\n * Contains definitions for all JVM opcodes.\n */\nexport class Opcodes {\n  /* 32-bit array load opcodes */\n\n  /**\n   * 32-bit array load opcode\n   */\n  private static _aload_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      idx = opStack.pop(),\n      obj = <JVMTypes.JVMArray<any>> opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      var len = obj.array.length;\n      if (idx < 0 || idx >= len) {\n        throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', `${idx} not in length ${len} array of type ${obj.getClass().getInternalName()}`);\n      } else {\n        opStack.push(obj.array[idx]);\n        frame.pc++;\n      }\n    }\n    // 'obj' is NULL. isNull threw an exception for us.\n  }\n\n  public static iaload = Opcodes._aload_32;\n  public static faload = Opcodes._aload_32;\n  public static aaload = Opcodes._aload_32;\n  public static baload = Opcodes._aload_32;\n  public static caload = Opcodes._aload_32;\n  public static saload = Opcodes._aload_32;\n\n  /* 64-bit array load opcodes */\n\n  /**\n   * 64-bit array load opcode.\n   */\n  private static _aload_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      idx = opStack.pop(),\n      obj = <JVMTypes.JVMArray<any>> opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      var len = obj.array.length;\n      if (idx < 0 || idx >= len) {\n        throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', `${idx} not in length ${len} array of type ${obj.getClass().getInternalName()}`);\n      } else {\n        opStack.push(obj.array[idx]);\n        // 64-bit value.\n        opStack.push(null);\n        frame.pc++;\n      }\n    }\n    // 'obj' is NULL. isNull threw an exception for us.\n  }\n\n  public static daload = Opcodes._aload_64;\n  public static laload = Opcodes._aload_64;\n\n  /* 32-bit array store opcodes */\n\n  /**\n   * 32-bit array store.\n   * @private\n   */\n  private static _astore_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      value = opStack.pop(),\n      idx = opStack.pop(),\n      obj = <JVMTypes.JVMArray<any>> opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      var len = obj.array.length;\n      if (idx < 0 || idx >= len) {\n        throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', `${idx} not in length ${len} array of type ${obj.getClass().getInternalName()}`);\n      } else {\n        obj.array[idx] = value;\n        frame.pc++;\n      }\n    }\n    // 'obj' is NULL. isNull threw an exception for us.\n  }\n\n  public static iastore = Opcodes._astore_32;\n  public static fastore = Opcodes._astore_32;\n  public static aastore = Opcodes._astore_32;\n  public static bastore = Opcodes._astore_32;\n  public static castore = Opcodes._astore_32;\n  public static sastore = Opcodes._astore_32;\n\n  /* 64-bit array store opcodes */\n\n  /**\n   * 64-bit array store.\n   * @private\n   */\n  private static _astore_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      value = opStack.pop2(),\n      idx = opStack.pop(),\n      obj = <JVMTypes.JVMArray<any>> opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      var len = obj.array.length;\n      if (idx < 0 || idx >= len) {\n        throwException(thread, frame, 'Ljava/lang/ArrayIndexOutOfBoundsException;', `${idx} not in length ${len} array of type ${obj.getClass().getInternalName()}`);\n      } else {\n        obj.array[idx] = value;\n        frame.pc++;\n      }\n    }\n    // 'obj' is NULL. isNull threw an exception for us.\n  }\n\n  public static lastore = Opcodes._astore_64;\n  public static dastore = Opcodes._astore_64;\n\n  /* 32-bit constants */\n  public static aconst_null(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(null);\n    frame.pc++;\n  }\n\n  private static _const_0_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(0);\n    frame.pc++;\n  }\n\n  private static _const_1_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(1);\n    frame.pc++;\n  }\n\n  private static _const_2_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(2);\n    frame.pc++;\n  }\n\n  public static iconst_m1(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(-1);\n    frame.pc++;\n  }\n\n  public static iconst_0 = Opcodes._const_0_32;\n  public static iconst_1 = Opcodes._const_1_32;\n  public static iconst_2 = Opcodes._const_2_32;\n\n  public static iconst_3(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(3);\n    frame.pc++;\n  }\n\n  public static iconst_4(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(4);\n    frame.pc++;\n  }\n\n  public static iconst_5(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(5);\n    frame.pc++;\n  }\n\n  public static fconst_0 = Opcodes._const_0_32;\n  public static fconst_1 = Opcodes._const_1_32;\n  public static fconst_2 = Opcodes._const_2_32;\n\n  /* 64-bit constants */\n  public static lconst_0(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(gLong.ZERO);\n    frame.pc++;\n  }\n\n  public static lconst_1(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(gLong.ONE);\n    frame.pc++;\n  }\n\n  public static dconst_0(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(0);\n    frame.pc++;\n  }\n\n  public static dconst_1(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(1);\n    frame.pc++;\n  }\n\n  /* 32-bit load opcodes */\n  private static _load_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.push(frame.locals[code.readUInt8(pc + 1)]);\n    frame.pc += 2;\n  }\n\n  private static _load_0_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(frame.locals[0]);\n    frame.pc++;\n  }\n\n  private static _load_1_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(frame.locals[1]);\n    frame.pc++;\n  }\n\n  private static _load_2_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(frame.locals[2]);\n    frame.pc++;\n  }\n\n  private static _load_3_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(frame.locals[3]);\n    frame.pc++;\n  }\n\n  public static iload = Opcodes._load_32;\n  public static iload_0 = Opcodes._load_0_32;\n  public static iload_1 = Opcodes._load_1_32;\n  public static iload_2 = Opcodes._load_2_32;\n  public static iload_3 = Opcodes._load_3_32;\n  public static fload = Opcodes._load_32;\n  public static fload_0 = Opcodes._load_0_32;\n  public static fload_1 = Opcodes._load_1_32;\n  public static fload_2 = Opcodes._load_2_32;\n  public static fload_3 = Opcodes._load_3_32;\n  public static aload = Opcodes._load_32;\n  public static aload_0 = Opcodes._load_0_32;\n  public static aload_1 = Opcodes._load_1_32;\n  public static aload_2 = Opcodes._load_2_32;\n  public static aload_3 = Opcodes._load_3_32;\n\n  /* 64-bit load opcodes */\n  private static _load_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.pushWithNull(frame.locals[code.readUInt8(pc + 1)]);\n    frame.pc += 2;\n  }\n\n  private static _load_0_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(frame.locals[0]);\n    frame.pc++;\n  }\n\n  private static _load_1_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(frame.locals[1]);\n    frame.pc++;\n  }\n\n  private static _load_2_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(frame.locals[2]);\n    frame.pc++;\n  }\n\n  private static _load_3_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.pushWithNull(frame.locals[3]);\n    frame.pc++;\n  }\n\n  public static lload = Opcodes._load_64;\n  public static lload_0 = Opcodes._load_0_64;\n  public static lload_1 = Opcodes._load_1_64;\n  public static lload_2 = Opcodes._load_2_64;\n  public static lload_3 = Opcodes._load_3_64;\n  public static dload = Opcodes._load_64;\n  public static dload_0 = Opcodes._load_0_64;\n  public static dload_1 = Opcodes._load_1_64;\n  public static dload_2 = Opcodes._load_2_64;\n  public static dload_3 = Opcodes._load_3_64;\n\n  /* 32-bit store opcodes */\n  private static _store_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.locals[code.readUInt8(pc + 1)] = frame.opStack.pop();\n    frame.pc += 2;\n  }\n\n  private static _store_0_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[0] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_1_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[1] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_2_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[2] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_3_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[3] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  public static istore = Opcodes._store_32;\n  public static istore_0 = Opcodes._store_0_32;\n  public static istore_1 = Opcodes._store_1_32;\n  public static istore_2 = Opcodes._store_2_32;\n  public static istore_3 = Opcodes._store_3_32;\n  public static fstore = Opcodes._store_32;\n  public static fstore_0 = Opcodes._store_0_32;\n  public static fstore_1 = Opcodes._store_1_32;\n  public static fstore_2 = Opcodes._store_2_32;\n  public static fstore_3 = Opcodes._store_3_32;\n  public static astore = Opcodes._store_32;\n  public static astore_0 = Opcodes._store_0_32;\n  public static astore_1 = Opcodes._store_1_32;\n  public static astore_2 = Opcodes._store_2_32;\n  public static astore_3 = Opcodes._store_3_32;\n\n  /* 64-bit store opcodes */\n  private static _store_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var offset = code.readUInt8(pc + 1);\n    // NULL\n    frame.locals[offset + 1] = frame.opStack.pop();\n    // The actual value.\n    frame.locals[offset] = frame.opStack.pop();\n    frame.pc += 2;\n  }\n\n  private static _store_0_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[1] = frame.opStack.pop();\n    frame.locals[0] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_1_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[2] = frame.opStack.pop();\n    frame.locals[1] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_2_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[3] = frame.opStack.pop();\n    frame.locals[2] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  private static _store_3_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.locals[4] = frame.opStack.pop();\n    frame.locals[3] = frame.opStack.pop();\n    frame.pc++;\n  }\n\n  public static lstore = Opcodes._store_64;\n  public static lstore_0 = Opcodes._store_0_64;\n  public static lstore_1 = Opcodes._store_1_64;\n  public static lstore_2 = Opcodes._store_2_64;\n  public static lstore_3 = Opcodes._store_3_64;\n  public static dstore = Opcodes._store_64;\n  public static dstore_0 = Opcodes._store_0_64;\n  public static dstore_1 = Opcodes._store_1_64;\n  public static dstore_2 = Opcodes._store_2_64;\n  public static dstore_3 = Opcodes._store_3_64;\n\n  /* Misc. */\n\n  public static sipush(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.push(code.readInt16BE(pc + 1));\n    frame.pc += 3;\n  }\n\n  public static bipush(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.push(code.readInt8(pc + 1));\n    frame.pc += 2;\n  }\n\n  public static pop(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dropFromTop(1);\n    frame.pc++;\n  }\n\n  public static pop2(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    // http://i.imgur.com/MieF0KG.jpg\n    frame.opStack.dropFromTop(2);\n    frame.pc++;\n  }\n\n  public static dup(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dup();\n    frame.pc++;\n  }\n\n  public static dup_x1(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dup_x1();\n    frame.pc++;\n  }\n\n  public static dup_x2(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dup_x2();\n    frame.pc++;\n  }\n\n  public static dup2(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dup2();\n    frame.pc++;\n  }\n\n  public static dup2_x1(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.dup2_x1();\n    frame.pc++;\n  }\n\n  public static dup2_x2(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v1 = opStack.pop(),\n      v2 = opStack.pop(),\n      v3 = opStack.pop(),\n      v4 = opStack.pop();\n    opStack.push6(v2, v1, v4, v3, v2, v1);\n    frame.pc++;\n  }\n\n  public static swap(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.swap();\n    frame.pc++;\n  }\n\n  /* Math Opcodes */\n  public static iadd(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push((opStack.pop() + opStack.pop()) | 0);\n    frame.pc++;\n  }\n\n  public static ladd(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().add(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static fadd(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(util.wrapFloat(opStack.pop() + opStack.pop()));\n    frame.pc++;\n  }\n\n  public static dadd(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2() + opStack.pop2());\n    frame.pc++;\n  }\n\n  public static isub(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push((-opStack.pop() + opStack.pop()) | 0);\n    frame.pc++;\n  }\n\n  public static fsub(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(util.wrapFloat(-opStack.pop() + opStack.pop()));\n    frame.pc++;\n  }\n\n  public static dsub(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(-opStack.pop2() + opStack.pop2());\n    frame.pc++;\n  }\n\n  public static lsub(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().negate().add(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static imul(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push((<any> Math).imul(opStack.pop(), opStack.pop()));\n    frame.pc++;\n  }\n\n  public static lmul(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().multiply(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static fmul(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(util.wrapFloat(opStack.pop() * opStack.pop()));\n    frame.pc++;\n  }\n\n  public static dmul(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2() * opStack.pop2());\n    frame.pc++;\n  }\n\n  public static idiv(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack, b: number = opStack.pop(), a: number = opStack.pop();\n    if (b === 0) {\n      throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');\n    } else {\n      // spec: \"if the dividend is the negative integer of largest possible magnitude\n      // for the int type, and the divisor is -1, then overflow occurs, and the\n      // result is equal to the dividend.\"\n      if (a === enums.Constants.INT_MIN && b === -1) {\n        opStack.push(a);\n      } else {\n        opStack.push((a / b) | 0);\n      }\n      frame.pc++;\n    }\n  }\n\n  public static ldiv(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      b: gLong = opStack.pop2(),\n      a: gLong = opStack.pop2();\n    if (b.isZero()) {\n      throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');\n    } else {\n      opStack.pushWithNull(a.div(b));\n      frame.pc++;\n    }\n  }\n\n  public static fdiv(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      a: number = opStack.pop();\n    opStack.push(util.wrapFloat(opStack.pop() / a));\n    frame.pc++;\n  }\n\n  public static ddiv(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v: number = opStack.pop2();\n    opStack.pushWithNull(opStack.pop2() / v);\n    frame.pc++;\n  }\n\n  public static irem(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      b: number = opStack.pop(),\n      a: number = opStack.pop();\n    if (b === 0) {\n      throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');\n    } else {\n      opStack.push(a % b);\n      frame.pc++;\n    }\n  }\n\n  public static lrem(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      b: gLong = opStack.pop2(),\n      a: gLong = opStack.pop2();\n    if (b.isZero()) {\n      throwException(thread, frame, 'Ljava/lang/ArithmeticException;', '/ by zero');\n    } else {\n      opStack.pushWithNull(a.modulo(b));\n      frame.pc++;\n    }\n  }\n\n  public static frem(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      b: number = opStack.pop();\n    opStack.push(opStack.pop() % b);\n    frame.pc++;\n  }\n\n  public static drem(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      b: number = opStack.pop2();\n    opStack.pushWithNull(opStack.pop2() % b);\n    frame.pc++;\n  }\n\n  public static ineg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(-opStack.pop() | 0);\n    frame.pc++;\n  }\n\n  public static lneg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().negate());\n    frame.pc++;\n  }\n\n  public static fneg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(-opStack.pop());\n    frame.pc++;\n  }\n\n  public static dneg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(-opStack.pop2());\n    frame.pc++;\n  }\n\n  /* Bitwise Operations */\n\n  public static ishl(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.push(opStack.pop() << s);\n    frame.pc++;\n  }\n\n  public static lshl(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.pushWithNull(opStack.pop2().shiftLeft(gLong.fromInt(s)));\n    frame.pc++;\n  }\n\n  public static ishr(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.push(opStack.pop() >> s);\n    frame.pc++;\n  }\n\n  public static lshr(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.pushWithNull(opStack.pop2().shiftRight(gLong.fromInt(s)));\n    frame.pc++;\n  }\n\n  public static iushr(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.push((opStack.pop() >>> s) | 0);\n    frame.pc++;\n  }\n\n  public static lushr(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      s: number = opStack.pop();\n    opStack.pushWithNull(opStack.pop2().shiftRightUnsigned(gLong.fromInt(s)));\n    frame.pc++;\n  }\n\n  public static iand(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop() & opStack.pop());\n    frame.pc++;\n  }\n\n  public static land(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().and(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static ior(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop() | opStack.pop());\n    frame.pc++;\n  }\n\n  public static lor(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().or(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static ixor(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop() ^ opStack.pop());\n    frame.pc++;\n  }\n\n  public static lxor(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().xor(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static iinc(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var idx = code.readUInt8(pc + 1),\n      val = code.readInt8(pc + 2);\n    frame.locals[idx] = (frame.locals[idx] + val) | 0;\n    frame.pc += 3;\n  }\n\n  public static i2l(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(gLong.fromInt(opStack.pop()));\n    frame.pc++;\n  }\n\n  public static i2f(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    // NOP; we represent ints as floats anyway.\n    // @todo What about quantities unexpressable as floats?\n    frame.pc++;\n  }\n\n  public static i2d(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(null);\n    frame.pc++;\n  }\n\n  public static l2i(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop2().toInt());\n    frame.pc++;\n  }\n\n  public static l2f(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop2().toNumber());\n    frame.pc++;\n  }\n\n  public static l2d(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(opStack.pop2().toNumber());\n    frame.pc++;\n  }\n\n  public static f2i(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(util.float2int(opStack.pop()));\n    frame.pc++;\n  }\n\n  public static f2l(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pushWithNull(gLong.fromNumber(opStack.pop()));\n    frame.pc++;\n  }\n\n  public static f2d(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.opStack.push(null);\n    frame.pc++;\n  }\n\n  public static d2i(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(util.float2int(opStack.pop2()));\n    frame.pc++;\n  }\n\n  public static d2l(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      d_val: number = opStack.pop2();\n    if (d_val === Number.POSITIVE_INFINITY) {\n      opStack.pushWithNull(gLong.MAX_VALUE);\n    } else if (d_val === Number.NEGATIVE_INFINITY) {\n      opStack.pushWithNull(gLong.MIN_VALUE);\n    } else {\n      opStack.pushWithNull(gLong.fromNumber(d_val));\n    }\n    frame.pc++;\n  }\n\n  public static d2f(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.pop();\n    opStack.push(util.wrapFloat(opStack.pop()));\n    frame.pc++;\n  }\n\n  public static i2b(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push((opStack.pop() << 24) >> 24);\n    frame.pc++;\n  }\n\n  public static i2c(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push(opStack.pop() & 0xFFFF);\n    frame.pc++;\n  }\n\n  public static i2s(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack;\n    opStack.push((opStack.pop() << 16) >> 16);\n    frame.pc++;\n  }\n\n  public static lcmp(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v2: gLong = opStack.pop2();\n    opStack.push(opStack.pop2().compare(v2));\n    frame.pc++;\n  }\n\n  public static fcmpl(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v2 = opStack.pop(),\n      v1 = opStack.pop();\n    if (v1 === v2) {\n      opStack.push(0);\n    } else if (v1 > v2) {\n      opStack.push(1);\n    } else {\n      // v1 < v2, and if v1 or v2 is NaN.\n      opStack.push(-1);\n    }\n    frame.pc++;\n  }\n\n  public static fcmpg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v2 = opStack.pop(),\n      v1 = opStack.pop();\n    if (v1 === v2) {\n      opStack.push(0);\n    } else if (v1 < v2) {\n      opStack.push(-1);\n    } else {\n      // v1 > v2, and if v1 or v2 is NaN.\n      opStack.push(1);\n    }\n    frame.pc++;\n  }\n\n  public static dcmpl(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v2 = opStack.pop2(),\n      v1 = opStack.pop2();\n    if (v1 === v2) {\n      opStack.push(0);\n    } else if (v1 > v2) {\n      opStack.push(1);\n    } else {\n      // v1 < v2, and if v1 or v2 is NaN.\n      opStack.push(-1);\n    }\n    frame.pc++;\n  }\n\n  public static dcmpg(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack,\n      v2 = opStack.pop2(),\n      v1 = opStack.pop2();\n    if (v1 === v2) {\n      opStack.push(0);\n    } else if (v1 < v2) {\n      opStack.push(-1);\n    } else {\n      // v1 > v2, and if v1 or v2 is NaN.\n      opStack.push(1);\n    }\n    frame.pc++;\n  }\n\n  /* Unary branch opcodes */\n  public static ifeq(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() === 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static ifne(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() !== 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static iflt(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() < 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static ifge(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() >= 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static ifgt(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() > 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static ifle(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() <= 0) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  /* Binary branch opcodes */\n  public static if_icmpeq(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 === v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_icmpne(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 !== v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_icmplt(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 < v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_icmpge(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 >= v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_icmpgt(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 > v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_icmple(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 <= v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_acmpeq(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 === v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static if_acmpne(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var v2 = frame.opStack.pop();\n    var v1 = frame.opStack.pop();\n    if (v1 !== v2) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  /* Jump opcodes */\n  public static goto(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    const offset = code.readInt16BE(pc + 1);\n    frame.pc += offset;\n    if (offset < 0) {\n      frame.method.incrBBEntries();\n    }\n  }\n\n  public static jsr(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.push(pc + 3);\n    const offset = code.readInt16BE(pc + 1);\n    frame.pc += offset;\n    if (offset < 0) {\n      frame.method.incrBBEntries();\n    }\n  }\n\n  public static ret(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.pc = frame.locals[code.readUInt8(pc + 1)];\n  }\n\n  public static tableswitch(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    let pc = frame.pc;\n    // Ignore padding bytes. The +1 is to skip the opcode byte.\n    pc += ((4 - (pc + 1) % 4) % 4) + 1;\n    var defaultOffset = code.readInt32BE(pc),\n      low = code.readInt32BE(pc + 4),\n      high = code.readInt32BE(pc + 8),\n      offset = frame.opStack.pop();\n\n    if (offset >= low && offset <= high) {\n      frame.pc += code.readInt32BE(pc + 12 + ((offset - low) * 4));\n    } else {\n      frame.pc += defaultOffset;\n    }\n  }\n\n  public static lookupswitch(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    let pc = frame.pc;\n    // Skip padding bytes. The +1 is to skip the opcode byte.\n    pc += ((4 - (pc + 1) % 4) % 4) + 1;\n    var defaultOffset = code.readInt32BE(pc),\n      nPairs = code.readInt32BE(pc + 4),\n      i: number,\n      v: number = frame.opStack.pop();\n\n    pc += 8;\n    for (i = 0; i < nPairs; i++) {\n      if (code.readInt32BE(pc) === v) {\n        const offset = code.readInt32BE(pc + 4);\n        frame.pc += offset;\n        if (offset < 0) {\n          frame.method.incrBBEntries();\n        }\n        return;\n      }\n      pc += 8;\n    }\n    // No match found.\n    frame.pc += defaultOffset;\n  }\n\n  public static return(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.returnToThreadLoop = true;\n    if (frame.method.accessFlags.isSynchronized()) {\n      // monitorexit\n      if (!frame.method.methodLock(thread, frame).exit(thread)) {\n        // monitorexit threw an exception.\n        return;\n      }\n    }\n    thread.asyncReturn();\n  }\n\n  /* 32-bit return bytecodes */\n\n  private static _return_32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.returnToThreadLoop = true;\n    if (frame.method.accessFlags.isSynchronized()) {\n      // monitorexit\n      if (!frame.method.methodLock(thread, frame).exit(thread)) {\n        // monitorexit threw an exception.\n        return;\n      }\n    }\n    thread.asyncReturn(frame.opStack.bottom());\n  }\n\n  public static ireturn = Opcodes._return_32;\n  public static freturn = Opcodes._return_32;\n  public static areturn = Opcodes._return_32;\n\n  /* 64-bit return opcodes */\n\n  private static _return_64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.returnToThreadLoop = true;\n    if (frame.method.accessFlags.isSynchronized()) {\n      // monitorexit\n      if (!frame.method.methodLock(thread, frame).exit(thread)) {\n        // monitorexit threw an exception.\n        return;\n      }\n    }\n    thread.asyncReturn(frame.opStack.bottom(), null);\n  }\n\n  public static lreturn = Opcodes._return_64;\n  public static dreturn = Opcodes._return_64;\n\n  public static getstatic(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);\n    if (fieldInfo.isResolved()) {\n      // Get the *actual* class that owns this field.\n      // This may not be initialized if it's an interface, so we need to check.\n      var fieldOwnerCls = fieldInfo.field.cls;\n      if (fieldOwnerCls.isInitialized(thread)) {\n        // Opcode is ready to execute! Rewrite to a 'fast' version,\n        // and run the fast version.\n        if (fieldInfo.nameAndTypeInfo.descriptor === 'J' || fieldInfo.nameAndTypeInfo.descriptor === 'D') {\n          code.writeUInt8(enums.OpCode.GETSTATIC_FAST64, pc);\n        } else {\n          code.writeUInt8(enums.OpCode.GETSTATIC_FAST32, pc);\n        }\n        // Stash the result of field lookup.\n        fieldInfo.fieldOwnerConstructor = fieldOwnerCls.getConstructor(thread);\n      } else {\n        // Initialize class and rerun opcode\n        initializeClassFromClass(thread, frame, fieldOwnerCls);\n      }\n    } else {\n      // Resolve the field.\n      resolveCPItem(thread, frame, fieldInfo);\n    }\n  }\n\n  /**\n   * A fast version of getstatic that assumes that relevant classes are\n   * initialized.\n   *\n   * Retrieves a 32-bit value.\n   */\n  public static getstatic_fast32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    frame.opStack.push(fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName]);\n    frame.pc += 3;\n  }\n\n  /**\n   * A fast version of getstatic that assumes that relevant classes are\n   * initialized.\n   *\n   * Retrieves a 64-bit value.\n   */\n  public static getstatic_fast64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    frame.opStack.pushWithNull(fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName]);\n    frame.pc += 3;\n  }\n\n  public static putstatic(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);\n\n    if (fieldInfo.isResolved()) {\n      // Get the *actual* class that owns this field.\n      // This may not be initialized if it's an interface, so we need to check.\n      var fieldOwnerCls = fieldInfo.field.cls;\n      if (fieldOwnerCls.isInitialized(thread)) {\n        // Opcode is ready to execute! Rewrite to a 'fast' version,\n        // and run the fast version.\n        if (fieldInfo.nameAndTypeInfo.descriptor === 'J' || fieldInfo.nameAndTypeInfo.descriptor === 'D') {\n          code.writeUInt8(enums.OpCode.PUTSTATIC_FAST64, pc);\n        } else {\n          code.writeUInt8(enums.OpCode.PUTSTATIC_FAST32, pc);\n        }\n        // Stash the result of field lookup.\n        fieldInfo.fieldOwnerConstructor = fieldOwnerCls.getConstructor(thread);\n      } else {\n        // Initialize class and rerun opcode\n        initializeClassFromClass(thread, frame, fieldOwnerCls);\n      }\n    } else {\n      // Resolve the field.\n      resolveCPItem(thread, frame, fieldInfo);\n    }\n  }\n\n  /**\n   * A fast version of putstatic that assumes that relevant classes are\n   * initialized.\n   *\n   * Puts a 32-bit value.\n   */\n  public static putstatic_fast32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName] = frame.opStack.pop();\n    frame.pc += 3;\n  }\n\n  /**\n   * A fast version of putstatic that assumes that relevant classes are\n   * initialized.\n   *\n   * Puts a 64-bit value.\n   */\n  public static putstatic_fast64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    fieldInfo.fieldOwnerConstructor[fieldInfo.fullFieldName] = frame.opStack.pop2();\n    frame.pc += 3;\n  }\n\n  public static getfield(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      loader = frame.getLoader(),\n      obj = frame.opStack.top();\n    assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);\n    // Check if the object is null; if we do not do this before get_class, then\n    // we might try to get a class that we have not initialized!\n    if (!isNull(thread, frame, obj)) {\n      // cls is guaranteed to be in the inheritance hierarchy of obj, so it must be\n      // initialized. However, it may not be loaded in the current class's\n      // ClassLoader...\n      if (fieldInfo.isResolved()) {\n        var field = fieldInfo.field;\n        if (field.rawDescriptor == 'J' || field.rawDescriptor == 'D') {\n          code.writeUInt8(enums.OpCode.GETFIELD_FAST64, pc);\n        } else {\n          code.writeUInt8(enums.OpCode.GETFIELD_FAST32, pc);\n        }\n        // Rerun opcode\n      } else {\n        resolveCPItem(thread, frame, fieldInfo);\n      }\n    }\n  }\n\n  public static getfield_fast32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack, obj: JVMTypes.java_lang_Object = opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      opStack.push((<any> obj)[fieldInfo.fullFieldName]);\n      frame.pc += 3;\n    }\n  }\n\n  public static getfield_fast64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack, obj: JVMTypes.java_lang_Object = opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      opStack.pushWithNull((<any> obj)[fieldInfo.fullFieldName]);\n      frame.pc += 3;\n    }\n  }\n\n  public static putfield(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      loader = frame.getLoader(),\n      isLong = fieldInfo.nameAndTypeInfo.descriptor == 'J' || fieldInfo.nameAndTypeInfo.descriptor == 'D',\n      obj = frame.opStack.fromTop(isLong ? 2 : 1);\n    assert(fieldInfo.getType() === enums.ConstantPoolItemType.FIELDREF);\n\n    // Check if the object is null; if we do not do this before get_class, then\n    // we might try to get a class that we have not initialized!\n    if (!isNull(thread, frame, obj)) {\n      // cls is guaranteed to be in the inheritance hierarchy of obj, so it must be\n      // initialized. However, it may not be loaded in the current class's\n      // ClassLoader...\n      if (fieldInfo.isResolved()) {\n        var field = fieldInfo.field;\n        if (isLong) {\n          code.writeUInt8(enums.OpCode.PUTFIELD_FAST64, pc);\n        } else {\n          code.writeUInt8(enums.OpCode.PUTFIELD_FAST32, pc);\n        }\n        // Stash the resolved full field name.\n        fieldInfo.fullFieldName = `${util.descriptor2typestr(field.cls.getInternalName())}/${fieldInfo.nameAndTypeInfo.name}`;\n        // Rerun opcode\n      } else {\n        resolveCPItem(thread, frame, fieldInfo);\n      }\n    }\n  }\n\n  public static putfield_fast32(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var opStack = frame.opStack,\n      val = opStack.pop(),\n      obj: JVMTypes.java_lang_Object = opStack.pop(),\n      fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n\n    if (!isNull(thread, frame, obj)) {\n      (<any> obj)[fieldInfo.fullFieldName] = val;\n      frame.pc += 3;\n    }\n    // NPE has been thrown.\n  }\n\n  public static putfield_fast64(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var opStack = frame.opStack,\n      val = opStack.pop2(),\n      obj: JVMTypes.java_lang_Object = opStack.pop(),\n      fieldInfo = <ConstantPool.FieldReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n\n    if (!isNull(thread, frame, obj)) {\n      (<any> obj)[fieldInfo.fullFieldName] = val;\n      frame.pc += 3;\n    }\n    // NPE has been thrown.\n  }\n\n  public static invokevirtual(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n\n    // Ensure referenced class is loaded in the current classloader.\n    // Even though we don't use this class for anything, and we know that it\n    // must be loaded because it is in the object's inheritance hierarchy,\n    // it needs to be present in the current classloader.\n    if (methodReference.isResolved()) {\n      var m = methodReference.method;\n      if (m.isSignaturePolymorphic()) {\n        switch (m.name) {\n          case 'invokeBasic':\n            code.writeUInt8(enums.OpCode.INVOKEBASIC, pc);\n            break;\n          case 'invoke':\n          case 'invokeExact':\n            code.writeUInt8(enums.OpCode.INVOKEHANDLE, pc);\n            break;\n          default:\n            throwException(thread, frame, 'Ljava/lang/AbstractMethodError;', `Invalid signature polymorphic method: ${m.cls.getExternalName()}.${m.name}`);\n            break;\n        }\n      } else {\n        code.writeUInt8(enums.OpCode.INVOKEVIRTUAL_FAST, pc);\n      }\n    } else {\n      resolveCPItem(thread, frame, methodReference);\n    }\n  }\n\n  public static invokeinterface(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (methodReference.isResolved()) {\n      if (methodReference.method.cls.isInitialized(thread)) {\n        // Rewrite to fast and rerun.\n        code.writeUInt8(enums.OpCode.INVOKEINTERFACE_FAST, pc);\n      } else {\n        // Initialize our class and rerun opcode.\n        // Note that the existance of an object of an interface type does *not*\n        // mean that the interface is initialized!\n        initializeClass(thread, frame, methodReference.classInfo);\n      }\n    } else {\n      resolveCPItem(thread, frame, methodReference);\n    }\n  }\n\n  public static invokedynamic(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var callSiteSpecifier = <ConstantPool.InvokeDynamic> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    thread.setStatus(enums.ThreadStatus.ASYNC_WAITING);\n    callSiteSpecifier.constructCallSiteObject(thread, frame.getLoader(), frame.method.cls, pc, (status: boolean) => {\n      if (status) {\n        assert(typeof(callSiteSpecifier.getCallSiteObject(pc)[0].vmtarget) === 'function', \"MethodName should be resolved...\");\n        code.writeUInt8(enums.OpCode.INVOKEDYNAMIC_FAST, pc);\n        // Resume and rerun fast opcode.\n        thread.setStatus(enums.ThreadStatus.RUNNABLE);\n      }\n    });\n    frame.returnToThreadLoop = true;\n  }\n\n  /**\n   * XXX: Actually perform superclass method lookup.\n   */\n  public static invokespecial(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (methodReference.isResolved()) {\n      // Rewrite and rerun.\n      code.writeUInt8(enums.OpCode.INVOKENONVIRTUAL_FAST, pc);\n    } else {\n      resolveCPItem(thread, frame, methodReference);\n    }\n  }\n\n  public static invokestatic(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (methodReference.isResolved()) {\n      var m = methodReference.method;\n      if (m.cls.isInitialized(thread)) {\n        var newOpcode: enums.OpCode = enums.OpCode.INVOKESTATIC_FAST;\n        if (methodReference.method.isSignaturePolymorphic()) {\n          switch (methodReference.method.name) {\n            case 'linkToInterface':\n            case 'linkToVirtual':\n              newOpcode = enums.OpCode.LINKTOVIRTUAL;\n              break;\n            case 'linkToStatic':\n            case 'linkToSpecial':\n              newOpcode = enums.OpCode.LINKTOSPECIAL;\n              break;\n            default:\n              assert(false, \"Should be impossible.\");\n              break;\n          }\n        }\n        // Rewrite and rerun.\n        code.writeUInt8(newOpcode, pc);\n      } else {\n        initializeClassFromClass(thread, frame, m.cls);\n      }\n    } else {\n      resolveCPItem(thread, frame, methodReference);\n    }\n  }\n\n  /// Fast invoke opcodes.\n\n  public static invokenonvirtual_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack, paramSize = methodReference.paramWordSize,\n      obj: JVMTypes.java_lang_Object = opStack.fromTop(paramSize);\n\n    if (!isNull(thread, frame, obj)) {\n      var args = opStack.sliceFromTop(paramSize);\n      opStack.dropFromTop(paramSize + 1);\n      assert(typeof (<any> obj)[methodReference.fullSignature] === 'function', `Resolved method ${methodReference.fullSignature} isn't defined?!`, thread);\n      (<any> obj)[methodReference.fullSignature](thread, args);\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  public static invokestatic_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack, paramSize = methodReference.paramWordSize,\n      args = opStack.sliceAndDropFromTop(paramSize);\n    assert(methodReference.jsConstructor != null, \"jsConstructor is missing?!\");\n    assert(typeof(methodReference.jsConstructor[methodReference.fullSignature]) === 'function', \"Resolved method isn't defined?!\");\n    methodReference.jsConstructor[methodReference.fullSignature](thread, args);\n    frame.returnToThreadLoop = true;\n  }\n\n  public static invokevirtual_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      count = methodReference.paramWordSize,\n      opStack = frame.opStack,\n      obj: JVMTypes.java_lang_Object = opStack.fromTop(count);\n    if (!isNull(thread, frame, obj)) {\n      // Use the class of the *object*.\n      assert(typeof (<any> obj)[methodReference.signature] === 'function', `Resolved method ${methodReference.signature} isn't defined?!`);\n      (<any> obj)[methodReference.signature](thread, opStack.sliceFromTop(count));\n      opStack.dropFromTop(count + 1);\n      frame.returnToThreadLoop = true;\n    }\n    // Object is NULL; NPE has been thrown.\n  }\n\n  public static invokeinterface_fast = Opcodes.invokevirtual_fast;\n\n  public static invokedynamic_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var callSiteSpecifier = <ConstantPool.InvokeDynamic> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      cso = callSiteSpecifier.getCallSiteObject(pc),\n      appendix = cso[1],\n      fcn = cso[0].vmtarget,\n      opStack = frame.opStack, paramSize = callSiteSpecifier.paramWordSize,\n      args = opStack.sliceAndDropFromTop(paramSize);\n\n    if (appendix !== null) {\n      args.push(appendix);\n    }\n    fcn(thread, null, args);\n    frame.returnToThreadLoop = true;\n  }\n\n  /**\n   * Opcode for MethodHandle.invoke and MethodHandle.invokeExact.\n   */\n  public static invokehandle(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack,\n      fcn = methodReference.memberName.vmtarget,\n      // Add in 1 for the method handle itself.\n      paramSize = methodReference.paramWordSize + 1,\n      appendix = methodReference.appendix,\n      args = opStack.sliceFromTop(paramSize);\n\n    if (appendix !== null) {\n      args.push(appendix);\n    }\n\n    if (!isNull(thread, frame, args[0])) {\n      opStack.dropFromTop(paramSize);\n      // fcn will handle invoking 'this' and such.\n      // TODO: If this can be varargs, pass in parameter types to the function.\n      fcn(thread, null, args);\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  /**\n   * Opcode for MethodHandle.invokeBasic.\n   * Unlike invoke/invokeExact, invokeBasic does not call a generated bytecode\n   * method. It calls the vmtarget embedded in the MethodHandler directly.\n   * This can cause crashes with malformed calls, thus it is only accesssible\n   * to trusted JDK code.\n   */\n  public static invokebasic(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      paramSize = methodReference.getParamWordSize(),\n      opStack = frame.opStack,\n      obj: JVMTypes.java_lang_invoke_MethodHandle = opStack.fromTop(paramSize),\n      // Need to include the MethodHandle in the arguments to vmtarget. vmtarget\n      // will appropriately invoke it.\n      args = opStack.sliceFromTop(paramSize + 1),\n      lmbdaForm: JVMTypes.java_lang_invoke_LambdaForm,\n      mn: JVMTypes.java_lang_invoke_MemberName,\n      m: methods.Method;\n\n    // obj is a MethodHandle.\n    if (!isNull(thread, frame, obj)) {\n      opStack.dropFromTop(paramSize + 1);\n      lmbdaForm = obj['java/lang/invoke/MethodHandle/form'];\n      mn = lmbdaForm['java/lang/invoke/LambdaForm/vmentry'];\n      assert(mn.vmtarget !== null && mn.vmtarget !== undefined, \"vmtarget must be defined\");\n      mn.vmtarget(thread, methodReference.nameAndTypeInfo.descriptor, args);\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  /**\n   * Also used for linkToStatic.\n   * TODO: De-conflate the two.\n   * TODO: Varargs functions.\n   */\n  public static linktospecial(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack, paramSize = methodReference.paramWordSize,\n      // Final argument is the relevant MemberName. Function args are right\n      // before it.\n      args = opStack.sliceFromTop(paramSize),\n      memberName: JVMTypes.java_lang_invoke_MemberName = args.pop(),\n      // TODO: Use parsed descriptor.\n      desc = methodReference.nameAndTypeInfo.descriptor;\n\n    if (!isNull(thread, frame, memberName)) {\n      opStack.dropFromTop(paramSize);\n      assert(memberName.getClass().getInternalName() === \"Ljava/lang/invoke/MemberName;\");\n      // parameterTypes for function are the same as the method reference, but without the trailing MemberName.\n      // TODO: Use parsed descriptor, avoid re-doing work here.\n      memberName.vmtarget(thread, desc.replace(\"Ljava/lang/invoke/MemberName;)\", \")\"), args);\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  // XXX: Varargs functions. We're supposed to box args if target is varargs.\n  public static linktovirtual(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var methodReference = <ConstantPool.MethodReference | ConstantPool.InterfaceMethodReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      paramSize = methodReference.paramWordSize,\n      opStack = frame.opStack,\n      args = opStack.sliceFromTop(paramSize),\n      // Final argument is the relevant MemberName. Function args are right\n      // before it.\n      memberName: JVMTypes.java_lang_invoke_MemberName = args.pop(),\n      desc = methodReference.nameAndTypeInfo.descriptor;\n\n    if (!isNull(thread, frame, memberName)) {\n      opStack.dropFromTop(paramSize);\n      assert(memberName.getClass().getInternalName() === \"Ljava/lang/invoke/MemberName;\");\n      // parameterTypes for function are the same as the method reference, but without the trailing MemberName.\n      memberName.vmtarget(thread, desc.replace(\"Ljava/lang/invoke/MemberName;)\", \")\"), args);\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  public static breakpoint(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    throwException(thread, frame, \"Ljava/lang/Error;\", \"breakpoint not implemented.\");\n  }\n\n  public static new(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (classRef.isResolved()) {\n      var cls = classRef.cls;\n      if (cls.isInitialized(thread)) {\n        code.writeUInt8(enums.OpCode.NEW_FAST, pc);\n        // Return to thread, rerun opcode.\n      } else {\n        initializeClassFromClass(thread, frame, cls);\n      }\n    } else {\n      resolveCPItem(thread, frame, classRef);\n    }\n  }\n\n  public static new_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    frame.opStack.push(new classRef.clsConstructor(thread));\n    frame.pc += 3;\n  }\n\n  public static newarray(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    // TODO: Stash all of these array types during JVM startup.\n    var opStack = frame.opStack,\n      type = \"[\" + ArrayTypes[code.readUInt8(pc + 1)],\n      cls = <ClassData.ArrayClassData<any>> frame.getLoader().getInitializedClass(thread, type),\n      length = opStack.pop();\n    if (length >= 0) {\n      opStack.push(new (cls.getConstructor(thread))(thread, length));\n      frame.pc += 2;\n    } else {\n      throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', `Tried to init ${type} array with length ${length}`);\n    }\n  }\n\n  public static anewarray(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (classRef.isResolved()) {\n      // Rewrite and rerun.\n      code.writeUInt8(enums.OpCode.ANEWARRAY_FAST, pc);\n      classRef.arrayClass = <ClassData.ArrayClassData<any>> frame.getLoader().getInitializedClass(thread, `[${classRef.cls.getInternalName()}`);\n      classRef.arrayClassConstructor = classRef.arrayClass.getConstructor(thread);\n    } else {\n      resolveCPItem(thread, frame, classRef);\n    }\n  }\n\n  public static anewarray_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var opStack = frame.opStack,\n      classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      length = opStack.pop();\n\n    if (length >= 0) {\n      opStack.push(new classRef.arrayClassConstructor(thread, length));\n      frame.pc += 3;\n    } else {\n      throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', `Tried to init ${classRef.arrayClass.getInternalName()} array with length ${length}`);\n    }\n  }\n\n  public static arraylength(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack, obj: JVMTypes.JVMArray<any> = opStack.pop();\n    if (!isNull(thread, frame, obj)) {\n      opStack.push(obj.array.length);\n      frame.pc++;\n    }\n    // obj is NULL. isNull threw an exception for us.\n  }\n\n  public static athrow(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    thread.throwException(frame.opStack.pop());\n    frame.returnToThreadLoop = true;\n  }\n\n  public static checkcast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (classRef.isResolved()) {\n      // Rewrite to fast version, and re-execute.\n      code.writeUInt8(enums.OpCode.CHECKCAST_FAST, pc);\n    } else {\n      resolveCPItem(thread, frame, classRef);\n    }\n  }\n\n  public static checkcast_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      cls = classRef.cls,\n      opStack = frame.opStack,\n      o: JVMTypes.java_lang_Object = opStack.top();\n    if ((o != null) && !o.getClass().isCastable(cls)) {\n      var targetClass = cls.getExternalName();\n      var candidateClass = o.getClass().getExternalName();\n      throwException(thread, frame, 'Ljava/lang/ClassCastException;', `${candidateClass} cannot be cast to ${targetClass}`);\n    } else {\n      // Success!\n      frame.pc += 3;\n    }\n  }\n\n  public static instanceof(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (classRef.isResolved()) {\n      // Rewrite and rerun.\n      code.writeUInt8(enums.OpCode.INSTANCEOF_FAST, pc);\n    } else {\n      // Fetch class and rerun opcode.\n      resolveCPItem(thread, frame, classRef);\n    }\n  }\n\n  public static instanceof_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      cls = classRef.cls,\n      opStack = frame.opStack,\n      o = <JVMTypes.java_lang_Object> opStack.pop();\n    opStack.push(o !== null ? (o.getClass().isCastable(cls) ? 1 : 0) : 0);\n    frame.pc += 3;\n  }\n\n  public static monitorenter(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var opStack = frame.opStack, monitorObj: JVMTypes.java_lang_Object = opStack.pop(),\n      monitorEntered = () => {\n        // [Note: Thread is now in the RUNNABLE state.]\n        // Increment the PC.\n        frame.pc++;\n      };\n\n    if (!monitorObj.getMonitor().enter(thread, monitorEntered)) {\n      // Opcode failed. monitorEntered will be run once we own the monitor.\n      // The thread is now in the BLOCKED state. Tell the frame to return to\n      // the thread loop.\n      frame.returnToThreadLoop = true;\n    } else {\n      monitorEntered();\n    }\n  }\n\n  public static monitorexit(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    var monitorObj: JVMTypes.java_lang_Object = frame.opStack.pop();\n    if (monitorObj.getMonitor().exit(thread)) {\n      frame.pc++;\n    } else {\n      // monitorexit failed, and threw an exception.\n      frame.returnToThreadLoop = true;\n    }\n  }\n\n  public static multianewarray(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (classRef.isResolved()) {\n      // Rewrite and rerun.\n      code.writeUInt8(enums.OpCode.MULTIANEWARRAY_FAST, pc);\n    } else {\n      resolveCPItem(thread, frame, classRef);\n    }\n  }\n\n  public static multianewarray_fast(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var classRef = <ConstantPool.ClassReference> frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1)),\n      opStack = frame.opStack,\n      dim = code.readUInt8(pc + 3),\n      i: number,\n      // Arguments to the constructor.\n      args = new Array<number>(dim), dimSize: number;\n\n    for (i = 0; i < dim; i++) {\n      dimSize = opStack.pop();\n      args[dim - i - 1] = dimSize;\n      if (dimSize < 0) {\n        throwException(thread, frame, 'Ljava/lang/NegativeArraySizeException;', `Tried to init ${classRef.cls.getInternalName()} array with a dimension of length ${dimSize}`);\n        return;\n      }\n    }\n    opStack.push(new (classRef.cls.getConstructor(thread))(thread, args));\n    frame.pc += 4;\n  }\n\n  public static ifnull(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() == null) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static ifnonnull(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    if (frame.opStack.pop() != null) {\n      const offset = code.readInt16BE(pc + 1);\n      frame.pc += offset;\n      if (offset < 0) {\n        frame.method.incrBBEntries();\n      }\n    } else {\n      frame.pc += 3;\n    }\n  }\n\n  public static goto_w(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    const offset = code.readInt32BE(pc + 1);\n    frame.pc += offset;\n    if (offset < 0) {\n      frame.method.incrBBEntries();\n    }\n  }\n\n  public static jsr_w(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    frame.opStack.push(frame.pc + 5);\n    frame.pc += code.readInt32BE(pc + 1);\n  }\n\n  public static nop(thread: threading.JVMThread, frame: threading.BytecodeStackFrame) {\n    frame.pc += 1;\n  }\n\n  public static ldc(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var constant = frame.method.cls.constantPool.get(code.readUInt8(pc + 1));\n    if (constant.isResolved()) {\n      assert((() => {\n        switch (constant.getType()) {\n          case enums.ConstantPoolItemType.STRING:\n          case enums.ConstantPoolItemType.CLASS:\n          case enums.ConstantPoolItemType.METHOD_HANDLE:\n          case enums.ConstantPoolItemType.METHOD_TYPE:\n          case enums.ConstantPoolItemType.INTEGER:\n          case enums.ConstantPoolItemType.FLOAT:\n            return true;\n          default:\n            return false;\n        }\n      })(), `Constant pool item ${enums.ConstantPoolItemType[constant.getType()]} is not appropriate for LDC.`);\n      frame.opStack.push(constant.getConstant(thread));\n      frame.pc += 2;\n    } else {\n      resolveCPItem(thread, frame, constant);\n    }\n  }\n\n  public static ldc_w(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var constant = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    if (constant.isResolved()) {\n      assert((() => {\n        switch (constant.getType()) {\n          case enums.ConstantPoolItemType.STRING:\n          case enums.ConstantPoolItemType.CLASS:\n          case enums.ConstantPoolItemType.METHOD_HANDLE:\n          case enums.ConstantPoolItemType.METHOD_TYPE:\n          case enums.ConstantPoolItemType.INTEGER:\n          case enums.ConstantPoolItemType.FLOAT:\n            return true;\n          default:\n            return false;\n        }\n      })(), `Constant pool item ${enums.ConstantPoolItemType[constant.getType()]} is not appropriate for LDC_W.`);\n      frame.opStack.push(constant.getConstant(thread));\n      frame.pc += 3;\n    } else {\n      resolveCPItem(thread, frame, constant);\n    }\n  }\n\n  public static ldc2_w(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var constant = frame.method.cls.constantPool.get(code.readUInt16BE(pc + 1));\n    assert(constant.getType() === enums.ConstantPoolItemType.LONG\n      || constant.getType() === enums.ConstantPoolItemType.DOUBLE,\n      `Invalid ldc_w constant pool type: ${enums.ConstantPoolItemType[constant.getType()]}`);\n    frame.opStack.pushWithNull((<ConstantPool.ConstLong | ConstantPool.ConstDouble> constant).value);\n    frame.pc += 3;\n  }\n\n  public static wide(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, code: Buffer) {\n    const pc = frame.pc;\n    var index = code.readUInt16BE(pc + 2);\n    // Increment PC before switch to avoid issue where ret chances PC and we\n    // erroneously increment the PC further.\n    frame.pc += 4;\n    switch (code.readUInt8(pc + 1)) {\n      case enums.OpCode.ILOAD:\n      case enums.OpCode.FLOAD:\n      case enums.OpCode.ALOAD:\n        frame.opStack.push(frame.locals[index]);\n        break;\n      case enums.OpCode.LLOAD:\n      case enums.OpCode.DLOAD:\n        frame.opStack.pushWithNull(frame.locals[index]);\n        break;\n      case enums.OpCode.ISTORE:\n      case enums.OpCode.FSTORE:\n      case enums.OpCode.ASTORE:\n        frame.locals[index] = frame.opStack.pop();\n        break;\n      case enums.OpCode.LSTORE:\n      case enums.OpCode.DSTORE:\n        // NULL\n        frame.locals[index + 1] = frame.opStack.pop();\n        // The actual value.\n        frame.locals[index] = frame.opStack.pop();\n        break;\n      case enums.OpCode.RET:\n        frame.pc = frame.locals[index];\n        break;\n      case enums.OpCode.IINC:\n        var value = code.readInt16BE(pc + 4);\n        frame.locals[index] = (frame.locals[index] + value) | 0;\n        // wide iinc has 2 extra bytes.\n        frame.pc += 2;\n        break;\n      default:\n        assert(false, `Unknown wide opcode: ${code.readUInt8(pc + 1)}`);\n        break;\n    }\n  }\n}\n\nexport var LookupTable: IOpcodeImplementation[] = new Array(0xff);\n// Put in function closure to prevent scope pollution.\n(() => {\n  for (var i = 0; i < 0xff; i++) {\n    if (enums.OpCode.hasOwnProperty(\"\" + i)) {\n      LookupTable[i] = (<any> Opcodes)[enums.OpCode[i].toLowerCase()];\n      assert(LookupTable[i] != null, `Missing implementation of opcode ${enums.OpCode[i]}`);\n    }\n  }\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/opcodes.ts\n **/","\"use strict\";\nimport gLong = require('./gLong');\nimport enums = require('./enums');\n\n// default module: logging\n\n// used for debugging the stack and local variables\nexport function debug_var(e: any): string {\n  if (e === null) {\n    return '!';\n  } else if (e === void 0) {\n    return 'undef';\n  } else if (e.ref != null) {\n    return \"*\" + e.ref;\n  } else if (e instanceof gLong) {\n    return e + \"L\";\n  }\n  return e;\n}\n\n// used for debugging the stack and local variables\nexport function debug_vars(arr: any[]): string[] {\n  return arr.map<string>(debug_var);\n}\n\n// log levels\n// TODO: turn this into an enum, if possible\nexport var VTRACE = 10;\nexport var TRACE = 9;\nexport var DEBUG = 5;\nexport var ERROR = 1;\nexport var log_level = ERROR;\n\nfunction log(level: number, msgs: any[]): void {\n  if (level <= log_level) {\n    var msg = msgs.join(' ');\n    if (level == 1) {\n      console.error(msg);\n    } else {\n      console.log(msg);\n    }\n  }\n}\n\nexport function vtrace(...msgs: any[]): void {\n  log(VTRACE, msgs);\n}\n\nexport function trace(...msgs: any[]): void {\n  log(TRACE, msgs);\n}\n\nexport function debug(...msgs: any[]): void {\n  log(DEBUG, msgs);\n}\n\nexport function error(...msgs: any[]): void {\n  log(ERROR, msgs);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/logging.ts\n **/","/**\n * Utility class. \"stream\" out string data, and compile into a single string.\n */\nclass StringOutputStream {\n  private _data: string[] = [];\n  public write(data: string) { this._data.push(data); }\n  public flush(): string {\n    var rv = this._data.join(\"\");\n    this._data = [];\n    return rv;\n  }\n\n}\n\nexport = StringOutputStream;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/StringOutputStream.ts\n **/","/**\n * Exports the global scope variable.\n * In the main browser thread, this is \"window\".\n * In a WebWorker, this is \"self\".\n * In Node, this is \"global\".\n */\ndeclare var global: any;\nvar toExport: any;\nif (typeof(window) !== 'undefined') {\n  toExport = window;\n} else if (typeof(self) !== 'undefined') {\n  toExport = self;\n} else {\n  toExport = global;\n}\nexport = toExport;\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/global.ts\n **/","\"use strict\";\n\nimport enums = require('./enums');\nimport opcodes = require('./opcodes');\nimport {Method} from './methods';\nimport ConstantPool = require('./ConstantPool');\n\n\nexport interface JitInfo {\n  pops: number,                 // If negative, then it is treated a request rather than a demand\n  pushes: number,\n  hasBranch: boolean,\n  emit: (pops: string[], pushes: string[], suffix: string, onSuccess: string, code: Buffer, pc: number, onErrorPushes: string[], method: Method) => string\n}\n\nfunction makeOnError(onErrorPushes: string[], pc: number) {\n  return onErrorPushes.length > 0 ? `f.pc=${pc};f.opStack.pushAll(${onErrorPushes.join(',')});` : `f.pc=${pc};`;\n}\n\nconst escapeStringRegEx = /\\\\/g;\n\nexport const opJitInfo: JitInfo[] = function() {\n\n// Intentionally indented higher: emitted code is shorter.\n\nconst table:JitInfo[] = [];\nconst OpCode = enums.OpCode;\n\ntable[OpCode.ACONST_NULL] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.ICONST_M1] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=-1;${onSuccess}`;\n}};\n\nconst load0_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[0];${onSuccess}`;\n}};\n\nconst load1_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[1];${onSuccess}`;\n}};\n\nconst load2_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[2];${onSuccess}`;\n}};\n\nconst load3_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[3];${onSuccess}`;\n}};\n\ntable[OpCode.ALOAD_0] = load0_32;\ntable[OpCode.ILOAD_0] = load0_32;\ntable[OpCode.FLOAD_0] = load0_32;\n\ntable[OpCode.ALOAD_1] = load1_32;\ntable[OpCode.ILOAD_1] = load1_32;\ntable[OpCode.FLOAD_1] = load1_32;\n\ntable[OpCode.ALOAD_2] = load2_32;\ntable[OpCode.ILOAD_2] = load2_32;\ntable[OpCode.FLOAD_2] = load2_32;\n\ntable[OpCode.ALOAD_3] = load3_32;\ntable[OpCode.ILOAD_3] = load3_32;\ntable[OpCode.FLOAD_3] = load3_32;\n\nconst load0_64: JitInfo = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[0],${pushes[1]}=null;${onSuccess}`;\n}};\n\nconst load1_64: JitInfo = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[1],${pushes[1]}=null;${onSuccess}`;\n}};\n\nconst load2_64: JitInfo = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[2],${pushes[1]}=null;${onSuccess}`;\n}};\n\nconst load3_64: JitInfo = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=f.locals[3],${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.LLOAD_0] = load0_64;\ntable[OpCode.DLOAD_0] = load0_64;\n\ntable[OpCode.LLOAD_1] = load1_64;\ntable[OpCode.DLOAD_1] = load1_64;\n\ntable[OpCode.LLOAD_2] = load2_64;\ntable[OpCode.DLOAD_2] = load2_64;\n\ntable[OpCode.LLOAD_3] = load3_64;\ntable[OpCode.DLOAD_3] = load3_64;\n\nconst store0_32: JitInfo = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[0]=${pops[0]};${onSuccess}`;\n}}\n\nconst store1_32: JitInfo = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[1]=${pops[0]};${onSuccess}`;\n}}\n\nconst store2_32: JitInfo = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[2]=${pops[0]};${onSuccess}`;\n}}\n\nconst store3_32: JitInfo = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[3]=${pops[0]};${onSuccess}`;\n}}\n\ntable[OpCode.ASTORE_0] = store0_32;\ntable[OpCode.ISTORE_0] = store0_32;\ntable[OpCode.FSTORE_0] = store0_32;\n\ntable[OpCode.ASTORE_1] = store1_32;\ntable[OpCode.ISTORE_1] = store1_32;\ntable[OpCode.FSTORE_1] = store1_32;\n\ntable[OpCode.ASTORE_2] = store2_32;\ntable[OpCode.ISTORE_2] = store2_32;\ntable[OpCode.FSTORE_2] = store2_32;\n\ntable[OpCode.ASTORE_3] = store3_32;\ntable[OpCode.ISTORE_3] = store3_32;\ntable[OpCode.FSTORE_3] = store3_32;\n\nconst store_64: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const offset = code.readUInt8(pc + 1);\n  return `f.locals[${offset+1}]=${pops[0]};f.locals[${offset}]=${pops[1]};${onSuccess}`;\n}}\n\nconst store0_64: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[1]=${pops[0]};f.locals[0]=${pops[1]};${onSuccess}`;\n}}\n\nconst store1_64: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[2]=${pops[0]};f.locals[1]=${pops[1]};${onSuccess}`;\n}}\n\nconst store2_64: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[3]=${pops[0]};f.locals[2]=${pops[1]};${onSuccess}`;\n}}\n\nconst store3_64: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `f.locals[4]=${pops[0]};f.locals[3]=${pops[1]};${onSuccess}`;\n}}\n\ntable[OpCode.LSTORE] = store_64;\ntable[OpCode.DSTORE] = store_64;\n\ntable[OpCode.LSTORE_0] = store0_64;\ntable[OpCode.DSTORE_0] = store0_64;\n\ntable[OpCode.LSTORE_1] = store1_64;\ntable[OpCode.DSTORE_1] = store1_64;\n\ntable[OpCode.LSTORE_2] = store2_64;\ntable[OpCode.DSTORE_2] = store2_64;\n\ntable[OpCode.LSTORE_3] = store3_64;\ntable[OpCode.DSTORE_3] = store3_64;\n\nconst const0_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=0;${onSuccess}`;\n}}\nconst const1_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=1;${onSuccess}`;\n}}\nconst const2_32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=2;${onSuccess}`;\n}}\n\n\ntable[OpCode.ICONST_0] = const0_32;\ntable[OpCode.ICONST_1] = const1_32;\ntable[OpCode.ICONST_2] = const2_32;\n\ntable[OpCode.FCONST_0] = const0_32;\ntable[OpCode.FCONST_1] = const1_32;\ntable[OpCode.FCONST_2] = const2_32;\n\ntable[OpCode.ICONST_3] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=3;${onSuccess}`;\n}}\n\ntable[OpCode.ICONST_4] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=4;${onSuccess}`;\n}}\n\ntable[OpCode.ICONST_5] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=5;${onSuccess}`;\n}}\n\ntable[OpCode.LCONST_0] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.gLong.ZERO,${pushes[1]}=null;${onSuccess}`;\n}}\n\ntable[OpCode.LCONST_1] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.gLong.ONE,${pushes[1]}=null;${onSuccess}`;\n}}\n\ntable[OpCode.DCONST_0] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=0,${pushes[1]}=null;${onSuccess}`;\n}}\n\ntable[OpCode.DCONST_1] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=1,${pushes[1]}=null;${onSuccess}`;\n}}\n\nconst aload32: JitInfo = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(!u.isNull(t,f,${pops[1]})){\nvar len${suffix}=${pops[1]}.array.length;\nif(${pops[0]}<0||${pops[0]}>=len${suffix}){\n${onError}\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\"\"+${pops[0]}+\" not in length \"+len${suffix}+\" array of type \"+${pops[1]}.getClass().getInternalName());\n}else{var ${pushes[0]}=${pops[1]}.array[${pops[0]}];${onSuccess}}\n}else{${onError}}`;\n}}\n\n\ntable[OpCode.IALOAD] = aload32;\ntable[OpCode.FALOAD] = aload32;\ntable[OpCode.AALOAD] = aload32;\ntable[OpCode.BALOAD] = aload32;\ntable[OpCode.CALOAD] = aload32;\ntable[OpCode.SALOAD] = aload32;\n\nconst aload64: JitInfo = {hasBranch: false, pops: 2, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(!u.isNull(t,f,${pops[1]})){\nvar len${suffix}=${pops[1]}.array.length;\nif(${pops[0]}<0||${pops[0]}>=len${suffix}){\n${onError}\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\"\"+${pops[0]}+\" not in length \"+len${suffix}+\" array of type \"+${pops[1]}.getClass().getInternalName());\n}else{var ${pushes[0]}=${pops[1]}.array[${pops[0]}],${pushes[1]}=null;${onSuccess}}\n}else{${onError}}`;\n}}\n\n\ntable[OpCode.DALOAD] = aload64;\ntable[OpCode.LALOAD] = aload64;\n\nconst astore32: JitInfo = {hasBranch: false, pops: 3, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(!u.isNull(t,f,${pops[2]})){\nvar len${suffix}=${pops[2]}.array.length;\nif(${pops[1]}<0||${pops[1]}>=len${suffix}){\n${onError}\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\"\"+${pops[1]}+\" not in length \"+len${suffix}+\" array of type \"+${pops[2]}.getClass().getInternalName());\n}else{${pops[2]}.array[${pops[1]}]=${pops[0]};${onSuccess}}\n}else{${onError}}`;\n}}\n\n\ntable[OpCode.IASTORE] = astore32;\ntable[OpCode.FASTORE] = astore32;\ntable[OpCode.AASTORE] = astore32;\ntable[OpCode.BASTORE] = astore32;\ntable[OpCode.CASTORE] = astore32;\ntable[OpCode.SASTORE] = astore32;\n\nconst astore64: JitInfo = {hasBranch: false, pops: 4, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(!u.isNull(t,f,${pops[3]})){\nvar len${suffix}=${pops[3]}.array.length;\nif(${pops[2]}<0||${pops[2]}>=len${suffix}){\n${onError}\nu.throwException(t,f,'Ljava/lang/ArrayIndexOutOfBoundsException;',\"\"+${pops[2]}+\" not in length \"+len${suffix}+\" array of type \"+${pops[3]}.getClass().getInternalName());\n}else{${pops[3]}.array[${pops[2]}]=${pops[1]};${onSuccess}}\n}else{${onError}}`;\n}}\n\n\ntable[OpCode.DASTORE] = astore64;\ntable[OpCode.LASTORE] = astore64;\n\n// TODO: get the constant at JIT time ?\ntable[OpCode.LDC] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const index = code.readUInt8(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nvar cnst${suffix}=f.method.cls.constantPool.get(${index});\nif(cnst${suffix}.isResolved()){var ${pushes[0]}=cnst${suffix}.getConstant(t);${onSuccess}\n}else{${onError}u.resolveCPItem(t,f,cnst${suffix});}`;\n}};\n\n// TODO: get the constant at JIT time ?\ntable[OpCode.LDC_W] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const index = code.readUInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nvar cnst${suffix}=f.method.cls.constantPool.get(${index});\nif(cnst${suffix}.isResolved()){var ${pushes[0]}=cnst${suffix}.getConstant(t);${onSuccess}\n}else{${onError}u.resolveCPItem(t,f,cnst${suffix});}`;\n}};\n\n// TODO: get the constant at JIT time ?\ntable[OpCode.LDC2_W] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt16BE(pc + 1);\n  return `var ${pushes[0]}=f.method.cls.constantPool.get(${index}).value,${pushes[1]}=null;${onSuccess}`;\n}};\n\n// TODO: get the field info at JIT time ?\ntable[OpCode.GETSTATIC_FAST32] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt16BE(pc + 1);\n  return `var fi${suffix}=f.method.cls.constantPool.get(${index}),${pushes[0]}=fi${suffix}.fieldOwnerConstructor[fi${suffix}.fullFieldName];${onSuccess}`;\n}};\n\n// TODO: get the field info at JIT time ?\ntable[OpCode.GETSTATIC_FAST64] = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt16BE(pc + 1);\n  return `\nvar fi${suffix}=f.method.cls.constantPool.get(${index}),${pushes[0]}=fi${suffix}.fieldOwnerConstructor[fi${suffix}.fullFieldName],\n${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.GETFIELD_FAST32] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  const index = code.readUInt16BE(pc + 1);\n  const fieldInfo = <ConstantPool.FieldReference> method.cls.constantPool.get(index);\n  const name = fieldInfo.fullFieldName.replace(escapeStringRegEx, \"\\\\\\\\\")\n  return `if(!u.isNull(t,f,${pops[0]})){var ${pushes[0]}=${pops[0]}['${name}'];${onSuccess}}else{${onError}}`;\n}};\n\ntable[OpCode.GETFIELD_FAST64] = {hasBranch: false, pops: 1, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  const index = code.readUInt16BE(pc + 1);\n  const fieldInfo = <ConstantPool.FieldReference> method.cls.constantPool.get(index);\n  const name = fieldInfo.fullFieldName.replace(escapeStringRegEx, \"\\\\\\\\\")\n  return `if(!u.isNull(t,f,${pops[0]})){var ${pushes[0]}=${pops[0]}['${name}'],${pushes[1]}=null;${onSuccess}}else{${onError}}`;\n}};\n\ntable[OpCode.PUTFIELD_FAST32] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  const index = code.readUInt16BE(pc + 1);\n  const fieldInfo = <ConstantPool.FieldReference> method.cls.constantPool.get(index);\n  const name = fieldInfo.fullFieldName.replace(escapeStringRegEx, \"\\\\\\\\\")\n  return `if(!u.isNull(t,f,${pops[1]})){${pops[1]}['${name}']=${pops[0]};${onSuccess}}else{${onError}}`;\n}};\n\ntable[OpCode.PUTFIELD_FAST64] = {hasBranch: false, pops: 3, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  const index = code.readUInt16BE(pc + 1);\n  const fieldInfo = <ConstantPool.FieldReference> method.cls.constantPool.get(index);\n  const name = fieldInfo.fullFieldName.replace(escapeStringRegEx, \"\\\\\\\\\")\n  return `if(!u.isNull(t,f,${pops[2]})){${pops[2]}['${name}']=${pops[1]};${onSuccess}}else{${onError}}`;\n}};\n\n// TODO: get the constant at JIT time ?\ntable[OpCode.INSTANCEOF_FAST] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt16BE(pc + 1);\n  return `var cls${suffix}=f.method.cls.constantPool.get(${index}).cls,${pushes[0]}=${pops[0]}!==null?(${pops[0]}.getClass().isCastable(cls${suffix})?1:0):0;${onSuccess}`;\n}};\n\ntable[OpCode.CHECKCAST_FAST] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  const index = code.readUInt16BE(pc + 1);\n  const classRef = <ConstantPool.ClassReference> method.cls.constantPool.get(index),\n    targetClass = classRef.cls.getExternalName();\n  return `var cls${suffix}=f.method.cls.constantPool.get(${index}).cls;\nif((${pops[0]}!=null)&&!${pops[0]}.getClass().isCastable(cls${suffix})){\nu.throwException(t,f,'Ljava/lang/ClassCastException;',${pops[0]}.getClass().getExternalName()+' cannot be cast to ${targetClass}');\n}else{var ${pushes[0]}=${pops[0]};${onSuccess}}`\n}};\n\ntable[OpCode.ARRAYLENGTH] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `if(!u.isNull(t,f,${pops[0]})){var ${pushes[0]}=${pops[0]}.array.length;${onSuccess}}else{${onError}}`;\n}};\n\nconst load32: JitInfo = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt8(pc + 1);\n  return `var ${pushes[0]}=f.locals[${index}];${onSuccess}`;\n}}\n\ntable[OpCode.ILOAD] = load32;\ntable[OpCode.ALOAD] = load32;\ntable[OpCode.FLOAD] = load32;\n\nconst load64: JitInfo = {hasBranch: false, pops: 0, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt8(pc + 1);\n  return `var ${pushes[0]}=f.locals[${index}],${pushes[1]}=null;${onSuccess}`;\n}}\n\ntable[OpCode.LLOAD] = load64;\ntable[OpCode.DLOAD] = load64;\n\nconst store32: JitInfo = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt8(pc + 1);\n  return `f.locals[${index}]=${pops[0]};${onSuccess}`;\n}}\n\ntable[OpCode.ISTORE] = store32;\ntable[OpCode.ASTORE] = store32;\ntable[OpCode.FSTORE] = store32;\n\ntable[OpCode.BIPUSH] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const value = code.readInt8(pc + 1);\n  return `var ${pushes[0]}=${value};${onSuccess}`;\n}};\n\ntable[OpCode.SIPUSH] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const value = code.readInt16BE(pc + 1);\n  return `var ${pushes[0]}=${value};${onSuccess}`;\n}};\n\ntable[OpCode.IINC] = {hasBranch: false, pops: 0, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const idx = code.readUInt8(pc + 1);\n  const val = code.readInt8(pc + 2);\n  return `f.locals[${idx}]=(f.locals[${idx}]+${val})|0;${onSuccess}`;\n}};\n\n// This is marked as hasBranch: true to stop further opcode inclusion during JITC. The name of \"hasBranch\" ought to be changed.\ntable[OpCode.ATHROW] = {hasBranch: true, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `${onError}t.throwException(${pops[0]});f.returnToThreadLoop=true;`;\n}};\n\ntable[OpCode.GOTO] = {hasBranch: true, pops: 0, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const offset = code.readInt16BE(pc + 1);\n  return `f.pc=${pc + offset};${onSuccess}`;\n}};\n\ntable[OpCode.TABLESWITCH] = {hasBranch: true, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  // Ignore padding bytes. The +1 is to skip the opcode byte.\n  const alignedPC = pc + ((4 - (pc + 1) % 4) % 4) + 1;\n  const defaultOffset = code.readInt32BE(alignedPC),\n    low = code.readInt32BE(alignedPC + 4),\n    high = code.readInt32BE(alignedPC + 8);\n  if ((high - low) < 8) {\n    let emitted = `switch(${pops[0]}){`;\n    for (let i = low; i <= high; i++) {\n      const offset = code.readInt32BE(alignedPC + 12+((i-low)*4));\n      emitted += `case ${i}:f.pc=${pc + offset};break;`;\n    }\n    emitted += `default:f.pc=${pc + defaultOffset}}${onSuccess}`\n    return emitted;\n  } else {\n    return `if(${pops[0]}>=${low}&&${pops[0]}<=${high}){f.pc=${pc}+f.method.getCodeAttribute().getCode().readInt32BE(${alignedPC + 12}+((${pops[0]} - ${low})*4))}else{f.pc=${pc + defaultOffset}}${onSuccess}`;\n  }\n}};\n\nconst cmpeq: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}===${pops[1]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IF_ICMPEQ] = cmpeq;\ntable[OpCode.IF_ACMPEQ] = cmpeq;\n\nconst cmpne: JitInfo = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}!==${pops[1]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IF_ICMPNE] = cmpne;\ntable[OpCode.IF_ACMPNE] = cmpne;\n\ntable[OpCode.IF_ICMPGE] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[1]}>=${pops[0]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IF_ICMPGT] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[1]}>${pops[0]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IF_ICMPLE] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[1]}<=${pops[0]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IF_ICMPLT] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[1]}<${pops[0]}){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFNULL] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}==null){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFNONNULL] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}!=null){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFEQ] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}===0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFNE] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}!==0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFGT] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}>0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFLT] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}<0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFGE] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}>=0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.IFLE] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const offset = code.readInt16BE(pc + 1);\n  const onError = makeOnError(onErrorPushes, pc + offset);\n  return `if(${pops[0]}<=0){${onError}}else{${onSuccess}}`;\n}};\n\ntable[OpCode.LCMP] = {hasBranch: false, pops: 4, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}.compare(${pops[1]});${onSuccess}`;\n}};\n\ntable[OpCode.FCMPL] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}===${pops[1]}?0:(${pops[1]}>${pops[0]}?1:-1);${onSuccess}`;\n}};\n\ntable[OpCode.DCMPL] = {hasBranch: false, pops: 4, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}===${pops[1]}?0:(${pops[3]}>${pops[1]}?1:-1);${onSuccess}`;\n}};\n\ntable[OpCode.FCMPG] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}===${pops[1]}?0:(${pops[1]}<${pops[0]}?-1:1);${onSuccess}`;\n}};\n\ntable[OpCode.DCMPG] = {hasBranch: false, pops: 4, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}===${pops[1]}?0:(${pops[3]}<${pops[1]}?-1:1);${onSuccess}`;\n}};\n\ntable[OpCode.RETURN] = {hasBranch: true, pops: 0, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  // TODO: on error pushes\n  if (method.accessFlags.isSynchronized()) {\n    return `f.pc=${pc};f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn();`;\n  } else {\n    return `f.pc=${pc};f.returnToThreadLoop=true;t.asyncReturn();`;\n  }\n}};\n\nconst return32: JitInfo = {hasBranch: true, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  // TODO: on error pushes\n  if (method.accessFlags.isSynchronized()) {\n    return `f.pc=${pc};f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn(${pops[0]});`;\n  } else {\n    return `f.pc=${pc};f.returnToThreadLoop=true;t.asyncReturn(${pops[0]});`;\n  }\n}};\ntable[OpCode.IRETURN] = return32;\ntable[OpCode.FRETURN] = return32;\ntable[OpCode.ARETURN] = return32;\n\nconst return64: JitInfo = {hasBranch: true, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes, method) => {\n  // TODO: on error pushes\n  if (method.accessFlags.isSynchronized()) {\n    return `f.pc=${pc};f.returnToThreadLoop=true;if(!f.method.methodLock(t,f).exit(t)){return}t.asyncReturn(${pops[1]},null);`;\n  } else {\n    return `f.pc=${pc};f.returnToThreadLoop=true;t.asyncReturn(${pops[1]},null);`;\n  }\n}};\ntable[OpCode.LRETURN] = return64;\ntable[OpCode.DRETURN] = return64;\n\ntable[OpCode.MONITOREXIT] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `if(${pops[0]}.getMonitor().exit(t)){${onSuccess}}else{${onError}f.returnToThreadLoop=true;}`;\n}};\n\ntable[OpCode.IXOR] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}^${pops[1]};${onSuccess}`;\n}};\n\ntable[OpCode.LXOR] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.xor(${pops[3]}),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IOR] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}|${pops[1]};${onSuccess}`;\n}};\n\ntable[OpCode.LOR] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}.or(${pops[1]}),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IAND] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}&${pops[1]};${onSuccess}`;\n}};\n\ntable[OpCode.LAND] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}.and(${pops[1]}),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IADD] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(${pops[0]}+${pops[1]})|0;${onSuccess}`;\n}};\n\ntable[OpCode.LADD] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.add(${pops[3]}),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.DADD] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}+${pops[3]},${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IMUL] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=Math.imul(${pops[0]}, ${pops[1]});${onSuccess}`;\n}};\n\ntable[OpCode.FMUL] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.wrapFloat(${pops[0]}*${pops[1]});${onSuccess}`;\n}};\n\ntable[OpCode.LMUL] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}.multiply(${pops[1]}),${pushes[1]}= null;${onSuccess}`;\n}};\n\ntable[OpCode.DMUL] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}*${pops[1]},${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IDIV] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(${pops[0]}===0){${onError}u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\n}else{var ${pushes[0]}=(${pops[1]}===u.Constants.INT_MIN&&${pops[0]}===-1)?${pops[1]}:((${pops[1]}/${pops[0]})|0);${onSuccess}}`;\n}};\n\ntable[OpCode.LDIV] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nif(${pops[1]}.isZero()){${onError}u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\n}else{var ${pushes[0]}=${pops[3]}.div(${pops[1]}),${pushes[1]}=null;${onSuccess}}`;\n}};\n\ntable[OpCode.DDIV] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}/${pops[1]},${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.ISUB] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(${pops[1]}-${pops[0]})|0;${onSuccess}`;\n}};\n\ntable[OpCode.LSUB] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.negate().add(${pops[3]}),${pushes[1]}= null;${onSuccess}`;\n}};\n\ntable[OpCode.DSUB] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}-${pops[1]},${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IREM] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `if(${pops[0]}===0){${onError}u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\n}else{var ${pushes[0]}=${pops[1]}%${pops[0]};${onSuccess}}`;\n}};\n\ntable[OpCode.LREM] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const onError = makeOnError(onErrorPushes, pc);\n  return `if(${pops[1]}.isZero()){${onError}u.throwException(t,f,'Ljava/lang/ArithmeticException;','/ by zero');\n}else{var ${pushes[0]}=${pops[3]}.modulo(${pops[1]}),${pushes[1]}=null;${onSuccess}}`;\n}};\n\ntable[OpCode.DREM] = {hasBranch: false, pops: 4, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[3]}%${pops[1]},${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.INEG] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(-${pops[0]})|0;${onSuccess}`;\n}};\n\ntable[OpCode.LNEG] = {hasBranch: false, pops: 2, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.negate(),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.ISHL] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}<<${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.LSHL] = {hasBranch: false, pops: 3, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[2]}.shiftLeft(u.gLong.fromInt(${pops[0]})),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.ISHR] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}>>${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.LSHR] = {hasBranch: false, pops: 3, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[2]}.shiftRight(u.gLong.fromInt(${pops[0]})),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.IUSHR] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(${pops[1]}>>>${pops[0]})|0;${onSuccess}`;\n}};\n\ntable[OpCode.LUSHR] = {hasBranch: false, pops: 3, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[2]}.shiftRightUnsigned(u.gLong.fromInt(${pops[0]})),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.I2B] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(${pops[0]}<<24)>>24;${onSuccess}`;\n}};\n\ntable[OpCode.I2S] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=(${pops[0]}<<16)>>16;${onSuccess}`;\n}};\n\ntable[OpCode.I2C] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]}&0xFFFF;${onSuccess}`;\n}};\n\ntable[OpCode.I2L] = {hasBranch: false, pops: 1, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.gLong.fromInt(${pops[0]}),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.I2F] = {hasBranch: false, pops: 0, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `${onSuccess}`;\n}};\n\ntable[OpCode.I2D] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.F2I] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.float2int(${pops[0]});${onSuccess}`;\n}};\n\ntable[OpCode.F2D] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.L2I] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.toInt();${onSuccess}`;\n}};\n\ntable[OpCode.L2D] = {hasBranch: false, pops: 2, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]}.toNumber(),${pushes[1]}=null;${onSuccess}`;\n}};\n\ntable[OpCode.D2I] = {hasBranch: false, pops: 2, pushes: 1, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=u.float2int(${pops[1]});${onSuccess}`;\n}};\n\n// TODO: update the DUPs when peeking is supported\ntable[OpCode.DUP] = {hasBranch: false, pops: 1, pushes: 2, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]},${pushes[1]}=${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.DUP2] = {hasBranch: false, pops: 2, pushes: 4, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]},${pushes[1]}=${pops[0]},${pushes[2]}=${pops[1]},${pushes[3]}=${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.DUP_X1] = {hasBranch: false, pops: 2, pushes: 3, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]},${pushes[1]}=${pops[1]},${pushes[2]}=${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.DUP_X2] = {hasBranch: false, pops: 3, pushes: 4, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[0]},${pushes[1]}=${pops[2]},${pushes[2]}=${pops[1]},${pushes[3]}=${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.DUP2_X1] = {hasBranch: false, pops: 3, pushes: 5, emit: (pops, pushes, suffix, onSuccess) => {\n  return `var ${pushes[0]}=${pops[1]},${pushes[1]}=${pops[0]},${pushes[2]}=${pops[2]},${pushes[3]}=${pops[1]},${pushes[4]}=${pops[0]};${onSuccess}`;\n}};\n\ntable[OpCode.NEW_FAST] = {hasBranch: false, pops: 0, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc) => {\n  const index = code.readUInt16BE(pc + 1);\n  return `var cr${suffix}=f.method.cls.constantPool.get(${index}),${pushes[0]}=(new cr${suffix}.clsConstructor(t));${onSuccess}`;\n}};\n\ntable[OpCode.NEWARRAY] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const index = code.readUInt8(pc + 1);\n  const arrayType = \"[\" + opcodes.ArrayTypes[index];\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nvar cls${suffix}=f.getLoader().getInitializedClass(t,'${arrayType}');\nif(${pops[0]}>=0){var ${pushes[0]}=new (cls${suffix}.getConstructor(t))(t,${pops[0]});${onSuccess}\n}else{${onError}u.throwException(t,f,'Ljava/lang/NegativeArraySizeException;','Tried to init ${arrayType} array with length '+${pops[0]});}`;\n}};\n\ntable[OpCode.ANEWARRAY_FAST] = {hasBranch: false, pops: 1, pushes: 1, emit: (pops, pushes, suffix, onSuccess, code, pc, onErrorPushes) => {\n  const index = code.readUInt16BE(pc + 1);\n  const arrayType = \"[\" + opcodes.ArrayTypes[index];\n  const onError = makeOnError(onErrorPushes, pc);\n  return `\nvar cr${suffix}=f.method.cls.constantPool.get(${index});\nif(${pops[0]}>=0){var ${pushes[0]}=new cr${suffix}.arrayClassConstructor(t,${pops[0]});${onSuccess}\n}else{${onError}u.throwException(t,f,'Ljava/lang/NegativeArraySizeException;','Tried to init '+cr${suffix}.arrayClass.getInternalName()+' array with length '+${pops[0]});}`;\n}};\n\ntable[OpCode.NOP] = {hasBranch: false, pops: 0, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `${onSuccess}`;\n}};\n\ntable[OpCode.POP] = {hasBranch: false, pops: 1, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `${onSuccess}`;\n}};\n\ntable[OpCode.POP2] = {hasBranch: false, pops: 2, pushes: 0, emit: (pops, pushes, suffix, onSuccess) => {\n  return `${onSuccess}`;\n}};\n\nreturn table;\n}();\n\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/jit.ts\n **/","import {ClassData, ReferenceClassData, ArrayClassData, PrimitiveClassData} from './ClassData';\nimport threading = require('./threading');\nimport ClassLock = require('./ClassLock');\nimport {IClasspathItem, ClasspathFactory} from './classpath';\nimport {TriState} from './enums';\nimport util = require('./util');\nimport methods = require('./methods');\nimport logging = require('./logging');\nimport assert = require('./assert');\nimport JAR = require('./jar');\nimport path = require('path');\nimport fs = require('fs');\nimport JVMTypes = require('../includes/JVMTypes');\nvar debug = logging.debug;\n\n/**\n * Used to lock classes for loading.\n */\nclass ClassLocks {\n  /**\n   * typrStr => array of callbacks to trigger when operation completes.\n   */\n  private locks: { [typeStr: string]: ClassLock } = {};\n\n  constructor() {}\n\n  /**\n   * Checks if the lock for the given class is already taken. If not, it takes\n   * the lock. If it is taken, we enqueue the callback.\n   * NOTE: For convenience, will handle triggering the owner's callback as well.\n   */\n  public tryLock(typeStr: string, thread: threading.JVMThread, cb: (cdata: ClassData) => void): boolean {\n    if (typeof this.locks[typeStr] === 'undefined') {\n      this.locks[typeStr] = new ClassLock();\n    }\n    return this.locks[typeStr].tryLock(thread, cb);\n  }\n\n  /**\n   * Releases the lock on the given string.\n   */\n  public unlock(typeStr: string, cdata: ClassData): void {\n    this.locks[typeStr].unlock(cdata);\n    // No need for this lock to remain.\n    delete this.locks[typeStr];\n  }\n\n  /**\n   * Returns the owning thread of a given lock. Returns null if the specified\n   * type string is not locked.\n   */\n  public getOwner(typeStr: string): threading.JVMThread {\n    if (this.locks[typeStr]) {\n      return this.locks[typeStr].getOwner();\n    }\n    return null;\n  }\n}\n\n/**\n * Base classloader class. Contains common class resolution and instantiation\n * logic.\n */\nexport abstract class ClassLoader {\n  /**\n   * Stores loaded *reference* and *array* classes.\n   */\n  private loadedClasses: { [typeStr: string]: ClassData } = {};\n  /**\n   * Stores callbacks that are waiting for another thread to finish loading\n   * the specified class.\n   */\n  private loadClassLocks: ClassLocks = new ClassLocks();\n\n  /**\n   * @param bootstrap The JVM's bootstrap classloader. ClassLoaders use it\n   *   to retrieve primitive types.\n   */\n  constructor(public bootstrap: BootstrapClassLoader) { }\n\n  /**\n   * Retrieve a listing of classes that are loaded in this class loader.\n   */\n  public getLoadedClassNames(): string[] {\n    return Object.keys(this.loadedClasses);\n  }\n\n  /**\n   * Adds the specified class to the classloader. As opposed to defineClass,\n   * which defines a new class from bytes with the classloader.\n   *\n   * What's the difference?\n   * * Classes created with defineClass are defined by this classloader.\n   * * Classes added with addClass may have been defined by a different\n   *   classloader. This happens when a custom class loader's loadClass\n   *   function proxies classloading to a different classloader.\n   *\n   * @param typeStr The type string of the class.\n   * @param classData The class data object representing the class.\n   */\n  public addClass(typeStr: string, classData: ClassData): void {\n    // If the class is already added, ensure it is the same class we are adding again.\n    assert(this.loadedClasses[typeStr] != null ? this.loadedClasses[typeStr] === classData : true);\n    this.loadedClasses[typeStr] = classData;\n  }\n\n  /**\n   * No-frills. Get the class if it's defined in the class loader, no matter\n   * what shape it is in.\n   *\n   * Should only be used internally by ClassLoader subclasses.\n   */\n  protected getClass(typeStr: string): ClassData {\n    return this.loadedClasses[typeStr];\n  }\n\n  /**\n   * Defines a new class with the class loader from an array of bytes.\n   * @param thread The thread that is currently in control when this class is\n   *   being defined. An exception may be thrown if there is an issue parsing\n   *   the class file.\n   * @param typeStr The type string of the class (e.g. \"Ljava/lang/Object;\")\n   * @param data The data associated with the class as a binary blob.\n   * @param protectionDomain The protection domain for the class (can be NULL).\n   * @return The defined class, or null if there was an issue.\n   */\n  public defineClass<T extends JVMTypes.java_lang_Object>(thread: threading.JVMThread, typeStr: string, data: Buffer, protectionDomain: JVMTypes.java_security_ProtectionDomain): ReferenceClassData<T> {\n    try {\n      var classData = new ReferenceClassData<T>(data, protectionDomain, this);\n      this.addClass(typeStr, classData);\n      if (this instanceof BootstrapClassLoader) {\n        debug(`[BOOTSTRAP] Defining class ${typeStr}`);\n      } else {\n        debug(`[CUSTOM] Defining class ${typeStr}`);\n      }\n      return classData;\n    } catch (e) {\n      if (thread === null) {\n        // This will only happen when we're loading java/lang/Thread for\n        // the very first time.\n        logging.error(`JVM initialization failed: ${e}`);\n        logging.error(e.stack);\n      } else {\n        thread.throwNewException('Ljava/lang/ClassFormatError;', e);\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Defines a new array class with this loader.\n   */\n  protected defineArrayClass<T>(typeStr: string): ArrayClassData<T> {\n    assert(this.getLoadedClass(util.get_component_type(typeStr)) != null);\n    var arrayClass = new ArrayClassData<T>(util.get_component_type(typeStr), this);\n    this.addClass(typeStr, arrayClass);\n    return arrayClass;\n  }\n\n  /**\n   * Attempts to retrieve the given loaded class.\n   * @param typeStr The name of the class.\n   * @return Returns the loaded class, or null if no such class is currently\n   *   loaded.\n   */\n  public getLoadedClass(typeStr: string): ClassData {\n    var cls = this.loadedClasses[typeStr];\n    if (cls != null) {\n      return cls;\n    } else {\n      if (util.is_primitive_type(typeStr)) {\n        // Primitive classes must be fetched from the bootstrap classloader.\n        return this.bootstrap.getPrimitiveClass(typeStr);\n      } else if (util.is_array_type(typeStr)) {\n        // We might be able to load this array class synchronously.\n        // Component class must be loaded. And we must define the array class\n        // with the component class's loader.\n        var component = this.getLoadedClass(util.get_component_type(typeStr));\n        if (component != null) {\n          var componentCl = component.getLoader();\n          if (componentCl === this) {\n            // We're responsible for defining the array class.\n            return this.defineArrayClass(typeStr);\n          } else {\n            // Delegate to the other loader, then add the class to our loaded\n            // roster.\n            cls = componentCl.getLoadedClass(typeStr);\n            this.addClass(typeStr, cls);\n            return cls;\n          }\n        }\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Attempts to retrieve the given resolved class.\n   * @param typeStr The name of the class.\n   * @return Returns the class if it is both loaded and resolved. Returns null\n   *   if this is not the case.\n   */\n  public getResolvedClass(typeStr: string): ClassData {\n    var cls = this.getLoadedClass(typeStr);\n    if (cls !== null) {\n      if (cls.isResolved() || cls.tryToResolve()) {\n        return cls;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Attempts to retrieve the given initialized class.\n   * @param typeStr The name of the class.\n   * @return Returns the class if it is initialized. Returns null if this is\n   *   not the case.\n   */\n  public getInitializedClass(thread: threading.JVMThread, typeStr: string): ClassData {\n    var cls = this.getLoadedClass(typeStr);\n    if (cls !== null) {\n      if (cls.isInitialized(thread) || cls.tryToInitialize()) {\n        return cls;\n      } else {\n        return null;\n      }\n    } else {\n      return cls;\n    }\n  }\n\n  /**\n   * Asynchronously loads the given class.\n   */\n  public loadClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    // See if we can grab this synchronously first.\n    var cdata = this.getLoadedClass(typeStr);\n    if (cdata) {\n      setImmediate(() => {\n        cb(cdata);\n      });\n    } else {\n      // Check the loadClass lock for this class.\n      if (this.loadClassLocks.tryLock(typeStr, thread, cb)) {\n        // Async it is!\n        if (util.is_reference_type(typeStr)) {\n          this._loadClass(thread, typeStr, (cdata) => {\n            this.loadClassLocks.unlock(typeStr, cdata);\n          }, explicit);\n        } else {\n          // Array\n          this.loadClass(thread, util.get_component_type(typeStr), (cdata) => {\n            if (cdata != null) {\n              // Synchronously will work now.\n              this.loadClassLocks.unlock(typeStr, this.getLoadedClass(typeStr));\n            }\n          }, explicit);\n        }\n      }\n    }\n  }\n\n  /**\n   * Asynchronously loads the given class. Works differently for bootstrap and\n   * custom class loaders.\n   *\n   * Should never be invoked directly! Use loadClass.\n   */\n  protected abstract _loadClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit?: boolean): void;\n\n  /**\n   * Convenience function: Resolve many classes. Calls cb with null should\n   * an error occur.\n   */\n  public resolveClasses(thread: threading.JVMThread, typeStrs: string[], cb: (classes: { [typeStr: string]: ClassData }) => void) {\n    var classes: { [typeStr: string]: ClassData } = {};\n    util.asyncForEach<string>(typeStrs, (typeStr: string, next_item: (err?: any) => void) => {\n      this.resolveClass(thread, typeStr, (cdata) => {\n        if (cdata === null) {\n          next_item(`Error resolving class: ${typeStr}`);\n        } else {\n          classes[typeStr] = cdata;\n          next_item();\n        }\n      });\n    }, (err?: any): void => {\n      if (err) {\n        cb(null);\n      } else {\n        cb(classes);\n      }\n    });\n  }\n\n  /**\n   * Asynchronously *resolves* the given class by loading the class and\n   * resolving its super class, interfaces, and/or component classes.\n   */\n  public resolveClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    this.loadClass(thread, typeStr, (cdata: ClassData) => {\n      if (cdata === null || cdata.isResolved()) {\n        // Nothing to do! Either cdata is null, an exception triggered, and we\n        // failed, or cdata is already resolved.\n        setImmediate(() => { cb(cdata); });\n      } else {\n        cdata.resolve(thread, cb, explicit);\n      }\n    }, explicit);\n  }\n\n  /**\n   * Asynchronously *initializes* the given class and its super classes.\n   */\n  public initializeClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    // Get the resolved class.\n    this.resolveClass(thread, typeStr, (cdata: ClassData) => {\n      if (cdata === null || cdata.isInitialized(thread)) {\n        // Nothing to do! Either resolution failed and an exception has already\n        // been thrown, cdata is already initialized, or the current thread is\n        // initializing the class.\n        setImmediate(() => {\n          cb(cdata);\n        });\n      } else {\n        assert(util.is_reference_type(typeStr));\n        (<ReferenceClassData<JVMTypes.java_lang_Object>> cdata).initialize(thread, cb, explicit);\n      }\n    }, explicit);\n  }\n\n  /**\n   * Throws the appropriate exception/error for a class not being found.\n   * If loading was implicitly triggered by the JVM, we call NoClassDefFoundError.\n   * If the program explicitly called loadClass, then we throw the ClassNotFoundException.\n   */\n  protected throwClassNotFoundException(thread: threading.JVMThread, typeStr: string, explicit: boolean): void {\n    thread.throwNewException(explicit ? 'Ljava/lang/ClassNotFoundException;' : 'Ljava/lang/NoClassDefFoundError;', `Cannot load class: ${util.ext_classname(typeStr)}`);\n  }\n\n  /**\n   * Returns the JVM object corresponding to this ClassLoader.\n   */\n  public abstract getLoaderObject(): JVMTypes.java_lang_ClassLoader;\n}\n\n/**\n * The JVM's bootstrap class loader. Loads classes directly from files on the\n * file system.\n */\nexport class BootstrapClassLoader extends ClassLoader {\n  /**\n   * The classpath. The first path in the array is the first searched.\n   * Meaning: The *end* of this array is the bootstrap class loader, and the\n   *   *beginning* of the array is the classpath item added last.\n   */\n  private classpath: IClasspathItem[];\n  /**\n   * Keeps track of all loaded packages, and the classpath item(s) from\n   * whence their packages came.\n   *\n   * Note: Package separators are specified with slashes ('/'), not periods ('.').\n   */\n  private loadedPackages: {[pkgString: string]: IClasspathItem[]};\n\n  /**\n   * Constructs the bootstrap classloader with the given classpath.\n   * @param classPath The classpath, where the *first* item is the *last*\n   *   classpath searched. Meaning, the classPath[0] should be the bootstrap\n   *   class path.\n   * @param extractionPath The path where jar files should be extracted.\n   * @param cb Called once all of the classpath items have been checked.\n   *   Passes an error if one occurs.\n   */\n  constructor(javaHome: string, classpath: string[], cb: (e?: any) => void) {\n    // The correct way to do this would be super(this), but we cannot reference this before calling super()\n    super(null);\n    this.bootstrap = this;\n\n    this.classpath = null;\n    this.loadedPackages = {};\n\n    ClasspathFactory(javaHome, classpath, (items) => {\n      this.classpath = items.reverse();\n      cb();\n    });\n  }\n\n  /**\n   * Registers that a given class has successfully been loaded from the specified\n   * classpath item.\n   */\n  private _registerLoadedClass(clsType: string, cpItem: IClasspathItem): void {\n    let pkgName = clsType.slice(0, clsType.lastIndexOf('/')),\n      itemLoader = this.loadedPackages[pkgName];\n    if (!itemLoader) {\n      this.loadedPackages[pkgName] = [cpItem];\n    } else if (itemLoader[0] !== cpItem && itemLoader.indexOf(cpItem) === -1) {\n      // Common case optimization: Simply check the first array element.\n      itemLoader.push(cpItem);\n    }\n  }\n\n  /**\n   * Returns a listing of tuples containing:\n   * * The package name (e.g. java/lang)\n   * * Classpath locations where classes in the package were loaded.\n   */\n  public getPackages(): [string, string[]][] {\n    return Object.keys(this.loadedPackages).map((pkgName: string): [string, string[]] => {\n      return [pkgName, this.loadedPackages[pkgName].map((item) => item.getPath())];\n    });\n  }\n\n  /**\n   * Retrieves or defines the specified primitive class.\n   */\n  public getPrimitiveClass(typeStr: string): PrimitiveClassData {\n    var cdata = <PrimitiveClassData> this.getClass(typeStr);\n    if (cdata == null) {\n      cdata = new PrimitiveClassData(typeStr, this);\n      this.addClass(typeStr, cdata);\n    }\n    return cdata;\n  }\n\n  /**\n   * Asynchronously load the given class from the classpath.\n   *\n   * SHOULD ONLY BE INVOKED INTERNALLY BY THE CLASSLOADER.\n   */\n  protected _loadClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    debug(`[BOOTSTRAP] Loading class ${typeStr}`);\n    // This method is only valid for reference types!\n    assert(util.is_reference_type(typeStr));\n    // Search the class path for the class.\n    let clsFilePath = util.descriptor2typestr(typeStr),\n      cPathLen = this.classpath.length,\n      toSearch: IClasspathItem[] = [],\n      clsData: Buffer;\n\n    searchLoop:\n    for (let i = 0; i < cPathLen; i++) {\n      let item = this.classpath[i];\n      switch (item.hasClass(clsFilePath)) {\n        case TriState.INDETERMINATE:\n          toSearch.push(item);\n          break;\n        case TriState.TRUE:\n          // Break out of the loop; TRUE paths are guaranteed to have the class.\n          toSearch.push(item);\n          break searchLoop;\n      }\n    }\n\n    util.asyncFind<IClasspathItem>(toSearch, (pItem: IClasspathItem, callback: (success: boolean) => void): void => {\n      pItem.loadClass(clsFilePath, (err: Error, data?: Buffer) => {\n        if (err) {\n          callback(false);\n        } else {\n          clsData = data;\n          callback(true);\n        }\n      });\n    }, (pItem?: IClasspathItem) => {\n      if (pItem) {\n        let cls = this.defineClass(thread, typeStr, clsData, null);\n        if (cls !== null) {\n          this._registerLoadedClass(clsFilePath, pItem);\n        }\n        cb(cls);\n      } else {\n        // No such class.\n        debug(`Could not find class ${typeStr}`);\n        this.throwClassNotFoundException(thread, typeStr, explicit);\n        cb(null);\n      }\n    });\n  }\n\n  /**\n   * Returns a listing of reference classes loaded in the bootstrap loader.\n   */\n  public getLoadedClassFiles(): string[] {\n    var loadedClasses = this.getLoadedClassNames();\n    return loadedClasses.filter((clsName: string) => util.is_reference_type(clsName));\n  }\n\n  /**\n   * Returns the JVM object corresponding to this ClassLoader.\n   * @todo Represent the bootstrap by something other than 'null'.\n   * @todo These should be one-in-the-same.\n   */\n  public getLoaderObject(): JVMTypes.java_lang_ClassLoader {\n    return null;\n  }\n\n  /**\n   * Returns the current classpath.\n   */\n  public getClassPath(): string[] {\n    let cpLen = this.classpath.length,\n      cpStrings: string[] = new Array<string>(cpLen);\n    for (let i = 0; i < cpLen; i++) {\n      // Reverse it so it is the expected order (last item is first search target)\n      cpStrings[i] = this.classpath[cpLen - i - 1].getPath();\n    }\n    return cpStrings;\n  }\n\n  /**\n   * Returns the classpath item objects in the classpath.\n   */\n  public getClassPathItems(): IClasspathItem[] {\n    return this.classpath.slice(0);\n  }\n}\n\n/**\n * A Custom ClassLoader. Loads classes by calling loadClass on the user-defined\n * loader.\n */\nexport class CustomClassLoader extends ClassLoader {\n  constructor(bootstrap: BootstrapClassLoader,\n    private loaderObj: JVMTypes.java_lang_ClassLoader) {\n    super(bootstrap);\n  }\n\n  /**\n   * Asynchronously load the given class from the classpath. Calls the\n   * classloader's loadClass method.\n   *\n   * SHOULD ONLY BE INVOKED BY THE CLASS LOADER.\n   *\n   * @param thread The thread that triggered the loading.\n   * @param typeStr The type string of the class.\n   * @param cb The callback that will be called with the loaded class. It will\n   *   be passed a null if there is an error -- which also indicates that it\n   *   threw an exception on the JVM thread.\n   * @param explicit 'True' if loadClass was explicitly invoked by the program,\n   *   false otherwise. This changes the exception/error that we throw.\n   */\n  protected _loadClass(thread: threading.JVMThread, typeStr: string, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    debug(`[CUSTOM] Loading class ${typeStr}`);\n    // This method is only valid for reference types!\n    assert(util.is_reference_type(typeStr));\n    // Invoke the custom class loader.\n    this.loaderObj['loadClass(Ljava/lang/String;)Ljava/lang/Class;'](thread, [util.initString(this.bootstrap, util.ext_classname(typeStr))], (e?: JVMTypes.java_lang_Throwable, jco?: JVMTypes.java_lang_Class) => {\n      if (e) {\n        // Exception! There was an issue defining the class.\n        this.throwClassNotFoundException(thread, typeStr, explicit);\n        cb(null);\n      } else {\n        // Add the class returned by loadClass, in case the classloader\n        // proxied loading to another classloader.\n        var cls = jco.$cls;\n        this.addClass(typeStr, cls);\n        cb(cls);\n      }\n    });\n  }\n\n  /**\n   * Returns the JVM object corresponding to this ClassLoader.\n   * @todo These should be one-in-the-same.\n   */\n  public getLoaderObject(): JVMTypes.java_lang_ClassLoader {\n    return this.loaderObj;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ClassLoader.ts\n **/","\"use strict\";\nimport util = require('./util');\nimport ByteStream = require('./ByteStream');\nimport ConstantPool = require('./ConstantPool');\nimport attributes = require('./attributes');\nimport {JVMThread, InternalStackFrame, NativeStackFrame, BytecodeStackFrame} from './threading';\nimport logging = require('./logging');\nimport methods = require('./methods');\nimport ClassLoader = require('./ClassLoader');\nimport enums = require('./enums');\nimport ClassLock = require('./ClassLock');\nimport assert = require('./assert');\nimport gLong = require('./gLong');\nimport JVM = require('./jvm');\nimport StringOutputStream = require('./StringOutputStream');\nimport JVMTypes = require('../includes/JVMTypes');\nimport ClassState = enums.ClassState;\n\nimport trace = logging.trace;\nimport debug = logging.debug;\n\nimport global = require('./global');\n\ndeclare var RELEASE: boolean;\nif (typeof RELEASE === 'undefined') global.RELEASE = false;\n\n/**\n * Auto-incrementing reference number. Uniquely identifies each object allocated\n * by the JVM. Started at 1 because we use 0 to identify NULL.\n */\nvar ref: number = 1;\nfunction getRef() {\n  return ref++;\n}\n\n/**\n * Defines special JVM-injected fields. The map stores the TypeScript type of\n * the field and the default value for the field, which will be assigned in the\n * JavaScript constructor for the class.\n */\nvar injectedFields: {[className: string]: {[fieldName: string]: [string, string]}} = {\n  'Ljava/lang/invoke/MemberName;': {\n    vmtarget: [\"(thread: JVMThread, descriptor: string, args: any[], cb?: (e?: JVMTypes.java_lang_Throwable, rv?: any) => void) => void\", \"null\"],\n    vmindex: [\"number\", \"-1\"]\n  },\n  'Ljava/lang/Object;': {\n    'ref': [\"number\", \"getRef()\"],\n    '$monitor': [\"Monitor\", \"null\"]\n  },\n  'Ljava/net/PlainSocketImpl;': {\n    '$is_shutdown': ['boolean', 'false'],\n    '$ws': ['Interfaces.IWebsock', 'null']\n  },\n  'Ljava/lang/Class;': {\n    '$cls': ['ClassData', 'null'],\n    'signers': ['JVMTypes.java_lang_Object[]', 'null']\n  },\n  'Ljava/lang/ClassLoader;': {\n    '$loader': ['ClassLoader', 'new ClassLoader.CustomClassLoader(thread.getBsCl(), this);']\n  },\n  'Ljava/lang/Thread;': {\n    // Note: Need to handle initial case when thread is NULL.\n    '$thread': ['JVMThread', 'thread ? new thread.constructor(thread.getJVM(), thread.getThreadPool(), this) : null']\n  }\n};\n\n/**\n * Defines special JVM-injected method. The map stores the TypeScript type\n * signature of the method and the JavaScript body of the method, keyed on the\n * method's name. These are all instance methods (e.g. non-static).\n */\nvar injectedMethods: {[className: string]: {[methodName: string]: string[]}} = {\n  'Ljava/lang/Object;': {\n    'getClass': [\"(): ClassData\", `function() { return this.constructor.cls }`],\n    'getMonitor': [\"(): Monitor\", `function() {\n  if (this.$monitor === null) {\n    this.$monitor = new Monitor();\n  }\n  return this.$monitor;\n}`]\n  },\n  'Ljava/lang/String;': {\n    'toString': [\"(): string\", `function() { return util.chars2jsStr(this['java/lang/String/value']); }`]\n  },\n  'Ljava/lang/Byte;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Byte/value']; }`]\n  },\n  'Ljava/lang/Character;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Character/value']; }`]\n  },\n  'Ljava/lang/Double;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Double/value']; }`]\n  },\n  'Ljava/lang/Float;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Float/value']; }`]\n  },\n  'Ljava/lang/Integer;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Integer/value']; }`]\n  },\n  'Ljava/lang/Long;': {\n    'unbox': [\"(): Long\", `function() { return this['java/lang/Long/value']; }`]\n  },\n  'Ljava/lang/Short;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Short/value']; }`]\n  },\n  'Ljava/lang/Boolean;': {\n    'unbox': [\"(): number\", `function() { return this['java/lang/Boolean/value']; }`]\n  },\n  // To catch any errors. Should never actually happen; Voids don't show up in arg lists.\n  'Ljava/lang/Void;': {\n    'unbox': [\"(): number\", `function() { throw new Error(\"Cannot unbox a Void type.\"); }`]\n  },\n  'Ljava/lang/invoke/MethodType;': {\n    'toString': [\"(): string\", `function() { return \"(\" + this['java/lang/invoke/MethodType/ptypes'].array.map(function (type) { return type.$cls.getInternalName(); }).join(\"\") + \")\" + this['java/lang/invoke/MethodType/rtype'].$cls.getInternalName(); }`]\n  }\n};\n\n/**\n * Same as injected methods, but these are static.\n */\nvar injectedStaticMethods: {[className: string]: {[methodName: string]: [string, string]}} = {\n  'Ljava/lang/Byte;': {\n    'box': [\"(val: number): java_lang_Byte\", `function(val) { var rv = new this(null); rv['java/lang/Byte/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Character;': {\n    'box': [\"(val: number): java_lang_Character\", `function(val) { var rv = new this(null); rv['java/lang/Character/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Double;': {\n    'box': [\"(val: number): java_lang_Double\", `function(val) { var rv = new this(null); rv['java/lang/Double/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Float;': {\n    'box': [\"(val: number): java_lang_Float\", `function(val) { var rv = new this(null); rv['java/lang/Float/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Integer;': {\n    'box': [\"(val: number): java_lang_Integer\", `function(val) { var rv = new this(null); rv['java/lang/Integer/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Long;': {\n    'box': [\"(val: Long): java_lang_Long\", `function(val) { var rv = new this(null); rv['java/lang/Long/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Short;': {\n    'box': [\"(val: number): java_lang_Short\", `function(val) { var rv = new this(null); rv['java/lang/Short/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Boolean;': {\n    'box': [\"(val: number): java_lang_Boolean\", `function(val) { var rv = new this(null); rv['java/lang/Boolean/value'] = val; return rv; }`]\n  },\n  'Ljava/lang/Void;': {\n    'box': [\"(): java_lang_Void\", `function() { return new this(null); }`]\n  }\n};\n\nexport interface IJVMConstructor<T extends JVMTypes.java_lang_Object> {\n  /**\n   * Constructs a new object in the same manner as the JVM's \"new\" opcode.\n   * Does *NOT* run the JVM constructor!\n   * @param jvm The thread that is constructing the object.\n   * @param lengths... If this is an array type, the length of each dimension of the array. (Required if an array type.)\n   */\n  new(thread: JVMThread, lengths?: number[] | number): T;\n}\n\n/**\n * Extends a JVM class by making its prototype a blank instantiation of an\n * object with the super class's prototype as its prototype. Inspired from\n * TypeScript's __extend function.\n */\nfunction extendClass(cls: any, superCls: any) {\n  function __() { this.constructor = cls; }\n  __.prototype = superCls.prototype;\n  cls.prototype = new (<any> __)();\n}\n\n/**\n * Represents a single class in the JVM.\n */\nexport abstract class ClassData {\n  protected loader: ClassLoader.ClassLoader;\n  public accessFlags: util.Flags = null;\n  /**\n   * We make this private to *enforce* call sites to use our getter functions.\n   * The actual state of this class depends on the state of its parents, and\n   * parents do not inform their children when they change state.\n   */\n  private state: enums.ClassState = enums.ClassState.LOADED;\n  private jco: JVMTypes.java_lang_Class = null;\n  /**\n   * The class's canonical name, in internal form.\n   * Ljava/lang/Foo;\n   */\n  protected className: string;\n  protected superClass: ReferenceClassData<JVMTypes.java_lang_Object> = null;\n\n  /**\n   * Responsible for setting up all of the fields that are guaranteed to be\n   * present on any ClassData object.\n   */\n  constructor(loader: ClassLoader.ClassLoader) {\n    this.loader = loader;\n  }\n\n  /**\n   * Get the external form of this class's name (e.g. java.lang.String).\n   */\n  public getExternalName(): string {\n    return util.ext_classname(this.className);\n  }\n\n  /**\n   * Get the internal form of this class's name (e.g. Ljava/lang/String;).\n   */\n  public getInternalName(): string {\n    return this.className;\n  }\n\n  /**\n   * Get the name of the package that this class belongs to (e.g. java.lang).\n   */\n  public getPackageName(): string {\n    var extName = this.getExternalName(), i: number;\n    // Find the index of the last '.' in the name.\n    for (i = extName.length - 1; i >= 0 && extName[i] !== '.'; i--) {}\n    if (i >= 0) {\n      return extName.slice(0, i);\n    } else {\n      return \"\";\n    }\n  }\n\n  /**\n   * Returns the ClassLoader object of the classloader that initialized this\n   * class. Returns null for the default classloader.\n   */\n  public getLoader(): ClassLoader.ClassLoader {\n    return this.loader;\n  }\n\n  /**\n   * Get the class's super class, which is always going to be a reference\n   * class.\n   */\n  public getSuperClass(): ReferenceClassData<JVMTypes.java_lang_Object> {\n    return this.superClass;\n  }\n\n  /**\n   * Get all of the interfaces that the class implements.\n   */\n  public getInterfaces(): ReferenceClassData<JVMTypes.java_lang_Object>[] {\n    return [];\n  }\n\n  /**\n   * Get all of the injected fields for this class. The value for each field\n   * in the returned map is its type.\n   */\n  public getInjectedFields(): { [fieldName: string]: string } {\n    var rv: { [fieldName: string]: string } = {};\n    if (injectedFields[this.getInternalName()] !== undefined) {\n      var fields = injectedFields[this.getInternalName()];\n      Object.keys(fields).forEach((fieldName: string) => {\n        rv[fieldName] = fields[fieldName][0];\n      });\n    }\n    return rv;\n  }\n\n  /**\n   * Get all of the injected methods for this class. The value for each method\n   * in the returned map is its type.\n   */\n  public getInjectedMethods(): { [methodName: string]: string } {\n    var rv: { [methodName: string]: string } = {},\n      lookupName = this.getInternalName();\n    // All array classes share the same injected methods.\n    if (lookupName[0] === '[') {\n      lookupName = '[';\n    }\n\n    if (injectedMethods[lookupName] !== undefined) {\n      var methods = injectedMethods[lookupName];\n      Object.keys(methods).forEach((methodName: string) => {\n        rv[methodName] = methods[methodName][0];\n      });\n    }\n    return rv;\n  }\n\n  /**\n   * Get all of the injected static methods for this class. The value for each\n   * method in the returned map is its type.\n   */\n  public getInjectedStaticMethods(): { [methodName: string]: string } {\n    var rv: { [methodName: string]: string } = {},\n      lookupName = this.getInternalName();\n    // All array classes share the same injected methods.\n    if (lookupName[0] === '[') {\n      lookupName = '[';\n    }\n\n    if (injectedStaticMethods[lookupName] !== undefined) {\n      var methods = injectedStaticMethods[lookupName];\n      Object.keys(methods).forEach((methodName: string) => {\n        rv[methodName] = methods[methodName][0];\n      });\n    }\n    return rv;\n  }\n\n  /**\n   * Get a java.lang.Class object corresponding to this class.\n   */\n  public getClassObject(thread: JVMThread): JVMTypes.java_lang_Class {\n    if (this.jco === null) {\n      this.jco = new ((<ReferenceClassData<JVMTypes.java_lang_Class>> thread.getBsCl().getResolvedClass('Ljava/lang/Class;')).getConstructor(thread))(thread);\n      this.jco.$cls = this;\n      this.jco['java/lang/Class/classLoader'] = this.getLoader().getLoaderObject();\n    }\n    return this.jco;\n  }\n\n  /**\n   * Get the protection domain of this class.\n   * This value is NULL for all but reference classes loaded by app classloaders.\n   */\n  public getProtectionDomain(): JVMTypes.java_security_ProtectionDomain {\n    return null;\n  }\n\n  /**\n   * Retrieves the method defined in this particular class by the given method\n   * signature *without* invoking method lookup.\n   * @param methodSignature The method's full signature, e.g. <clinit>()V\n   */\n  public getMethod(methodSignature: string): methods.Method {\n    return null;\n  }\n\n  /**\n   * Retrieve all of the methods defined on this class.\n   */\n  public getMethods(): methods.Method[] {\n    return [];\n  }\n\n  /**\n   * Retrieve the set of fields defined on this class.\n   */\n  public getFields(): methods.Field[] {\n    return [];\n  }\n\n  /**\n   * Attempt to synchronously resolve this class using its loader. Should only\n   * be called on ClassData in the LOADED state.\n   */\n  public abstract tryToResolve(): boolean;\n\n  /**\n   * Attempt to synchronously initialize this class.\n   */\n  public abstract tryToInitialize(): boolean;\n\n  /**\n   * Set the state of this particular class to LOADED/RESOLVED/INITIALIZED.\n   */\n  public setState(state: enums.ClassState): void {\n    this.state = state;\n  }\n\n  /**\n   * Gets the current state of this class.\n   */\n  protected getState(): enums.ClassState {\n    if (this.state === ClassState.RESOLVED && this.getMethod('<clinit>()V') === null) {\n      // We can promote to INITIALIZED if this class has no static initialization\n      // logic, and its parent class is initialized.\n      var scls = this.getSuperClass();\n      if (scls !== null && scls.getState() === ClassState.INITIALIZED) {\n        this.state = ClassState.INITIALIZED;\n      }\n    }\n    return this.state;\n  }\n\n  /**\n   * Check if the class is initialized.\n   * @param thread The thread that is performing the check. If initialization\n   *   is in progress on that thread, then the class is, for all intents and\n   *   purposes, initialized.\n   */\n  public isInitialized(thread: JVMThread): boolean {\n    return this.getState() === ClassState.INITIALIZED;\n  }\n  // Convenience function.\n  public isResolved(): boolean { return this.getState() !== ClassState.LOADED; }\n\n  public isSubinterface(target: ClassData): boolean {\n    return false;\n  }\n\n  public isSubclass(target: ClassData): boolean {\n    if (this === target) {\n      return true;\n    }\n    if (this.getSuperClass() === null) {\n      return false;\n    }\n    return this.getSuperClass().isSubclass(target);\n  }\n\n  public abstract isCastable(target: ClassData): boolean;\n\n  public resolve(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    throw new Error(\"Unimplemented.\");\n  }\n\n  public initialize(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    throw new Error(\"Unimplemented.\");\n  }\n\n  protected outputInjectedMethods(jsClassName: string, outputStream: StringOutputStream) {\n    var lookupName = this.getInternalName();\n    if (lookupName[0] === '[') {\n      lookupName = '[';\n    }\n    if (injectedMethods[lookupName] !== undefined) {\n      var methods = injectedMethods[lookupName];\n      Object.keys(methods).forEach((methodName: string) => {\n        outputStream.write(`  ${jsClassName}.prototype.${methodName} = ${methods[methodName][1]};\\n`);\n      });\n    }\n\n    if (injectedStaticMethods[lookupName] !== undefined) {\n      var staticMethods = injectedStaticMethods[lookupName];\n      Object.keys(staticMethods).forEach((methodName: string) => {\n        outputStream.write(`  ${jsClassName}.${methodName} = ${staticMethods[methodName][1]};\\n`);\n      });\n    }\n  }\n}\n\nexport class PrimitiveClassData extends ClassData {\n  constructor(className: string, loader: ClassLoader.ClassLoader) {\n    super(loader);\n    this.className = className;\n    // PrimitiveClassData objects are ABSTRACT, FINAL, and PUBLIC.\n    this.accessFlags = new util.Flags(0x411);\n    this.setState(ClassState.INITIALIZED);\n  }\n\n  /**\n   * Returns a boolean indicating if this class is an instance of the target class.\n   * \"target\" is a ClassData object.\n   * The ClassData objects do not need to be initialized; just loaded.\n   */\n  public isCastable(target: ClassData): boolean {\n    return this.className === target.getInternalName();\n  }\n\n  /**\n   * Returns the internal class name for the corresponding boxed type.\n   */\n  public boxClassName(): string {\n    return util.boxClassName(this.className);\n  }\n\n  /**\n   * Returns a boxed version of the given primitive.\n   */\n  public createWrapperObject(thread: JVMThread, value: any): JVMTypes.java_lang_Object {\n    var boxName = this.boxClassName();\n    var boxCls = <ReferenceClassData<JVMTypes.java_lang_Object>> thread.getBsCl().getInitializedClass(thread, boxName);\n    // these are all initialized in preinit (for the BSCL, at least)\n    var boxCons = boxCls.getConstructor(thread);\n    var wrapped = new boxCons(thread);\n    if (boxName !== 'V') {\n      // XXX: all primitive wrappers store their value in a private static final field named 'value'\n      (<any> wrapped)[util.descriptor2typestr(boxName) + '/value'] = value;\n      assert(typeof value === \"number\" || typeof value === \"boolean\" || typeof value.low_ === \"number\", `Invalid primitive value: ${value}`);\n    }\n    return wrapped;\n  }\n\n  public tryToResolve(): boolean {\n    return true;\n  }\n\n  public tryToInitialize(): boolean {\n    return true;\n  }\n\n  /**\n   * Primitive classes are already resolved.\n   */\n  public resolve(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    setImmediate(() => cb(this));\n  }\n}\n\nexport class ArrayClassData<T> extends ClassData {\n  private componentClassName: string;\n  private componentClass: ClassData;\n  private _constructor: IJVMConstructor<JVMTypes.JVMArray<T>> = null;\n\n  constructor(componentType: string, loader: ClassLoader.ClassLoader) {\n    super(loader);\n    this.className = `[${componentType}`;\n    // ArrayClassData objects are ABSTRACT, FINAL, and PUBLIC.\n    this.accessFlags = new util.Flags(0x411);\n    this.componentClassName = componentType;\n  }\n\n  /**\n   * Looks up a method with the given signature. Returns null if no method\n   * found.\n   */\n  public methodLookup(signature: string): methods.Method {\n    return this.superClass.methodLookup(signature);\n  }\n\n  public fieldLookup(name: string): methods.Field {\n    return this.superClass.fieldLookup(name);\n  }\n\n  /**\n   * Resolve the class.\n   */\n  public resolve(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    if (this.isResolved()) {\n      // Short circuit.\n      setImmediate(() => cb(this));\n      return;\n    }\n    util.asyncForEach([\"Ljava/lang/Object;\", this.componentClassName], (cls: string, nextItem: (err?: any) => void) => {\n      this.loader.resolveClass(thread, cls, (cdata: ClassData) => {\n        if (cdata !== null) {\n          nextItem();\n        } else {\n          nextItem(\"Failed.\");\n        }\n      });\n    }, (err?: any) => {\n      if (!err) {\n        this.setResolved(<ReferenceClassData<JVMTypes.java_lang_Object>> this.loader.getResolvedClass(\"Ljava/lang/Object;\"), this.loader.getResolvedClass(this.componentClassName));\n        cb(this);\n      } else {\n        cb(null);\n      }\n    });\n  }\n\n  public getComponentClass(): ClassData {\n    return this.componentClass;\n  }\n\n  /**\n   * Resolved and initialized are the same for array types.\n   */\n  public setResolved<T extends JVMTypes.java_lang_Object>(super_class_cdata: ReferenceClassData<T>, component_class_cdata: ClassData): void {\n    this.superClass = super_class_cdata;\n    this.componentClass = component_class_cdata;\n    this.setState(ClassState.INITIALIZED);\n  }\n\n  public tryToResolve(): boolean {\n    var loader = this.loader,\n      superClassCdata = <ReferenceClassData<JVMTypes.java_lang_Object>> loader.getResolvedClass(\"Ljava/lang/Object;\"),\n      componentClassCdata = loader.getResolvedClass(this.componentClassName);\n\n    if (superClassCdata === null || componentClassCdata === null) {\n      return false;\n    } else {\n      this.setResolved(superClassCdata, componentClassCdata);\n      return true;\n    }\n  }\n\n  public tryToInitialize(): boolean {\n    // Arrays are initialized once resolved.\n    return this.tryToResolve();\n  }\n\n  /**\n   * Returns a boolean indicating if this class is an instance of the target class.\n   * \"target\" is a ClassData object.\n   * The ClassData objects do not need to be initialized; just loaded.\n   * See §2.6.7 for casting rules.\n   */\n  public isCastable(target: ClassData): boolean {\n    if (!(target instanceof ArrayClassData)) {\n      if (target instanceof PrimitiveClassData) {\n        return false;\n      }\n      // Must be a reference type.\n      if (target.accessFlags.isInterface()) {\n        // Interface reference type\n        var type = target.getInternalName();\n        return type === 'Ljava/lang/Cloneable;' || type === 'Ljava/io/Serializable;';\n      }\n      // Non-interface reference type\n      return target.getInternalName() === 'Ljava/lang/Object;';\n    }\n    // We are both array types, so it only matters if my component type can be\n    // cast to its component type.\n    return this.getComponentClass().isCastable((<ArrayClassData<any>> target).getComponentClass());\n  }\n\n  public initialize(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    this.resolve(thread, cb, explicit);\n  }\n\n  /**\n   * Get the array constructor for this particular JVM array class.\n   * Uses typed arrays when available for primitive arrays.\n   */\n  private getJSArrayConstructor(): string {\n    if (!util.typedArraysSupported) {\n      return 'Array';\n    }\n    switch (this.componentClassName) {\n      case 'B':\n        return 'Int8Array';\n      case 'C':\n        return 'Uint16Array';\n      case 'S':\n        return 'Int16Array';\n      case 'I':\n        return 'Int32Array';\n      case 'F':\n        return 'Float32Array';\n      case 'D':\n        return 'Float64Array';\n      default:\n        return 'Array';\n    }\n  }\n\n  /**\n   * Get the initial value placed into each array element.\n   */\n  private getJSDefaultArrayElement(): string {\n    switch(this.componentClassName[0]) {\n      case '[':\n        return `new (cls.getComponentClass().getConstructor())(thread, otherLengths)`;\n      case 'L':\n        return \"null\";\n      case 'J':\n        return \"gLongZero\";\n      default:\n        return \"0\";\n    }\n  }\n\n  /**\n   * Creates a specialized `slice` method that creates a shallow slice of this\n   * array. Specialized to the type of array (JS or Typed).\n   */\n  private _getSliceMethod(): string {\n    var output = new StringOutputStream(),\n      jsArrCons = this.getJSArrayConstructor();\n    output.write(`function(start, end) {\n    var newObj = new this.constructor(null, 0);\\n`);\n    if (jsArrCons === 'Array') {\n      output.write(`    newObj.array = this.array.slice(start, end);\\n`);\n    } else {\n      var elementSize: number;\n      switch (jsArrCons) {\n        case 'Int8Array':\n          elementSize = 1;\n          break;\n        case 'Int16Array':\n        case 'Uint16Array':\n          elementSize = 2;\n          break;\n        case 'Int32Array':\n        case 'Float32Array':\n          elementSize = 4;\n          break;\n        case 'Float64Array':\n          elementSize = 8;\n          break;\n        default:\n          assert(false, \"Illegal array type returned??\");\n      }\n      // Although ArrayBuffer.slice has an optional end argument, we need to\n      // multiply it if it does exist.\n      output.write(`    if (end === undefined) end = this.array.length;\n      ${elementSize > 1 ? `start *= ${elementSize};\\nend *= ${elementSize};` : ''}\n      newObj.array = new ${jsArrCons}(this.array.buffer.slice(start, end));\\n`);\n    }\n    output.write(`    return newObj;\n  }`);\n    return output.flush();\n  }\n\n  private _constructConstructor(thread: JVMThread): IJVMConstructor<JVMTypes.JVMArray<T>> {\n    assert(this._constructor === null, `Tried to construct constructor twice for ${this.getExternalName()}!`);\n    var outputStream = new StringOutputStream(),\n      jsClassName = util.jvmName2JSName(this.getInternalName());\n      // Arguments: extendClass, cls, superCls, gLongZero, thread\n    outputStream.write(`extendClass(${jsClassName}, superCls.getConstructor(thread));\n  function ${jsClassName}(thread, lengths) {\\n`);\n    this.superClass.outputInjectedFields(outputStream);\n    // Initialize array.\n    if (this.componentClassName[0] !== '[') {\n      // Array elements are a non-array type.\n      outputStream.write(`    this.array = new ${this.getJSArrayConstructor()}(lengths);\\n`)\n      if (this.getJSArrayConstructor() === 'Array') {\n        // TypedArrays are already initialized to 0, so this check skips array\n        // initialization in that case.\n        outputStream.write(`    for (var i = 0; i < lengths; i++) {\n      this.array[i] = ${this.getJSDefaultArrayElement()};\n    }\\n`)\n      }\n    } else {\n      // Multi-dimensional array.\n      outputStream.write(`    if (typeof lengths === 'number') {\n        this.array = new ${this.getJSArrayConstructor()}(lengths);\n        for (var i = 0; i < length; i++) {\n          this.array[i] = null;\n        }\n      } else {\n        var length = lengths[0], otherLengths = lengths.length > 2 ? lengths.slice(1) : lengths[1];\n        this.array = new ${this.getJSArrayConstructor()}(length);\n        for (var i = 0; i < length; i++) {\n          this.array[i] = ${this.getJSDefaultArrayElement()};\n        }\n      }\\n`)\n    }\n    outputStream.write(`  }\n\n  ${jsClassName}.prototype.slice = ${this._getSliceMethod()};\n  ${jsClassName}.cls = cls;\\n`);\n    this.outputInjectedMethods(jsClassName, outputStream);\n    outputStream.write(`\n  return ${jsClassName};`);\n    // All arrays extend java/lang/Object\n    // function _create(extendClass, cls, superCls, gLongZero, thread) {\n    const fcn = new Function(\"extendClass\", \"cls\", \"superCls\", \"gLongZero\", \"thread\", \"getRef\", \"util\", outputStream.flush());\n    return fcn(extendClass, this, this.superClass, gLong.ZERO, thread, getRef, util);\n  }\n\n  public getConstructor(thread: JVMThread): IJVMConstructor<JVMTypes.JVMArray<T>> {\n    assert(this.isResolved(), `Tried to get constructor for class ${this.getInternalName()} before it was resolved.`);\n    if (this._constructor === null) {\n      this._constructor = this._constructConstructor(thread);\n    }\n    return this._constructor;\n  }\n}\n\n/**\n * Represents a \"reference\" Class -- that is, a class that neither represents a\n * primitive nor an array.\n */\nexport class ReferenceClassData<T extends JVMTypes.java_lang_Object> extends ClassData {\n  private minorVersion: number;\n  public majorVersion: number;\n  public constantPool: ConstantPool.ConstantPool;\n  /**\n   * All of the fields directly defined by this class.\n   */\n  private fields: methods.Field[];\n  /**\n   * All of the methods directly defined by this class.\n   */\n  private methods: methods.Method[];\n  private attrs: attributes.IAttribute[];\n  private interfaceClasses: ReferenceClassData<JVMTypes.java_lang_Object>[] = null;\n  private superClassRef: ConstantPool.ClassReference = null;\n  private interfaceRefs: ConstantPool.ClassReference[];\n  /**\n   * Initialization lock.\n   */\n  private initLock: ClassLock = new ClassLock();\n  /**\n   * Stores the JavaScript constructor for this class.\n   */\n  private _constructor: IJVMConstructor<T> = null;\n  /**\n   * Virtual field table\n   */\n  private _fieldLookup: { [name: string]: methods.Field } = {};\n  /**\n   * All fields in object instantiations. Fields from super classes are in front\n   * of fields from this class. A field's offset in the array is its *vmindex*.\n   */\n  protected _objectFields: methods.Field[] = [];\n  /**\n   * All static fields in this particular class. The field's offset in this\n   * array is its *vmindex*.\n   */\n  protected _staticFields: methods.Field[] = [];\n  /**\n   * Virtual method table, keyed by method signature. Unlike _vmTable,\n   * _methodLookup contains static methods and constructors, too.\n   */\n  private _methodLookup: { [signature: string]: methods.Method } = {};\n  /**\n   * Virtual method table, keyed by vmindex. Methods originally defined by\n   * super classes are in front of methods defined in this class. Overriding\n   * methods are placed into the vmindex of the originating method.\n   */\n  protected _vmTable: methods.Method[] = [];\n  /**\n   * Default method implementations that this class did *not* inherit, but are\n   * still invocable in the class via their full name (e.g. through an\n   * invokespecial bytecode).\n   */\n  protected _uninheritedDefaultMethods: methods.Method[] = [];\n  /**\n   * The ProtectionDomain for this class, specified by the application class\n   * loader. NULL for bootstrap classloaded items.\n   */\n  protected _protectionDomain: JVMTypes.java_security_ProtectionDomain;\n\n  constructor(buffer: Buffer, protectionDomain?: JVMTypes.java_security_ProtectionDomain, loader?: ClassLoader.ClassLoader, cpPatches?: JVMTypes.JVMArray<JVMTypes.java_lang_Object>) {\n    super(loader);\n    this._protectionDomain = protectionDomain ? protectionDomain : null;\n    var byteStream = new ByteStream(buffer),\n      i: number = 0;\n    if ((byteStream.getUint32()) !== 0xCAFEBABE) {\n      throw new Error(\"Magic number invalid\");\n    }\n    this.minorVersion = byteStream.getUint16();\n    this.majorVersion = byteStream.getUint16();\n    if (!(45 <= this.majorVersion && this.majorVersion <= 52)) {\n      throw new Error(\"Major version invalid\");\n    }\n    this.constantPool = new ConstantPool.ConstantPool();\n    this.constantPool.parse(byteStream, cpPatches);\n    // bitmask for {public,final,super,interface,abstract} class modifier\n    this.accessFlags = new util.Flags(byteStream.getUint16());\n\n    this.className = (<ConstantPool.ClassReference> this.constantPool.get(byteStream.getUint16())).name;\n    // super reference is 0 when there's no super (basically just java.lang.Object)\n    var superRef = byteStream.getUint16();\n    if (superRef !== 0) {\n      this.superClassRef = (<ConstantPool.ClassReference> this.constantPool.get(superRef));\n    }\n    // direct interfaces of this class\n    var isize = byteStream.getUint16();\n    this.interfaceRefs = new Array<ConstantPool.ClassReference>(isize);\n    for (i = 0; i < isize; ++i) {\n      this.interfaceRefs[i] = <ConstantPool.ClassReference> this.constantPool.get(byteStream.getUint16());\n    }\n    // fields of this class\n    var numFields = byteStream.getUint16();\n    this.fields = new Array<methods.Field>(numFields);\n    for (i = 0; i < numFields; ++i) {\n      this.fields[i] = new methods.Field(this, this.constantPool, i, byteStream);\n    }\n    // class methods\n    var numMethods = byteStream.getUint16();\n    this.methods = new Array<methods.Method>(numMethods);\n    for (i = 0; i < numMethods; i++) {\n      var m = new methods.Method(this, this.constantPool, i, byteStream);\n      this.methods[i] = m;\n    }\n    // class attributes\n    this.attrs = attributes.makeAttributes(byteStream, this.constantPool);\n    if (byteStream.hasBytes()) {\n      throw `Leftover bytes in classfile: ${byteStream}`;\n    }\n  }\n\n  public getSuperClassReference(): ConstantPool.ClassReference {\n    return this.superClassRef;\n  }\n\n  public getInterfaceClassReferences(): ConstantPool.ClassReference[] {\n    return this.interfaceRefs.slice(0);\n  }\n\n  /**\n   * Retrieve the set of interfaces that this class implements.\n   * DO NOT MUTATE!\n   */\n  public getInterfaces(): ReferenceClassData<JVMTypes.java_lang_Object>[] {\n    return this.interfaceClasses;\n  }\n\n  /**\n   * The set of fields that this class has.\n   * DO NOT MUTATE!\n   */\n  public getFields(): methods.Field[] {\n    return this.fields;\n  }\n\n  /**\n   * Get the Virtual Method table for this class.\n   */\n  public getVMTable(): methods.Method[] {\n    return this._vmTable;\n  }\n\n  /**\n   * Returns the VM index for the given method. Returns -1 if not present in the\n   * virtual method table (e.g. is static or a constructor).\n   */\n  public getVMIndexForMethod(m: methods.Method): number {\n    // Use M's signature, as we might override the method and use a different\n    // method object in the table for its vmindex.\n    return this._vmTable.indexOf(this.methodLookup(m.signature));\n  }\n\n  /**\n   * Returns the method corresponding to the given VMIndex.\n   */\n  public getMethodFromVMIndex(i: number): methods.Method {\n    if (this._vmTable[i] !== undefined) {\n      return this._vmTable[i];\n    }\n    return null;\n  }\n\n  /**\n   * Get the VM index for the given field\n   * NOTE: A static and non-static field can have the same vmindex! Caller must\n   * be able to differentiate between static and non-static behavior!\n   */\n  public getVMIndexForField(f: methods.Field): number {\n    if (f.accessFlags.isStatic()) {\n      assert(f.cls === this, \"Looks like we actually need to support static field lookups!\");\n      return this._staticFields.indexOf(f);\n    } else {\n      return this._objectFields.indexOf(f);\n    }\n  }\n\n  public getStaticFieldFromVMIndex(index: number): methods.Field {\n    var f = this._staticFields[index];\n    if (f !== undefined) {\n      return f;\n    }\n    return null;\n  }\n\n  public getObjectFieldFromVMIndex(index: number): methods.Field {\n    var f = this._objectFields[index];\n    if (f !== undefined) {\n      return f;\n    }\n    return null;\n  }\n\n  /**\n   * Get a field from its \"slot\". A \"slot\" is just the field's index in its\n   * defining class's field array.\n   */\n  public getFieldFromSlot(slot: number): methods.Field {\n    return this.fields[slot];\n  }\n\n  /**\n   * Get a method from its \"slot\". A \"slot\" is just the method's index in its\n   * defining class's method array.\n   */\n  public getMethodFromSlot(slot: number): methods.Method {\n    return this.methods[slot];\n  }\n\n  /**\n   * Retrieve a method with the given signature from this particular class.\n   * Does not search superclasses / interfaces.\n   */\n  public getMethod(sig: string): methods.Method {\n    var m = this._methodLookup[sig];\n    if (m.cls === this) {\n      return m;\n    }\n    return null;\n  }\n\n  public getSpecificMethod(definingCls: string, sig: string): methods.Method {\n    if (this.getInternalName() === definingCls) {\n      return this.getMethod(sig);\n    }\n    var searchClasses = this.interfaceClasses.slice(0), m: methods.Method;\n    if (this.superClass) {\n      searchClasses.push(this.superClass);\n    }\n    for (var i = 0; i < searchClasses.length; i++) {\n      if (null !== (m = searchClasses[i].getSpecificMethod(definingCls, sig))) {\n        return m;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the methods belonging to this particular class.\n   * DO NOT MUTATE!\n   */\n  public getMethods(): methods.Method[] {\n    return this.methods;\n  }\n\n  /**\n   * Get the set of default methods that are invocable on this object, but were\n   * not inherited in the virtual method table.\n   * DO NOT MUTATE!\n   */\n  public getUninheritedDefaultMethods(): methods.Method[] {\n    return this._uninheritedDefaultMethods;\n  }\n\n  public getProtectionDomain(): JVMTypes.java_security_ProtectionDomain {\n    return this._protectionDomain;\n  }\n\n  /**\n   * Resolves this class's virtual method table according to the JVM\n   * specification:\n   * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.3\n   */\n  private _resolveMethods(): void {\n    if (this.superClass !== null) {\n      // Start off with my parents' method table.\n      this._vmTable = this._vmTable.concat(this.superClass._vmTable);\n      Object.keys(this.superClass._methodLookup).forEach((m: string) => {\n        this._methodLookup[m] = this.superClass._methodLookup[m];\n      });\n    }\n\n    // My methods override my super class'.\n    this.methods.forEach((m: methods.Method) => {\n      var superM = this._methodLookup[m.signature];\n      if (!m.accessFlags.isStatic() && m.name !== \"<init>\") {\n        // Only non-static non-constructor methods are placed into the virtual\n        // method table.\n        if (superM === undefined) {\n          // New vmindex.\n          this._vmTable.push(m);\n        } else {\n          // Old vmindex. Inherit the super class method's vmindex.\n          this._vmTable[this._vmTable.indexOf(superM)] = m;\n        }\n      }\n      this._methodLookup[m.signature] = m;\n    });\n\n    // Root out any miranda / default / static interface methods. Only install\n    // them if there are no alternatives already in the table.\n    this.interfaceClasses.forEach((iface: ReferenceClassData<JVMTypes.java_lang_Object>) => {\n      Object.keys(iface._methodLookup).forEach((ifaceMethodSig: string) => {\n        var ifaceM = iface._methodLookup[ifaceMethodSig];\n        if (this._methodLookup[ifaceMethodSig] === undefined) {\n          if (!ifaceM.accessFlags.isStatic()) {\n            // New vmindex.\n            this._vmTable.push(ifaceM);\n          }\n          this._methodLookup[ifaceMethodSig] = ifaceM;\n        } else if (ifaceM.isDefault()) {\n          // Default method; uninherited, but still callable via full signature.\n          this._uninheritedDefaultMethods.push(ifaceM);\n        }\n      });\n    });\n  }\n\n  /**\n   * Resolves all of the fields for this class according to the JVM\n   * specification:\n   * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.3.2\n   */\n  private _resolveFields(): void {\n    if (this.superClass !== null) {\n      // Start off w/ my parent class' fields.\n      this._objectFields = this._objectFields.concat(this.superClass._objectFields);\n      Object.keys(this.superClass._fieldLookup).forEach((f: string) => {\n        this._fieldLookup[f] = this.superClass._fieldLookup[f];\n      });\n    }\n\n    // Superinterface fields trump superclass fields.\n    this.interfaceClasses.forEach((iface: ReferenceClassData<JVMTypes.java_lang_Object>) => {\n      Object.keys(iface._fieldLookup).forEach((ifaceFieldName: string) => {\n        var ifaceF = iface._fieldLookup[ifaceFieldName];\n        assert(ifaceF.accessFlags.isStatic(), \"Interface fields must be static.\");\n        this._fieldLookup[ifaceFieldName] = ifaceF;\n      });\n    });\n\n    // My fields override all other fields.\n    this.fields.forEach((f: methods.Field) => {\n      this._fieldLookup[f.name] = f;\n      if (f.accessFlags.isStatic()) {\n        this._staticFields.push(f);\n      } else {\n        this._objectFields.push(f);\n      }\n    });\n  }\n\n  /**\n   * Looks up a method with the given signature. Returns null if no method\n   * found.\n   */\n  public methodLookup(signature: string): methods.Method {\n    var m = this._methodLookup[signature];\n    if (m !== undefined) {\n      return m;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Performs method lookup, and includes signature polymorphic results if\n   * the method is signature polymorphic.\n   */\n  public signaturePolymorphicAwareMethodLookup(signature: string): methods.Method {\n    var m: methods.Method;\n    if (null !== (m = this.methodLookup(signature))) {\n      return m;\n    } else if (this.className === 'Ljava/lang/invoke/MethodHandle;') {\n      // Check if this is a signature polymorphic method.\n      // From S2.9:\n      // A method is signature polymorphic if and only if all of the following conditions hold :\n      // * It is declared in the java.lang.invoke.MethodHandle class.\n      // * It has a single formal parameter of type Object[].\n      // * It has a return type of Object.\n      // * It has the ACC_VARARGS and ACC_NATIVE flags set.\n      var polySig = `${signature.slice(0, signature.indexOf('('))}([Ljava/lang/Object;)Ljava/lang/Object;`,\n        m = this._methodLookup[polySig];\n      if (m !== undefined && m.accessFlags.isNative() && m.accessFlags.isVarArgs() && m.cls === this) {\n        return m;\n      }\n    } else if (this.superClass !== null) {\n      return this.superClass.signaturePolymorphicAwareMethodLookup(signature);\n    }\n    return null;\n  }\n\n  /**\n   * Looks up a field with the given name. Returns null if no method found.\n   */\n  public fieldLookup(name: string): methods.Field {\n    var f = this._fieldLookup[name];\n    if (f !== undefined) {\n      return f;\n    } else {\n      return null;\n    }\n  }\n\n  public getAttribute(name: string): attributes.IAttribute {\n    var attrs = this.attrs;\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.getName() === name) {\n        return attr;\n      }\n    }\n    return null;\n  }\n\n  public getAttributes(name: string): attributes.IAttribute[] {\n    var attrs = this.attrs;\n    var results : attributes.IAttribute[] = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (attr.getName() === name) {\n        results.push(attr);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Get the bootstrap method information for an InvokeDynamic opcode.\n   */\n  public getBootstrapMethod(idx: number): [ConstantPool.MethodHandle, ConstantPool.IConstantPoolItem[]] {\n    var bms = <attributes.BootstrapMethods> this.getAttribute('BootstrapMethods');\n    return bms.bootstrapMethods[idx];\n  }\n\n  /**\n   * Returns the initial value for a given static field in the class. Should\n   * only be called when the constructor is created.\n   */\n  private _getInitialStaticFieldValue(thread: JVMThread, name: string): any {\n    var f: methods.Field = this.fieldLookup(name);\n    if (f !== null && f.accessFlags.isStatic()) {\n      var cva = <attributes.ConstantValue> f.getAttribute('ConstantValue');\n      if (cva !== null) {\n        switch (cva.value.getType()) {\n          case enums.ConstantPoolItemType.STRING:\n            var stringCPI = <ConstantPool.ConstString> cva.value;\n            if (stringCPI.value === null) {\n              stringCPI.value = thread.getJVM().internString(stringCPI.stringValue);\n            }\n            return stringCPI.value;\n          default:\n            // TODO: Type better.\n            return (<any> cva.value).value;\n        }\n      } else {\n        return util.initialValue(f.rawDescriptor);\n      }\n    }\n    assert(false, `Tried to construct a static field value that ${f !== null ? \"isn't static\" : \"doesn't exist\"}: ${f !== null ? f.cls.getInternalName() : this.getInternalName()} ${name}`);\n  }\n\n  public setResolved(superClazz: ReferenceClassData<JVMTypes.java_lang_Object>, interfaceClazzes: ReferenceClassData<JVMTypes.java_lang_Object>[]): void {\n    this.superClass = superClazz;\n    trace(`Class ${this.getInternalName()} is now resolved.`);\n    this.interfaceClasses = interfaceClazzes;\n    // TODO: Assert we are not already resolved or initialized?\n    this._resolveMethods();\n    this._resolveFields();\n    this.setState(ClassState.RESOLVED);\n  }\n\n  public tryToResolve(): boolean {\n    if (this.getState() === ClassState.LOADED) {\n      // Need to grab the super class, and interfaces.\n      var loader = this.loader,\n        toResolve = this.superClassRef !== null ? this.interfaceRefs.concat(this.superClassRef) : this.interfaceRefs,\n        allGood = true,\n        resolvedItems: ReferenceClassData<JVMTypes.java_lang_Object>[] = [], i: number,\n        item: ConstantPool.ClassReference;\n      for (i = 0; i < toResolve.length; i++) {\n        item = toResolve[i];\n        if (item.tryResolve(loader)) {\n          resolvedItems.push(<ReferenceClassData<JVMTypes.java_lang_Object>> item.cls);\n        } else {\n          return false;\n        }\n      }\n\n      // It worked!\n      this.setResolved(this.superClassRef !== null ? resolvedItems.pop() : null, resolvedItems);\n    }\n    return true;\n  }\n\n  /**\n   * Attempt to synchronously initialize. This is possible if there is no\n   * static initializer, and the parent classes are properly initialized.\n   */\n  public tryToInitialize(): boolean {\n    if (this.getState() === ClassState.INITIALIZED) {\n      // Already initialized.\n      return true;\n    }\n\n    if (this.getState() === ClassState.RESOLVED || this.tryToResolve()) {\n      // Ensure parent is initialized.\n      if (this.superClass !== null && !this.superClass.tryToInitialize()) {\n        // Parent failed to initialize.\n        return false;\n      }\n\n      // Check if this class has a static initializer.\n      var clinit = this.getMethod('<clinit>()V');\n      if (clinit !== null) {\n        // Nope; this class needs to do the full initialization song-and-dance.\n        return false;\n      } else {\n        // No static initializer! This class is initialized!\n        this.setState(ClassState.INITIALIZED);\n        return true;\n      }\n    }\n\n    // This class is not resolved.\n    return false;\n  }\n\n  /**\n   * Returns a boolean indicating if this class is an instance of the target class.\n   * \"target\" is a ClassData object.\n   * The ClassData objects do not need to be initialized; just loaded.\n   * See §2.6.7 for casting rules.\n   * @todo Determine this statically to make this a constant time operation.\n   */\n  public isCastable(target: ClassData): boolean {\n    if (!(target instanceof ReferenceClassData)) {\n      return false;\n    }\n    if (this.accessFlags.isInterface()) {\n      // We are both interfaces\n      if (target.accessFlags.isInterface()) {\n        return this.isSubinterface(target);\n      }\n      // Only I am an interface\n      if (!target.accessFlags.isInterface()) {\n        return target.getInternalName() === 'Ljava/lang/Object;';\n      }\n    } else {\n      // I am a regular class, target is an interface\n      if (target.accessFlags.isInterface()) {\n        return this.isSubinterface(target);\n      }\n      // We are both regular classes\n      return this.isSubclass(target);\n    }\n  }\n\n  /**\n   * Returns 'true' if I implement the target interface.\n   */\n  public isSubinterface(target: ClassData): boolean {\n    if (this.className === target.getInternalName()) {\n      return true;\n    }\n    var ifaces = this.getInterfaces();\n    for (var i = 0; i < ifaces.length; i++) {\n      var superIface = ifaces[i];\n      if (superIface.isSubinterface(target)) {\n        return true;\n      }\n    }\n    if (this.getSuperClass() == null) {\n      return false;\n    }\n    return this.getSuperClass().isSubinterface(target);\n  }\n\n  /**\n   * Asynchronously *initializes* the class and its super classes.\n   * Throws a Java exception on the thread if initialization fails.\n   * @param thread The thread that is performing the initialization.\n   * @param cb Callback to invoke when completed. Contains a reference to the\n   *   class if it succeeds, or NULL if a failure occurs.\n   * @param [explicit] Defaults to true. If true, this class is being\n   *   *explicitly* initialized by a user. If false, the JVM is implicitly\n   *   initializing the class.\n   */\n  public initialize(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    if (this.isResolved()) {\n      if (this.isInitialized(thread)) {\n        // Nothing to do! Either resolution failed and an exception has already\n        // been thrown, cdata is already initialized, or the current thread is\n        // initializing the class.\n        setImmediate(() => {\n          cb(this);\n        });\n      } else if (this.initLock.tryLock(thread, cb)) {\n        // Initialize the super class, and then this class.\n        if (this.superClass != null) {\n          this.superClass.initialize(thread, (cdata: ClassData) => {\n            if (cdata == null) {\n              // Nothing to do. Initializing the super class failed.\n              this.initLock.unlock(null);\n            } else {\n              // Initialize myself.\n              this._initialize(thread, (cdata: ClassData) => {\n                this.initLock.unlock(cdata);\n              });\n            }\n          }, explicit);\n        } else {\n          // java/lang/Object's parent is NULL.\n          // Continue initializing this class.\n          this._initialize(thread, (cdata: ClassData) => {\n            this.initLock.unlock(cdata);\n          });\n        }\n      }\n    } else {\n      // Resolve first, then initialize.\n      this.resolve(thread, (cdata: ClassData) => {\n        if (cdata !== null) {\n          this.initialize(thread, cb, explicit);\n        } else {\n          // Else: An exception was thrown.\n          cb(cdata);\n        }\n      }, explicit);\n    }\n  }\n\n  /**\n   * Helper function. Initializes this class alone. Assumes super class is\n   * already initialized.\n   */\n  private _initialize(thread: JVMThread, cb: (cdata: ClassData) => void): void {\n    var cons = <typeof JVMTypes.java_lang_Object> <any> this.getConstructor(thread);\n    if (cons['<clinit>()V'] !== undefined) {\n      debug(`T${thread.getRef()} Running static initialization for class ${this.className}...`);\n      cons['<clinit>()V'](thread, null, (e?: JVMTypes.java_lang_Throwable) => {\n        if (e) {\n          debug(`Initialization of class ${this.className} failed.`);\n          this.setState(enums.ClassState.RESOLVED);\n          /**\n           * \"The class or interface initialization method must have completed\n           *  abruptly by throwing some exception E. If the class of E is not\n           *  Error or one of its subclasses, then create a new instance of the\n           *  class ExceptionInInitializerError with E as the argument, and use\n           *  this object in place of E.\"\n           * @url http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5\n           */\n          if (e.getClass().isCastable(thread.getBsCl().getResolvedClass('Ljava/lang/Error;'))) {\n            // 'e' is 'Error or one of its subclasses'.\n            thread.throwException(e);\n            cb(null);\n          } else {\n            // Wrap the error.\n            thread.getBsCl().initializeClass(thread, 'Ljava/lang/ExceptionInInitializerError;', (cdata: ReferenceClassData<JVMTypes.java_lang_ExceptionInInitializerError>) => {\n              if (cdata == null) {\n                // Exceptional failure right here: *We failed to construct ExceptionInInitializerError*!\n                // initializeClass will throw an exception on our behalf;\n                // nothing to do.\n                cb(null);\n              } else {\n                // Construct the object!\n                var eCons = cdata.getConstructor(thread),\n                  e2 = new eCons(thread);\n                // Construct the ExceptionInInitializerError!\n                e2[\"<init>(Ljava/lang/Throwable;)V\"](thread, [e], (e?: JVMTypes.java_lang_Throwable) => {\n                  // Throw the newly-constructed error!\n                  thread.throwException(e2);\n                  cb(null);\n                });\n              }\n            });\n          }\n        } else {\n          this.setState(enums.ClassState.INITIALIZED);\n          debug(`Initialization of class ${this.className} succeeded.`);\n          // Normal case! Initialization succeeded.\n          cb(this);\n        }\n      });\n    } else {\n      // Class doesn't have a static initializer.\n      this.setState(enums.ClassState.INITIALIZED);\n      cb(this);\n    }\n  }\n\n  /**\n   * A reference class can be treated as initialized in a thread if that thread\n   * is in the process of initializing it.\n   */\n  public isInitialized(thread: JVMThread): boolean {\n    return this.getState() === ClassState.INITIALIZED || this.initLock.getOwner() === thread;\n  }\n\n  /**\n   * Resolve the class.\n   */\n  public resolve(thread: JVMThread, cb: (cdata: ClassData) => void, explicit: boolean = true): void {\n    var toResolve: ConstantPool.ClassReference[] = this.interfaceRefs.slice(0);\n    if (this.superClassRef !== null) {\n      toResolve.push(this.superClassRef);\n    }\n    toResolve = toResolve.filter((item: ConstantPool.ClassReference) => !item.isResolved());\n    util.asyncForEach(toResolve, (clsRef: ConstantPool.ClassReference, nextItem: (err?: any) => void) => {\n      clsRef.resolve(thread, this.loader, this, (status: boolean) => {\n        if (!status) {\n          nextItem(\"Failed.\");\n        } else {\n          nextItem();\n        }\n      }, explicit);\n    }, (err?: any) => {\n      if (!err) {\n        this.setResolved(this.superClassRef !== null ? <ReferenceClassData<JVMTypes.java_lang_Object>> this.superClassRef.cls : null, this.interfaceRefs.map((ref: ConstantPool.ClassReference) => <ReferenceClassData<JVMTypes.java_lang_Object>> ref.cls));\n        cb(this);\n      } else {\n        cb(null);\n      }\n    });\n  }\n\n  /**\n   * Find Miranda and default interface methods in this class. These\n   * methods manifest as new vmindices in the virtual method table compared with\n   * the superclass, and are not defined in this class itself.\n   */\n  public getMirandaAndDefaultMethods(): methods.Method[] {\n    var superClsMethodTable: methods.Method[] = this.superClass !== null ? this.superClass.getVMTable() : [];\n    return this.getVMTable().slice(superClsMethodTable.length).filter((method: methods.Method) => method.cls !== this);\n  }\n\n  public outputInjectedFields(outputStream: StringOutputStream) {\n    if (this.superClass !== null) {\n      this.superClass.outputInjectedFields(outputStream);\n    }\n    var injected = injectedFields[this.getInternalName()];\n    if (injected !== undefined) {\n      Object.keys(injected).forEach((fieldName: string) => {\n        outputStream.write(`this.${fieldName} = ${injected[fieldName][1]};\\n`);\n      });\n    }\n  }\n\n  protected _constructConstructor(thread: JVMThread): IJVMConstructor<T> {\n    assert(this._constructor === null, `Attempted to construct constructor twice for class ${this.getExternalName()}!`);\n\n    var jsClassName = util.jvmName2JSName(this.getInternalName()),\n      outputStream = new StringOutputStream();\n\n    // Expects args: extendClass, cls, InternalStackFrame, NativeStackFrame, BytecodeStackFrame, gLongZero, ClassLoader, Monitor, thread\n    outputStream.write(`if (cls.superClass !== null) {\n    extendClass(${jsClassName}, cls.superClass.getConstructor(thread));\n  }\n  function ${jsClassName}(thread) {\\n`);\n    // Injected fields.\n    this.outputInjectedFields(outputStream);\n\n    // Output instance field assignments.\n    this._objectFields.forEach((f: methods.Field) => f.outputJavaScriptField(jsClassName, outputStream));\n    outputStream.write(`  }\n  ${jsClassName}.cls = cls;\\n`);\n\n    // Injected methods.\n    this.outputInjectedMethods(jsClassName, outputStream);\n\n    // Static fields.\n    this._staticFields.forEach((f: methods.Field) => f.outputJavaScriptField(jsClassName, outputStream));\n\n    // Static and instance methods.\n    this.getMethods().forEach((m: methods.Method) => m.outputJavaScriptFunction(jsClassName, outputStream));\n\n    // Miranda and default interface methods.\n    this.getMirandaAndDefaultMethods().forEach((m: methods.Method) => m.outputJavaScriptFunction(jsClassName, outputStream));\n\n    // Uninherited default methods.\n    this.getUninheritedDefaultMethods().forEach((m: methods.Method) => m.outputJavaScriptFunction(jsClassName, outputStream, true));\n\n    outputStream.write(`  return ${jsClassName};`);\n\n    var evalText = outputStream.flush();\n    // NOTE: Thread will be null during system bootstrapping.\n    if (!RELEASE && thread !== null && thread.getJVM().shouldDumpCompiledCode()) {\n      thread.getJVM().dumpObjectDefinition(this, evalText);\n    }\n    const fcn = new Function(\"extendClass\", \"cls\", \"InternalStackFrame\", \"NativeStackFrame\", \"BytecodeStackFrame\", \"gLongZero\", \"ClassLoader\", \"Monitor\", \"thread\", \"getRef\", \"util\", evalText);\n    return fcn(extendClass, this, InternalStackFrame, NativeStackFrame, BytecodeStackFrame, gLong.ZERO, require('./ClassLoader'), require('./Monitor'), thread, getRef, util);\n  }\n\n  public getConstructor(thread: JVMThread): IJVMConstructor<T> {\n    if (this._constructor == null) {\n      assert(this.isResolved(), `Cannot construct ${this.getInternalName()}'s constructor until it is resolved.`);\n      this._constructor = this._constructConstructor(thread);\n    }\n    return this._constructor;\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ClassData.ts\n **/","﻿\"use strict\";\nimport gLong = require('./gLong');\nimport assert = require('./assert');\n\n/**\n * A ByteStream, implemented using a NodeBuffer.\n */\nclass ByteStream {\n  private _index: number = 0;\n\n  constructor(private buffer: NodeBuffer) {}\n\n  /**\n   * Returns the current read index, and increments the index by the indicated\n   * amount.\n   */\n  private incIndex(inc: number): number {\n    var readIndex = this._index;\n    this._index += inc;\n    return readIndex;\n  }\n\n  public rewind(): void {\n    this._index = 0;\n  }\n\n  public seek(idx: number) {\n    assert(idx >= 0 && idx < this.buffer.length, \"Invalid seek position.\");\n    this._index = idx;\n  }\n\n  public pos(): number {\n    return this._index;\n  }\n\n  public skip(bytesCount: number): void {\n    this._index += bytesCount;\n  }\n\n  public hasBytes(): boolean {\n    return this._index < this.buffer.length;\n  }\n\n  public getFloat(): number {\n    return this.buffer.readFloatBE(this.incIndex(4));\n  }\n\n  public getDouble(): number {\n    return this.buffer.readDoubleBE(this.incIndex(8));\n  }\n\n  public getUint(byteCount: number): number {\n    switch (byteCount) {\n      case 1:\n        return this.getUint8();\n      case 2:\n        return this.getUint16();\n      case 4:\n        return this.getUint32();\n      default:\n        throw new Error(\"Invalid byte count for getUint: \" + byteCount);\n    }\n  }\n\n  public getInt(byteCount: number): number {\n    switch (byteCount) {\n      case 1:\n        return this.getInt8();\n      case 2:\n        return this.getInt16();\n      case 4:\n        return this.getInt32();\n      default:\n        throw new Error(\"Invalid byte count for getUint: \" + byteCount);\n    }\n  }\n\n  public getUint8(): number {\n    return this.buffer.readUInt8(this.incIndex(1));\n  }\n\n  public getUint16(): number {\n    return this.buffer.readUInt16BE(this.incIndex(2));\n  }\n\n  public getUint32(): number {\n    return this.buffer.readUInt32BE(this.incIndex(4));\n  }\n\n  public getInt8(): number {\n    return this.buffer.readInt8(this.incIndex(1));\n  }\n\n  public getInt16(): number {\n    return this.buffer.readInt16BE(this.incIndex(2));\n  }\n\n  public getInt32(): number {\n    return this.buffer.readInt32BE(this.incIndex(4));\n  }\n\n  public getInt64(): gLong {\n    var high = this.getUint32();\n    var low = this.getUint32();\n    return gLong.fromBits(low, high);\n  }\n\n  public read(bytesCount: number): Buffer {\n    var rv = this.buffer.slice(this._index, this._index + bytesCount);\n    this._index += bytesCount;\n    return rv;\n  }\n\n  public peek(): number {\n    return this.buffer.readUInt8(this._index);\n  }\n\n  public size(): number {\n    return this.buffer.length - this._index;\n  }\n\n  public slice(len: number): ByteStream {\n    var arr = new ByteStream(this.buffer.slice(this._index, this._index + len));\n    this._index += len;\n    return arr;\n  }\n\n  public getBuffer(): NodeBuffer {\n    return this.buffer;\n  }\n}\n\nexport = ByteStream;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ByteStream.ts\n **/","\"use strict\";\nimport gLong = require('./gLong');\nimport ByteStream = require('./ByteStream');\nimport util = require('./util');\nimport enums = require('./enums');\nimport assert = require('./assert');\nimport ClassData = require('./ClassData');\nimport methods = require('./methods');\nimport ClassLoader = require('./ClassLoader');\n// For type information.\nimport threading = require('./threading');\nimport JVMTypes = require('../includes/JVMTypes');\n\n/**\n * Represents a constant pool item. Use the item's type to discriminate among them.\n */\nexport interface IConstantPoolItem {\n  getType(): enums.ConstantPoolItemType;\n  /**\n   * Is this constant pool item resolved? Use to discriminate among resolved\n   * and unresolved reference types.\n   */\n  isResolved(): boolean;\n  /**\n   * Returns the constant associated with the constant pool item. The item *must*\n   * be resolved.\n   * Only defined on constant pool items that return values through LDC.\n   */\n  getConstant?(thread: threading.JVMThread): any;\n  /**\n   * Resolves an unresolved constant pool item. Can only be called if\n   * isResolved() returns false.\n   */\n  resolve?(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit?: boolean): void;\n}\n\n/**\n * All constant pool items have a static constructor function.\n */\nexport interface IConstantPoolType {\n  fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem;\n  /**\n   * The resulting size in the constant pool, in machine words.\n   */\n  size: number;\n  /**\n   * The bytesize on disk of the item's information past the tag byte.\n   */\n  infoByteSize: number;\n}\n/**\n * Stores all of the constant pool classes, keyed on their enum value.\n */\nvar CP_CLASSES: { [n: number]: IConstantPoolType } = {};\n\n// #region Tier 0\n\n/**\n * Represents a constant UTF-8 string.\n * ```\n * CONSTANT_Utf8_info {\n *   u1 tag;\n *   u2 length;\n *   u1 bytes[length];\n * }\n * ```\n */\nexport class ConstUTF8 implements IConstantPoolItem {\n  public value: string;\n  constructor(rawBytes: Buffer) {\n    this.value = this.bytes2str(rawBytes);\n  }\n\n  /**\n   * Parse Java's pseudo-UTF-8 strings into valid UTF-16 codepoints (spec 4.4.7)\n   * Note that Java uses UTF-16 internally by default for string representation,\n   * and the pseudo-UTF-8 strings are *only* used for serialization purposes.\n   * Thus, there is no reason for other parts of the code to call this routine!\n   * TODO: To avoid copying, create a character array for this data.\n   * http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7\n   */\n  private bytes2str(bytes: Buffer): string {\n    var y: number, z: number, v: number, w: number, x: number, charCode: number, idx = 0, rv = '';\n    while (idx < bytes.length) {\n      x = bytes.readUInt8(idx++) & 0xff;\n      // While the standard specifies that surrogate pairs should be handled, it seems like\n      // they are by default with the three byte format. See parsing code here:\n      // http://hg.openjdk.java.net/jdk8u/jdk8u-dev/jdk/file/3623f1b29b58/src/share/classes/java/io/DataInputStream.java#l618\n\n      // One UTF-16 character.\n      if (x <= 0x7f) {\n        // One character, one byte.\n        charCode = x;\n      } else if (x <= 0xdf) {\n        // One character, two bytes.\n        y = bytes.readUInt8(idx++);\n        charCode = ((x & 0x1f) << 6) + (y & 0x3f);\n      } else {\n        // One character, three bytes.\n        y = bytes.readUInt8(idx++);\n        z = bytes.readUInt8(idx++);\n        charCode = ((x & 0xf) << 12) + ((y & 0x3f) << 6) + (z & 0x3f);\n      }\n      rv += String.fromCharCode(charCode);\n    }\n\n    return rv;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.UTF8;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return true; }\n\n  public static size: number = 1;\n  // Variable-size.\n  public static infoByteSize: number = 0;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var strlen = byteStream.getUint16();\n    return new this(byteStream.read(strlen));\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.UTF8] = ConstUTF8;\n\n/**\n * Represents a constant 32-bit integer.\n * ```\n * CONSTANT_Integer_info {\n *   u1 tag;\n *   u4 bytes;\n * }\n * ```\n */\nexport class ConstInt32 implements IConstantPoolItem {\n  public value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.INTEGER;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return true; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    return new this(byteStream.getInt32());\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.INTEGER] = ConstInt32;\n\n/**\n * Represents a constant 32-bit floating point number.\n * ```\n * CONSTANT_Float_info {\n *   u1 tag;\n *   u4 bytes;\n * }\n * ```\n */\nexport class ConstFloat implements IConstantPoolItem {\n  public value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.FLOAT;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return true; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    return new this(byteStream.getFloat());\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.FLOAT] = ConstFloat;\n\n/**\n * Represents a constant 64-bit integer.\n * ```\n * CONSTANT_Long_info {\n *   u1 tag;\n *   u4 high_bytes;\n *   u4 low_bytes;\n * }\n * ```\n */\nexport class ConstLong implements IConstantPoolItem {\n  public value: gLong;\n  constructor(value: gLong) {\n    this.value = value;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.LONG;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return true; }\n\n  public static size: number = 2;\n  public static infoByteSize: number = 8;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    return new this(byteStream.getInt64());\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.LONG] = ConstLong;\n\n/**\n * Represents a constant 64-bit floating point number.\n * ```\n * CONSTANT_Double_info {\n *   u1 tag;\n *   u4 high_bytes;\n *   u4 low_bytes;\n * }\n * ```\n */\nexport class ConstDouble implements IConstantPoolItem {\n  public value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.DOUBLE;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return true; }\n\n  public static size: number = 2;\n  public static infoByteSize: number = 8;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    return new this(byteStream.getDouble());\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.DOUBLE] = ConstDouble;\n\n// #endregion\n\n// #region Tier 1\n\n/**\n * Represents a class or interface.\n * ```\n * CONSTANT_Class_info {\n *   u1 tag;\n *   u2 name_index;\n * }\n * ```\n * @todo Have a classloader-local cache of class reference objects.\n */\nexport class ClassReference implements IConstantPoolItem {\n  /**\n   * The name of the class, in full descriptor form, e.g.:\n   * Lfoo/bar/Baz;\n   */\n  public name: string;\n  /**\n   * The resolved class reference.\n   */\n  public cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object> | ClassData.ArrayClassData<any> = null;\n  /**\n   * The JavaScript constructor for the referenced class.\n   */\n  public clsConstructor: ClassData.IJVMConstructor<JVMTypes.java_lang_Object> = null;\n  /**\n   * The array class for the resolved class reference.\n   */\n  public arrayClass: ClassData.ArrayClassData<any> = null;\n  /**\n   * The JavaScript constructor for the array class.\n   */\n  public arrayClassConstructor: ClassData.IJVMConstructor<JVMTypes.JVMArray<any>> = null;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Attempt to synchronously resolve.\n   */\n  public tryResolve(loader: ClassLoader.ClassLoader): boolean {\n    if (this.cls === null) {\n      this.cls = <ClassData.ReferenceClassData<JVMTypes.java_lang_Object>> loader.getResolvedClass(this.name);\n    }\n    return this.cls !== null;\n  }\n\n  /**\n   * Resolves the class reference by resolving the class. Does not run\n   * class initialization.\n   */\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit: boolean = true) {\n    // Because of Java 8 anonymous classes, THIS CHECK IS REQUIRED FOR CORRECTNESS.\n    // (ClassLoaders do not know about anonymous classes, hence they are\n    //  'anonymous')\n    // (Anonymous classes are an 'Unsafe' feature, and are not part of the standard,\n    //  but they are employed for lambdas and such.)\n    // NOTE: Thread is 'null' during JVM bootstrapping.\n    if (thread !== null) {\n      var currentMethod = thread.currentMethod();\n      // The stack might be empty during resolution, which occurs during JVM bootup.\n      if (currentMethod !== null && this.name === currentMethod.cls.getInternalName()) {\n        this.setResolved(thread, thread.currentMethod().cls);\n        return cb(true);\n      }\n    }\n\n    loader.resolveClass(thread, this.name, (cdata: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>) => {\n      this.setResolved(thread, cdata);\n      cb(cdata !== null);\n    }, explicit);\n  }\n\n  private setResolved(thread: threading.JVMThread, cls: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>) {\n    this.cls = cls;\n    if (cls !== null) {\n      this.clsConstructor = cls.getConstructor(thread);\n    }\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.CLASS;\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.cls.getClassObject(thread); }\n\n  public isResolved() { return this.cls !== null; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 2;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var nameIndex = byteStream.getUint16(),\n      cpItem = constantPool.get(nameIndex);\n    assert(cpItem.getType() === enums.ConstantPoolItemType.UTF8,\n      'ConstantPool ClassReference type != UTF8');\n    // The ConstantPool stores class names without the L...; descriptor stuff\n    return new this(util.typestr2descriptor((<ConstUTF8> cpItem).value));\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.CLASS] = ClassReference;\n\n/**\n * Represents a field or method without indicating which class or interface\n * type it belongs to.\n * ```\n * CONSTANT_NameAndType_info {\n *   u1 tag;\n *   u2 name_index;\n *   u2 descriptor_index;\n * }\n * ```\n */\nexport class NameAndTypeInfo implements IConstantPoolItem {\n  public name: string;\n  public descriptor: string;\n  constructor(name: string, descriptor: string) {\n    this.name = name;\n    this.descriptor = descriptor;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.NAME_AND_TYPE;\n  }\n\n  public isResolved() { return true; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var nameIndex = byteStream.getUint16(),\n      descriptorIndex = byteStream.getUint16(),\n      nameConst = <ConstUTF8> constantPool.get(nameIndex),\n      descriptorConst = <ConstUTF8> constantPool.get(descriptorIndex);\n    assert(nameConst.getType() === enums.ConstantPoolItemType.UTF8 &&\n      descriptorConst.getType() === enums.ConstantPoolItemType.UTF8,\n      'ConstantPool NameAndTypeInfo types != UTF8');\n    return new this(nameConst.value, descriptorConst.value);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.NAME_AND_TYPE] = NameAndTypeInfo;\n\n/**\n * Represents constant objects of the type java.lang.String.\n * ```\n * CONSTANT_String_info {\n *   u1 tag;\n *   u2 string_index;\n * }\n * ```\n */\nexport class ConstString implements IConstantPoolItem {\n  public stringValue: string;\n  public value: JVMTypes.java_lang_String = null;\n  constructor(stringValue: string) {\n    this.stringValue = stringValue;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.STRING;\n  }\n\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void) {\n    this.value = thread.getJVM().internString(this.stringValue);\n    setImmediate(() => cb(true));\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.value; }\n\n  public isResolved() { return this.value !== null; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 2;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var stringIndex = byteStream.getUint16(),\n      utf8Info = <ConstUTF8> constantPool.get(stringIndex);\n    assert(utf8Info.getType() === enums.ConstantPoolItemType.UTF8,\n      'ConstantPool ConstString type != UTF8');\n    return new this(utf8Info.value);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.STRING] = ConstString;\n\n/**\n * Represents a given method type.\n * ```\n * CONSTANT_MethodType_info {\n *   u1 tag;\n *   u2 descriptor_index;\n * }\n * ```\n */\nexport class MethodType implements IConstantPoolItem {\n  private descriptor: string;\n  public methodType: JVMTypes.java_lang_invoke_MethodType = null;\n  constructor(descriptor: string) {\n    this.descriptor = descriptor;\n  }\n\n  public resolve(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void) {\n    util.createMethodType(thread, cl, this.descriptor, (e: JVMTypes.java_lang_Throwable, type: JVMTypes.java_lang_invoke_MethodType) => {\n      if (e) {\n        thread.throwException(e);\n        cb(false);\n      } else {\n        this.methodType = type;\n        cb(true);\n      }\n    });\n  }\n\n  public getConstant(thread: threading.JVMThread) { return this.methodType; }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.METHOD_TYPE;\n  }\n\n  public isResolved() { return this.methodType !== null; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 2;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var descriptorIndex = byteStream.getUint16(),\n      utf8Info = <ConstUTF8> constantPool.get(descriptorIndex);\n    assert(utf8Info.getType() === enums.ConstantPoolItemType.UTF8,\n      'ConstantPool MethodType type != UTF8');\n    return new this(utf8Info.value);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.METHOD_TYPE] = MethodType;\n\n// #endregion\n\n// #region Tier 2\n\n/**\n * Represents a particular method.\n * ```\n * CONSTANT_Methodref_info {\n *   u1 tag;\n *   u2 class_index;\n *   u2 name_and_type_index;\n * }\n * ```\n */\nexport class MethodReference implements IConstantPoolItem {\n  public classInfo: ClassReference;\n  public nameAndTypeInfo: NameAndTypeInfo;\n  public method: methods.Method = null;\n  /**\n   * The signature of the method, without the owning class.\n   * e.g. foo(IJ)V\n   */\n  public signature: string;\n  /**\n   * The signature of the method, including the owning class.\n   * e.g. bar/Baz/foo(IJ)V\n   */\n  public fullSignature: string = null;\n  public paramWordSize: number = -1;\n  /**\n   * Contains a reference to the MemberName object for the method that invokes\n   * the desired function.\n   */\n  public memberName: JVMTypes.java_lang_invoke_MemberName = null;\n  /**\n   * Contains an object that needs to be pushed onto the stack before invoking\n   * memberName.\n   */\n  public appendix: JVMTypes.java_lang_Object = null;\n  /**\n   * The JavaScript constructor for the class that the method belongs to.\n   */\n  public jsConstructor: any = null;\n\n  constructor(classInfo: ClassReference, nameAndTypeInfo: NameAndTypeInfo) {\n    this.classInfo = classInfo;\n    this.nameAndTypeInfo = nameAndTypeInfo;\n    this.signature = this.nameAndTypeInfo.name + this.nameAndTypeInfo.descriptor;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.METHODREF;\n  }\n\n  /**\n   * Checks the method referenced by this constant pool item in the specified\n   * bytecode context.\n   * Returns null if an error occurs.\n   * - Throws a NoSuchFieldError if missing.\n   * - Throws an IllegalAccessError if field is inaccessible.\n   * - Throws an IncompatibleClassChangeError if the field is an incorrect type\n   *   for the field access.\n   */\n  public hasAccess(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, isStatic: boolean): boolean {\n    var method = this.method, accessingCls = frame.method.cls;\n    if (method.accessFlags.isStatic() !== isStatic) {\n      thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', `Method ${method.name} from class ${method.cls.getExternalName()} is ${isStatic ? 'not ' : ''}static.`);\n      frame.returnToThreadLoop = true;\n      return false;\n    } else if (!util.checkAccess(accessingCls, method.cls, method.accessFlags)) {\n      thread.throwNewException('Ljava/lang/IllegalAccessError;', `${accessingCls.getExternalName()} cannot access ${method.cls.getExternalName()}.${method.name}`);\n      frame.returnToThreadLoop = true;\n      return false;\n    }\n    return true;\n  }\n\n  private resolveMemberName(method: methods.Method, thread: threading.JVMThread, cl: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void): void {\n    var memberHandleNatives = <typeof JVMTypes.java_lang_invoke_MethodHandleNatives>  (<ClassData.ReferenceClassData<JVMTypes.java_lang_invoke_MethodHandleNatives>> thread.getBsCl().getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;')).getConstructor(thread),\n      appendix = new ((<ClassData.ArrayClassData<JVMTypes.java_lang_Object>> thread.getBsCl().getInitializedClass(thread, '[Ljava/lang/Object;')).getConstructor(thread))(thread, 1);\n\n    util.createMethodType(thread, cl, this.nameAndTypeInfo.descriptor, (e: JVMTypes.java_lang_Throwable, type: JVMTypes.java_lang_invoke_MethodType) => {\n      if (e) {\n        thread.throwException(e);\n        cb(false);\n      } else {\n        /* MemberName linkMethod( int refKind, Class<?> defc,\n           String name, Object type,\n           Object[] appendixResult) */\n        memberHandleNatives['java/lang/invoke/MethodHandleNatives/linkMethod(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;'](\n          thread,\n          // Class callerClass\n          [caller.getClassObject(thread),\n          // int refKind\n           enums.MethodHandleReferenceKind.INVOKEVIRTUAL,\n          // Class defc\n           this.classInfo.cls.getClassObject(thread),\n          // String name\n           thread.getJVM().internString(this.nameAndTypeInfo.name),\n          // Object type, Object[] appendixResult\n           type, appendix],\n        (e?: JVMTypes.java_lang_Throwable, rv?: JVMTypes.java_lang_invoke_MemberName) => {\n          if (e !== null) {\n            thread.throwException(e);\n            cb(false);\n          } else {\n            this.appendix = appendix.array[0];\n            this.memberName = rv;\n            cb(true);\n          }\n        });\n      }\n    });\n  }\n\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit: boolean = true) {\n    if (!this.classInfo.isResolved()) {\n      this.classInfo.resolve(thread, loader, caller, (status: boolean) => {\n        if (!status) {\n          cb(false);\n        } else {\n          this.resolve(thread, loader, caller, cb, explicit);\n        }\n      }, explicit);\n    } else {\n      var cls = this.classInfo.cls,\n        method = cls.methodLookup(this.signature);\n      if (method === null) {\n        if (util.is_reference_type(cls.getInternalName())) {\n          // Signature polymorphic lookup.\n          method = (<ClassData.ReferenceClassData<JVMTypes.java_lang_Object>> cls).signaturePolymorphicAwareMethodLookup(this.signature);\n          if (method !== null && (method.name === 'invoke' || method.name === 'invokeExact')) {\n            // In order to completely resolve the signature polymorphic function,\n            // we need to resolve its MemberName object and Appendix.\n            return this.resolveMemberName(method, thread, loader, caller, (status: boolean) => {\n              if (status === true) {\n                this.setResolved(thread, method);\n              } else {\n                thread.throwNewException('Ljava/lang/NoSuchMethodError;', `Method ${this.signature} does not exist in class ${this.classInfo.cls.getExternalName()}.`);\n              }\n              cb(status);\n            });\n          }\n        }\n      }\n      if (method !== null) {\n        this.setResolved(thread, method);\n        cb(true);\n      } else {\n        thread.throwNewException('Ljava/lang/NoSuchMethodError;', `Method ${this.signature} does not exist in class ${this.classInfo.cls.getExternalName()}.`);\n        cb(false);\n      }\n    }\n  }\n\n  public setResolved(thread: threading.JVMThread, method: methods.Method): void {\n    this.method = method;\n    this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n    this.fullSignature = this.method.fullSignature;\n    this.jsConstructor = this.method.cls.getConstructor(thread);\n  }\n\n  public isResolved() { return this.method !== null; }\n  public getParamWordSize(): number {\n    if (this.paramWordSize === -1) {\n      this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n    }\n    return this.paramWordSize;\n  }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var classIndex = byteStream.getUint16(),\n      nameAndTypeIndex = byteStream.getUint16(),\n      classInfo = <ClassReference> constantPool.get(classIndex),\n      nameAndTypeInfo = <NameAndTypeInfo> constantPool.get(nameAndTypeIndex);\n    assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&\n      nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE,\n      'ConstantPool MethodReference types mismatch');\n    return new this(classInfo, nameAndTypeInfo);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.METHODREF] = MethodReference;\n\n/**\n * Represents a particular interface method.\n * ```\n * CONSTANT_InterfaceMethodref_info {\n *   u1 tag;\n *   u2 class_index;\n *   u2 name_and_type_index;\n * }\n * ```\n */\nexport class InterfaceMethodReference implements IConstantPoolItem {\n  public classInfo: ClassReference;\n  public nameAndTypeInfo: NameAndTypeInfo;\n  /**\n   * The signature of the method, without the owning class.\n   * e.g. foo(IJ)V\n   */\n  public signature: string;\n  /**\n   * The signature of the method, including the owning class.\n   * e.g. bar/Baz/foo(IJ)V\n   */\n  public fullSignature: string = null;\n  public method: methods.Method = null;\n  public paramWordSize: number = -1;\n  public jsConstructor: any = null;\n  constructor(classInfo: ClassReference, nameAndTypeInfo: NameAndTypeInfo) {\n    this.classInfo = classInfo;\n    this.nameAndTypeInfo = nameAndTypeInfo;\n    this.signature = this.nameAndTypeInfo.name + this.nameAndTypeInfo.descriptor;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.INTERFACE_METHODREF;\n  }\n\n  /**\n   * Checks the method referenced by this constant pool item in the specified\n   * bytecode context.\n   * Returns null if an error occurs.\n   * - Throws a NoSuchFieldError if missing.\n   * - Throws an IllegalAccessError if field is inaccessible.\n   * - Throws an IncompatibleClassChangeError if the field is an incorrect type\n   *   for the field access.\n   */\n  public hasAccess(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, isStatic: boolean): boolean {\n    var method = this.method, accessingCls = frame.method.cls;\n    if (method.accessFlags.isStatic() !== isStatic) {\n      thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', `Method ${method.name} from class ${method.cls.getExternalName()} is ${isStatic ? 'not ' : ''}static.`);\n      frame.returnToThreadLoop = true;\n      return false;\n    } else if (!util.checkAccess(accessingCls, method.cls, method.accessFlags)) {\n      thread.throwNewException('Ljava/lang/IllegalAccessError;', `${accessingCls.getExternalName()} cannot access ${method.cls.getExternalName()}.${method.name}`);\n      frame.returnToThreadLoop = true;\n      return false;\n    }\n    return true;\n  }\n\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit: boolean = true) {\n    if (!this.classInfo.isResolved()) {\n      this.classInfo.resolve(thread, loader, caller, (status: boolean) => {\n        if (!status) {\n          cb(false);\n        } else {\n          this.resolve(thread, loader, caller, cb, explicit);\n        }\n      }, explicit);\n    } else {\n      var cls = this.classInfo.cls,\n        method = cls.methodLookup(this.signature);\n      this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n      if (method !== null) {\n        this.setResolved(thread, method);\n        cb(true);\n      } else {\n        thread.throwNewException('Ljava/lang/NoSuchMethodError;', `Method ${this.signature} does not exist in class ${this.classInfo.cls.getExternalName()}.`);\n        cb(false);\n      }\n    }\n  }\n\n  public setResolved(thread: threading.JVMThread, method: methods.Method): void {\n    this.method = method;\n    this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n    this.fullSignature = this.method.fullSignature;\n    this.jsConstructor = this.method.cls.getConstructor(thread);\n  }\n\n  public getParamWordSize(): number {\n    if (this.paramWordSize === -1) {\n      this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n    }\n    return this.paramWordSize;\n  }\n\n  public isResolved() { return this.method !== null; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var classIndex = byteStream.getUint16(),\n      nameAndTypeIndex = byteStream.getUint16(),\n      classInfo = <ClassReference> constantPool.get(classIndex),\n      nameAndTypeInfo = <NameAndTypeInfo> constantPool.get(nameAndTypeIndex);\n    assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&\n      nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE,\n      'ConstantPool InterfaceMethodReference types mismatch');\n    return new this(classInfo, nameAndTypeInfo);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.INTERFACE_METHODREF] = InterfaceMethodReference;\n\n/**\n * Represents a particular field.\n * ```\n * CONSTANT_Fieldref_info {\n *   u1 tag;\n *   u2 class_index;\n *   u2 name_and_type_index;\n * }\n * ```\n */\nexport class FieldReference implements IConstantPoolItem {\n  public classInfo: ClassReference;\n  public nameAndTypeInfo: NameAndTypeInfo;\n  public field: methods.Field = null;\n  /**\n   * The full name of the field, including the owning class.\n   * e.g. java/lang/String/value\n   */\n  public fullFieldName: string = null;\n  /**\n   * The constructor for the field owner. Used for static fields.\n   */\n  public fieldOwnerConstructor: any = null;\n  constructor(classInfo: ClassReference, nameAndTypeInfo: NameAndTypeInfo) {\n    this.classInfo = classInfo;\n    this.nameAndTypeInfo = nameAndTypeInfo;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.FIELDREF;\n  }\n\n  /**\n   * Checks the field referenced by this constant pool item in the specified\n   * bytecode context.\n   * Returns null if an error occurs.\n   * - Throws a NoSuchFieldError if missing.\n   * - Throws an IllegalAccessError if field is inaccessible.\n   * - Throws an IncompatibleClassChangeError if the field is an incorrect type\n   *   for the field access.\n   */\n  public hasAccess(thread: threading.JVMThread, frame: threading.BytecodeStackFrame, isStatic: boolean): boolean {\n    var field = this.field, accessingCls = frame.method.cls;\n    if (field.accessFlags.isStatic() !== isStatic) {\n      thread.throwNewException('Ljava/lang/IncompatibleClassChangeError;', `Field ${name} from class ${field.cls.getExternalName()} is ${isStatic ? 'not ' : ''}static.`);\n      frame.returnToThreadLoop = true;\n      return false;\n    } else if (!util.checkAccess(accessingCls, field.cls, field.accessFlags)) {\n      thread.throwNewException('Ljava/lang/IllegalAccessError;', `${accessingCls.getExternalName()} cannot access ${field.cls.getExternalName()}.${name}`);\n      frame.returnToThreadLoop = true;\n      return false;\n    }\n    return true;\n  }\n\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit: boolean = true) {\n    if (!this.classInfo.isResolved()) {\n      this.classInfo.resolve(thread, loader, caller, (status: boolean) => {\n        if (!status) {\n          cb(false);\n        } else {\n          this.resolve(thread, loader, caller, cb, explicit);\n        }\n      }, explicit);\n    } else {\n      var cls = this.classInfo.cls,\n        field = cls.fieldLookup(this.nameAndTypeInfo.name);\n      if (field !== null) {\n        this.fullFieldName = `${util.descriptor2typestr(field.cls.getInternalName())}/${field.name}`;\n        this.field = field;\n        cb(true);\n      } else {\n        thread.throwNewException('Ljava/lang/NoSuchFieldError;', `Field ${this.nameAndTypeInfo.name} does not exist in class ${this.classInfo.cls.getExternalName()}.`);\n        cb(false);\n      }\n    }\n  }\n\n  public isResolved() { return this.field !== null; }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var classIndex = byteStream.getUint16(),\n      nameAndTypeIndex = byteStream.getUint16(),\n      classInfo = <ClassReference> constantPool.get(classIndex),\n      nameAndTypeInfo = <NameAndTypeInfo> constantPool.get(nameAndTypeIndex);\n    assert(classInfo.getType() === enums.ConstantPoolItemType.CLASS &&\n      nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE,\n      'ConstantPool FieldReference types mismatch');\n    return new this(classInfo, nameAndTypeInfo);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.FIELDREF] = FieldReference;\n\n/**\n * Used by an invokedynamic instruction to specify a bootstrap method,\n * the dynamic invocation name, the argument and return types of the call,\n * and optionally, a sequence of additional constants called static arguments\n * to the bootstrap method.\n * ```\n * CONSTANT_InvokeDynamic_info {\n *   u1 tag;\n *   u2 bootstrap_method_attr_index;\n *   u2 name_and_type_index;\n * }\n * ```\n */\nexport class InvokeDynamic implements IConstantPoolItem {\n  public bootstrapMethodAttrIndex: number;\n  public nameAndTypeInfo: NameAndTypeInfo;\n  /**\n   * The parameter word size of the nameAndTypeInfo's descriptor.\n   * Does not take appendix into account; this is the static paramWordSize.\n   */\n  public paramWordSize: number;\n  /**\n   * Once a CallSite is defined for a particular lexical occurrence of\n   * InvokeDynamic, the CallSite will be reused for each future execution\n   * of that particular occurrence.\n   *\n   * We store the CallSite objects here for future retrieval, along with an\n   * optional 'appendix' argument.\n   */\n  private callSiteObjects: { [pc: number]: [JVMTypes.java_lang_invoke_MemberName, JVMTypes.java_lang_Object] } = {};\n  /**\n   * A MethodType object corresponding to this InvokeDynamic call's\n   * method descriptor.\n   */\n  private methodType: JVMTypes.java_lang_invoke_MethodType = null;\n\n  constructor(bootstrapMethodAttrIndex: number, nameAndTypeInfo: NameAndTypeInfo) {\n    this.bootstrapMethodAttrIndex = bootstrapMethodAttrIndex;\n    this.nameAndTypeInfo = nameAndTypeInfo;\n    this.paramWordSize = util.getMethodDescriptorWordSize(this.nameAndTypeInfo.descriptor);\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.INVOKE_DYNAMIC;\n  }\n  public isResolved(): boolean { return this.methodType !== null; }\n  public resolve(thread: threading.JVMThread, loader: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void) {\n    util.createMethodType(thread, loader, this.nameAndTypeInfo.descriptor, (e: JVMTypes.java_lang_Throwable, rv: JVMTypes.java_lang_invoke_MethodType) => {\n      if (e) {\n        thread.throwException(e);\n        cb(false);\n      } else {\n        this.methodType = rv;\n        cb(true);\n      }\n    });\n  }\n\n  public getCallSiteObject(pc: number): [JVMTypes.java_lang_invoke_MemberName, JVMTypes.java_lang_Object] {\n    var cso = this.callSiteObjects[pc]\n    if (cso) {\n      return cso;\n    } else {\n      return null;\n    }\n  }\n\n  public constructCallSiteObject(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, clazz: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, pc: number, cb: (status: boolean) => void, explicit: boolean = true): void {\n    /**\n     * A call site specifier gives a symbolic reference to a method handle which\n     * is to serve as the bootstrap method for a dynamic call site (§4.7.23).\n     * The method handle is resolved to obtain a reference to an instance of\n     * java.lang.invoke.MethodHandle (§5.4.3.5).\n     */\n    var bootstrapMethod = clazz.getBootstrapMethod(this.bootstrapMethodAttrIndex),\n      unresolvedItems: IConstantPoolItem[] = bootstrapMethod[1].concat(bootstrapMethod[0], this).filter((item: IConstantPoolItem) => !item.isResolved());\n\n    if (unresolvedItems.length > 0) {\n      // Resolve all needed constant pool items (including this one).\n      return util.asyncForEach(unresolvedItems, (cpItem: IConstantPoolItem, nextItem: (err?: any) => void) => {\n        cpItem.resolve(thread, cl, clazz, (status: boolean) => {\n          if (!status) {\n            nextItem(\"Failed.\");\n          } else {\n            nextItem();\n          }\n        }, explicit);\n      }, (err?: any) => {\n        if (err) {\n          cb(false);\n        } else {\n          // Rerun. This time, all items are resolved.\n          this.constructCallSiteObject(thread, cl, clazz, pc, cb, explicit);\n        }\n      });\n    }\n\n    /**\n     * A call site specifier gives zero or more static arguments, which\n     * communicate application-specific metadata to the bootstrap method. Any\n     * static arguments which are symbolic references to classes, method\n     * handles, or method types are resolved, as if by invocation of the ldc\n     * instruction (§ldc), to obtain references to Class objects,\n     * java.lang.invoke.MethodHandle objects, and java.lang.invoke.MethodType\n     * objects respectively. Any static arguments that are string literals are\n     * used to obtain references to String objects.\n     */\n    function getArguments(): JVMTypes.JVMArray<JVMTypes.java_lang_Object> {\n      var cpItems = bootstrapMethod[1],\n        i: number, cpItem: IConstantPoolItem,\n        rvObj = new ((<ClassData.ArrayClassData<JVMTypes.java_lang_Object>> thread.getBsCl().getInitializedClass(thread, '[Ljava/lang/Object;')).getConstructor(thread))(thread, cpItems.length),\n        rv = rvObj.array;\n      for (i = 0; i < cpItems.length; i++) {\n        cpItem = cpItems[i];\n        switch (cpItem.getType()) {\n          case enums.ConstantPoolItemType.CLASS:\n            rv[i] = (<ClassReference> cpItem).cls.getClassObject(thread);\n            break;\n          case enums.ConstantPoolItemType.METHOD_HANDLE:\n            rv[i] = (<MethodHandle> cpItem).methodHandle;\n            break;\n          case enums.ConstantPoolItemType.METHOD_TYPE:\n            rv[i] = (<MethodType> cpItem).methodType;\n            break;\n          case enums.ConstantPoolItemType.STRING:\n            rv[i] = (<ConstString> cpItem).value;\n            break;\n          case enums.ConstantPoolItemType.UTF8:\n            rv[i] = thread.getJVM().internString((<ConstUTF8> cpItem).value);\n            break;\n          case enums.ConstantPoolItemType.INTEGER:\n            rv[i] = (<ClassData.PrimitiveClassData> cl.getInitializedClass(thread, 'I')).createWrapperObject(thread, (<ConstInt32> cpItem).value);\n            break;\n          case enums.ConstantPoolItemType.LONG:\n            rv[i] = (<ClassData.PrimitiveClassData> cl.getInitializedClass(thread, 'J')).createWrapperObject(thread, (<ConstLong> cpItem).value);\n            break;\n          case enums.ConstantPoolItemType.FLOAT:\n            rv[i] = (<ClassData.PrimitiveClassData> cl.getInitializedClass(thread, 'F')).createWrapperObject(thread, (<ConstFloat> cpItem).value);\n            break;\n          case enums.ConstantPoolItemType.DOUBLE:\n            rv[i] = (<ClassData.PrimitiveClassData> cl.getInitializedClass(thread, 'D')).createWrapperObject(thread, (<ConstDouble> cpItem).value);\n            break;\n          default:\n            assert(false, \"Invalid CPItem for static args: \" + enums.ConstantPoolItemType[cpItem.getType()]);\n            break;\n        }\n      }\n      assert((() => {\n        var status = true;\n        cpItems.forEach((cpItem: IConstantPoolItem, i: number) => {\n          if (rv[i] === undefined) {\n            console.log(\"Undefined item at arg \" + i + \": \" + enums.ConstantPoolItemType[cpItem.getType()]);\n            status = false;\n          } else if (rv[i] === null) {\n            console.log(\"Null item at arg \" + i + \": \" + enums.ConstantPoolItemType[cpItem.getType()]);\n            status = false;\n          }\n        });\n        return status;\n      })(), \"Arguments cannot be undefined or null.\");\n\n      return rvObj;\n    }\n\n    /**\n     * A call site specifier gives a method descriptor, TD. A reference to an\n     * instance of java.lang.invoke.MethodType is obtained as if by resolution\n     * of a symbolic reference to a method type with the same parameter and\n     * return types as TD (§5.4.3.5).\n     *\n     * Do what all OpenJDK-based JVMs do: Call\n     * MethodHandleNatives.linkCallSite with:\n     * - The class w/ the invokedynamic instruction\n     * - The bootstrap method\n     * - The name string from the nameAndTypeInfo\n     * - The methodType object from the nameAndTypeInfo\n     * - The static arguments from the bootstrap method.\n     * - A 1-length appendix box.\n     */\n    var methodName = thread.getJVM().internString(this.nameAndTypeInfo.name),\n      appendixArr = new ((<ClassData.ArrayClassData<JVMTypes.java_lang_Object>> cl.getInitializedClass(thread, '[Ljava/lang/Object;')).getConstructor(thread))(thread, 1),\n      staticArgs = getArguments(),\n      mhn = <typeof JVMTypes.java_lang_invoke_MethodHandleNatives> (<ClassData.ReferenceClassData<JVMTypes.java_lang_invoke_MethodHandleNatives>> cl.getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;')).getConstructor(thread);\n\n\n    mhn['java/lang/invoke/MethodHandleNatives/linkCallSite(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/invoke/MemberName;'](thread,\n      [clazz.getClassObject(thread), bootstrapMethod[0].methodHandle, methodName, this.methodType, staticArgs, appendixArr], (e?: JVMTypes.java_lang_Throwable, rv?: JVMTypes.java_lang_invoke_MemberName) => {\n      if (e) {\n        thread.throwException(e);\n        cb(false);\n      } else {\n        this.setResolved(pc, [rv, appendixArr.array[0]]);\n        cb(true);\n      }\n    });\n  }\n\n  private setResolved(pc: number, cso: [JVMTypes.java_lang_invoke_MemberName, JVMTypes.java_lang_Object]) {\n    // Prevent resolution races. It's OK to create multiple CSOs, but only one\n    // should ever be used!\n    if (this.callSiteObjects[pc] === undefined) {\n      this.callSiteObjects[pc] = cso;\n    }\n  }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 4;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var bootstrapMethodAttrIndex = byteStream.getUint16(),\n      nameAndTypeIndex = byteStream.getUint16(),\n      nameAndTypeInfo = <NameAndTypeInfo> constantPool.get(nameAndTypeIndex);\n    assert(nameAndTypeInfo.getType() === enums.ConstantPoolItemType.NAME_AND_TYPE,\n      'ConstantPool InvokeDynamic types mismatch');\n    return new this(bootstrapMethodAttrIndex, nameAndTypeInfo);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.INVOKE_DYNAMIC] = InvokeDynamic;\n\n// #endregion\n\n// #region Tier 3\n\nexport interface IConstantPoolReference extends IConstantPoolItem {\n  classInfo: ClassReference;\n  nameAndTypeInfo: NameAndTypeInfo;\n  getMethodHandleType(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, cb: (e: any, type: JVMTypes.java_lang_Object) => void): void;\n}\n\n/**\n * Represents a given method handle.\n * ```\n * CONSTANT_MethodHandle_info {\n *   u1 tag;\n *   u1 reference_kind;\n *   u2 reference_index;\n * }\n * ```\n */\nexport class MethodHandle implements IConstantPoolItem {\n  private reference: FieldReference | MethodReference | InterfaceMethodReference;\n  private referenceType: enums.MethodHandleReferenceKind;\n  /**\n   * The resolved MethodHandle object.\n   */\n  public methodHandle: JVMTypes.java_lang_invoke_MethodHandle = null;\n  constructor(reference: FieldReference | MethodReference | InterfaceMethodReference, referenceType: enums.MethodHandleReferenceKind) {\n    this.reference = reference;\n    this.referenceType = referenceType;\n  }\n\n  public getType(): enums.ConstantPoolItemType {\n    return enums.ConstantPoolItemType.METHOD_HANDLE;\n  }\n  public isResolved(): boolean { return this.methodHandle !== null; }\n  public getConstant(thread: threading.JVMThread) { return this.methodHandle; }\n\n  /**\n   * Asynchronously constructs a JVM-visible MethodHandle object for this\n   * MethodHandle.\n   *\n   * Requires producing the following, and passing it to a MethodHandle\n   * constructor:\n   * * [java.lang.Class] The defining class.\n   * * [java.lang.String] The name of the field/method/etc.\n   * * [java.lang.invoke.MethodType | java.lang.Class] The type of the field OR,\n   *   if a method, the type of the method descriptor.\n   *\n   * If needed, this function will resolve needed classes.\n   */\n  public resolve(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, caller: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>, cb: (status: boolean) => void, explicit: boolean) {\n    if (!this.reference.isResolved()) {\n      return this.reference.resolve(thread, cl, caller, (status: boolean) => {\n        if (!status) {\n          cb(false);\n        } else {\n          this.resolve(thread, cl, caller, cb, explicit);\n        }\n      }, explicit);\n    }\n\n    this.constructMethodHandleType(thread, cl, (type: JVMTypes.java_lang_Object) => {\n      if (type === null) {\n        cb(false);\n      } else {\n        var methodHandleNatives = <typeof JVMTypes.java_lang_invoke_MethodHandleNatives> (<ClassData.ReferenceClassData<JVMTypes.java_lang_invoke_MethodHandleNatives>> cl.getInitializedClass(thread, 'Ljava/lang/invoke/MethodHandleNatives;')).getConstructor(thread);\n        methodHandleNatives['linkMethodHandleConstant(Ljava/lang/Class;ILjava/lang/Class;Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;'](\n          thread,\n          [caller.getClassObject(thread), this.referenceType, this.getDefiningClassObj(thread), thread.getJVM().internString(this.reference.nameAndTypeInfo.name), type], (e?: JVMTypes.java_lang_Throwable, methodHandle?: JVMTypes.java_lang_invoke_MethodHandle) => {\n          if (e) {\n            thread.throwException(e);\n            cb(false);\n          } else {\n            this.methodHandle = methodHandle;\n            cb(true);\n          }\n        });\n      }\n    });\n  }\n\n  private getDefiningClassObj(thread: threading.JVMThread): JVMTypes.java_lang_Class {\n    if (this.reference.getType() === enums.ConstantPoolItemType.FIELDREF) {\n      return (<FieldReference> this.reference).field.cls.getClassObject(thread);\n    } else {\n      return (<MethodReference> this.reference).method.cls.getClassObject(thread);\n    }\n  }\n\n  private constructMethodHandleType(thread: threading.JVMThread, cl: ClassLoader.ClassLoader, cb: (type: JVMTypes.java_lang_Object) => void): void {\n    if (this.reference.getType() === enums.ConstantPoolItemType.FIELDREF) {\n      var resolveObj: string = this.reference.nameAndTypeInfo.descriptor;\n      cl.resolveClass(thread, resolveObj, (cdata: ClassData.ReferenceClassData<JVMTypes.java_lang_Object>) => {\n        if (cdata !== null) {\n          cb(cdata.getClassObject(thread));\n        } else {\n          cb(null);\n        }\n      });\n    } else {\n      util.createMethodType(thread, cl, this.reference.nameAndTypeInfo.descriptor, (e: JVMTypes.java_lang_Throwable, rv: JVMTypes.java_lang_invoke_MethodType) => {\n        if (e) {\n          thread.throwException(e);\n          cb(null);\n        } else {\n          cb(rv);\n        }\n      });\n    }\n  }\n\n  public static size: number = 1;\n  public static infoByteSize: number = 3;\n  public static fromBytes(byteStream: ByteStream, constantPool: ConstantPool): IConstantPoolItem {\n    var referenceKind: enums.MethodHandleReferenceKind = byteStream.getUint8(),\n      referenceIndex = byteStream.getUint16(),\n      reference: FieldReference | MethodReference | InterfaceMethodReference = <any> constantPool.get(referenceIndex);\n\n    assert(0 < referenceKind && referenceKind < 10,\n      'ConstantPool MethodHandle invalid referenceKind: ' + referenceKind);\n    // Sanity check.\n    assert((() => {\n      switch (referenceKind) {\n        case enums.MethodHandleReferenceKind.GETFIELD:\n        case enums.MethodHandleReferenceKind.GETSTATIC:\n        case enums.MethodHandleReferenceKind.PUTFIELD:\n        case enums.MethodHandleReferenceKind.PUTSTATIC:\n          return reference.getType() === enums.ConstantPoolItemType.FIELDREF;\n        case enums.MethodHandleReferenceKind.INVOKEINTERFACE:\n          return reference.getType() === enums.ConstantPoolItemType.INTERFACE_METHODREF\n            && (<MethodReference>reference).nameAndTypeInfo.name[0] !== '<';\n        case enums.MethodHandleReferenceKind.INVOKEVIRTUAL:\n        case enums.MethodHandleReferenceKind.INVOKESTATIC:\n        case enums.MethodHandleReferenceKind.INVOKESPECIAL:\n          // NOTE: Spec says METHODREF, but I've found instances where\n          // INVOKESPECIAL is used on an INTERFACE_METHODREF.\n          return (reference.getType() === enums.ConstantPoolItemType.METHODREF\n            || reference.getType() === enums.ConstantPoolItemType.INTERFACE_METHODREF)\n            && (<MethodReference>reference).nameAndTypeInfo.name[0] !== '<';\n        case enums.MethodHandleReferenceKind.NEWINVOKESPECIAL:\n          return reference.getType() === enums.ConstantPoolItemType.METHODREF\n            && (<MethodReference>reference).nameAndTypeInfo.name === '<init>';\n      }\n      return true;\n    })(), \"Invalid constant pool reference for method handle reference type: \" + enums.MethodHandleReferenceKind[referenceKind]);\n\n    return new this(reference, referenceKind);\n  }\n}\nCP_CLASSES[enums.ConstantPoolItemType.METHOD_HANDLE] = MethodHandle;\n\n// #endregion\n\n/**\n * Constant pool type *resolution tiers*. Value is the tier, key is the\n * constant pool type.\n * Tier 0 has no references to other constant pool items, and can be resolved\n * first.\n * Tier 1 refers to tier 0 items.\n * Tier n refers to tier n-1 items and below.\n * Initialized in the given fashion to give the JS engine a tasty type hint.\n */\nvar CONSTANT_POOL_TIER: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n// Populate CONSTANT_POOL_TIER. Put into a closure to avoid scope pollution.\n((tierInfos: enums.ConstantPoolItemType[][]) => {\n  tierInfos.forEach((tierInfo: enums.ConstantPoolItemType[], index: number) => {\n    tierInfo.forEach((type: enums.ConstantPoolItemType) => {\n      CONSTANT_POOL_TIER[type] = index;\n    });\n  });\n})([\n    // Tier 0\n    [\n      enums.ConstantPoolItemType.UTF8,\n      enums.ConstantPoolItemType.INTEGER,\n      enums.ConstantPoolItemType.FLOAT,\n      enums.ConstantPoolItemType.LONG,\n      enums.ConstantPoolItemType.DOUBLE\n    ],\n    // Tier 1\n    [\n      enums.ConstantPoolItemType.CLASS,\n      enums.ConstantPoolItemType.STRING,\n      enums.ConstantPoolItemType.NAME_AND_TYPE,\n      enums.ConstantPoolItemType.METHOD_TYPE\n    ],\n    // Tier 2\n    [\n      enums.ConstantPoolItemType.FIELDREF,\n      enums.ConstantPoolItemType.METHODREF,\n      enums.ConstantPoolItemType.INTERFACE_METHODREF,\n      enums.ConstantPoolItemType.INVOKE_DYNAMIC\n    ],\n    // Tier 3\n    [\n      enums.ConstantPoolItemType.METHOD_HANDLE\n    ]\n  ]);\n\n/**\n * Represents a constant pool for a particular class.\n */\nexport class ConstantPool {\n  /**\n   * The core constant pool array. Note that some indices are undefined.\n   */\n  private constantPool: IConstantPoolItem[];\n\n  public parse(byteStream: ByteStream, cpPatches: JVMTypes.JVMArray<JVMTypes.java_lang_Object> = null): ByteStream {\n    var cpCount = byteStream.getUint16(),\n      // First key is the tier.\n      deferredQueue: { offset: number; index: number }[][] = [[], [], []],\n      // The ending offset of the constant pool items.\n      endIdx = 0, idx = 1,\n      // Tag of the currently-being-processed item.\n      tag = 0,\n      // Offset of the currently-being-processed item.\n      itemOffset = 0,\n      // Tier of the currently-being-processed item.\n      itemTier = 0;\n    this.constantPool = new Array<IConstantPoolItem>(cpCount);\n\n    // Scan for tier info.\n    while (idx < cpCount) {\n      itemOffset = byteStream.pos();\n      tag = byteStream.getUint8();\n      assert(CP_CLASSES[tag] !== null && CP_CLASSES[tag] !== undefined,\n        'Unknown ConstantPool tag: ' + tag);\n      itemTier = CONSTANT_POOL_TIER[tag];\n      if (itemTier > 0) {\n        deferredQueue[itemTier - 1].push({ offset: itemOffset, index: idx });\n        byteStream.skip(CP_CLASSES[tag].infoByteSize);\n      } else {\n        this.constantPool[idx] = CP_CLASSES[tag].fromBytes(byteStream, this);\n      }\n      idx += CP_CLASSES[tag].size;\n    }\n    endIdx = byteStream.pos();\n\n    // Process tiers.\n    deferredQueue.forEach((deferredItems: { offset: number; index: number; }[]) => {\n      deferredItems.forEach((item: { offset: number; index: number; }) => {\n        byteStream.seek(item.offset);\n        tag = byteStream.getUint8();\n        this.constantPool[item.index] = CP_CLASSES[tag].fromBytes(byteStream, this);\n        if (cpPatches !== null && cpPatches.array[item.index] !== null && cpPatches.array[item.index] !== undefined) {\n          /*\n           * For each CP entry, the corresponding CP patch must either be null or have\n           * the format that matches its tag:\n           *\n           * * Integer, Long, Float, Double: the corresponding wrapper object type from java.lang\n           * * Utf8: a string (must have suitable syntax if used as signature or name)\n           * * Class: any java.lang.Class object\n           * * String: any object (not just a java.lang.String)\n           * * InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments\n           */\n          var patchObj: JVMTypes.java_lang_Object = cpPatches.array[item.index];\n          switch (patchObj.getClass().getInternalName()) {\n            case 'Ljava/lang/Integer;':\n              assert(tag === enums.ConstantPoolItemType.INTEGER);\n              (<ConstInt32> this.constantPool[item.index]).value = (<JVMTypes.java_lang_Integer> patchObj)['java/lang/Integer/value'];\n              break;\n            case 'Ljava/lang/Long;':\n              assert(tag === enums.ConstantPoolItemType.LONG);\n              (<ConstLong> this.constantPool[item.index]).value = (<JVMTypes.java_lang_Long> patchObj)['java/lang/Long/value'];\n              break;\n            case 'Ljava/lang/Float;':\n              assert(tag === enums.ConstantPoolItemType.FLOAT);\n              (<ConstFloat> this.constantPool[item.index]).value = (<JVMTypes.java_lang_Float> patchObj)['java/lang/Float/value'];\n              break;\n            case 'Ljava/lang/Double;':\n              assert(tag === enums.ConstantPoolItemType.DOUBLE);\n              (<ConstDouble> this.constantPool[item.index]).value = (<JVMTypes.java_lang_Double> patchObj)['java/lang/Double/value'];\n              break;\n            case 'Ljava/lang/String;':\n              assert(tag === enums.ConstantPoolItemType.UTF8);\n              (<ConstUTF8> this.constantPool[item.index]).value = (<JVMTypes.java_lang_String> patchObj).toString();\n              break;\n            case 'Ljava/lang/Class;':\n              assert(tag === enums.ConstantPoolItemType.CLASS);\n              (<ClassReference> this.constantPool[item.index]).name = (<JVMTypes.java_lang_Class> patchObj).$cls.getInternalName();\n              (<ClassReference> this.constantPool[item.index]).cls = <ClassData.ReferenceClassData<JVMTypes.java_lang_Object>> (<JVMTypes.java_lang_Class> patchObj).$cls;\n              break;\n            default:\n              assert(tag === enums.ConstantPoolItemType.STRING);\n              (<ConstString> this.constantPool[item.index]).stringValue = \"\";\n              // XXX: Not actually a string, but the JVM does this.\n              (<ConstString> this.constantPool[item.index]).value = <JVMTypes.java_lang_String> patchObj;\n              break;\n          }\n        }\n      });\n    });\n\n    // Return to the correct offset, at the end of the CP data.\n    byteStream.seek(endIdx);\n    return byteStream;\n  }\n\n  public get(idx: number): IConstantPoolItem {\n    assert(this.constantPool[idx] !== undefined, \"Invalid ConstantPool reference.\");\n    return this.constantPool[idx];\n  }\n\n  public each(fn: (idx: number, item: IConstantPoolItem) => void): void {\n    this.constantPool.forEach((item: IConstantPoolItem, idx: number) => {\n      if (item !== undefined) {\n        fn(idx, item);\n      }\n    });\n  }\n}\n\n/// Resolved forms of constant pool items.\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ConstantPool.ts\n **/","import threading = require('./threading');\nimport ClassData = require('./ClassData');\n\n/**\n * A single class lock, used for load/initialization locks.\n */\nclass ClassLock {\n  private queue: { thread: threading.JVMThread; cb: (cdata: ClassData.ClassData) => void; }[] = [];\n\n  /**\n   * Checks if the lock is taken. If so, it enqueues the callback. Otherwise,\n   * it takes the lock and returns true.\n   */\n  public tryLock(thread: threading.JVMThread, cb: (cdata: ClassData.ClassData) => void): boolean {\n    // We're the owner if the queue was previously empty.\n    return this.queue.push({ thread: thread, cb: cb }) === 1;\n  }\n\n  /**\n   * Releases the lock on the class, and passes the object to all enqueued\n   * callbacks.\n   */\n  public unlock(cdata: ClassData.ClassData): void {\n    var i: number, num = this.queue.length;\n    for (i = 0; i < num; i++) {\n      this.queue[i].cb(cdata);\n    }\n    this.queue = [];\n  }\n\n  /**\n   * Get the owner of this lock.\n   */\n  public getOwner(): threading.JVMThread {\n    if (this.queue.length > 0) {\n      return this.queue[0].thread;\n    }\n    return null;\n  }\n}\n\nexport = ClassLock;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ClassLock.ts\n **/","import threading = require('./threading');\nimport enums = require('./enums');\nimport assert = require('./assert');\n\n/**\n * Represents a JVM monitor.\n */\nclass Monitor {\n  /**\n   * The owner of the monitor.\n   */\n  private owner: threading.JVMThread = null;\n  /**\n   * Number of times that the current owner has locked this monitor.\n   */\n  private count: number = 0;\n  /**\n   * JVM threads that are waiting for the current owner to relinquish the\n   * monitor.\n   */\n  private blocked: {\n    [threadRef: number]: {\n      /**\n       * The blocked thread.\n       */\n      thread: threading.JVMThread;\n      /**\n       * A callback that should be triggered once the thread becomes the\n       * owner of the monitor.\n       */\n      cb: () => void;\n      /**\n       * The lock count to restore once the thread owns the lock.\n       */\n      count: number;\n    }\n  } = {};\n  /**\n   * Queue of JVM threads that are waiting for a JVM thread to notify them.\n   */\n  private waiting: {\n    [threadRef: number]: {\n      /**\n       * The blocked thread.\n       */\n      thread: threading.JVMThread;\n      /**\n       * A callback that should be triggered once the thread owns the monitor.\n       */\n      cb: (fromTimer: boolean) => void;\n      /**\n       * The thread's lock count at the time it invoked Object.wait.\n       */\n      count: number;\n      /**\n       * True if the thread issued waiting with a timeout.\n       */\n      isTimed: boolean;\n      /**\n       * The timer ID for the timeout callback, if isTimed is true. Allows us\n       * to revoke timeout timers before they execute.\n       */\n      timer?: number;\n    }\n  } = {};\n\n  /**\n   * Attempts to acquire the monitor.\n   *\n   * Thread transitions:\n   * * RUNNABLE => BLOCKED [If fails to acquire lock]\n   *\n   * @param thread The thread that is trying to acquire the monitor.\n   * @param cb If this method returns false, then this callback will be\n   *   triggered once the thread becomes owner of the monitor. At that time,\n   *   the thread will be in the RUNNABLE state.\n   * @return True if successfull, false if not. If not successful, the thread\n   *   becomes BLOCKED, and the input callback will be triggered once the\n   *   thread owns the monitor and is RUNNABLE.\n   */\n  public enter(thread: threading.JVMThread, cb: () => void): boolean {\n    if (this.owner === thread) {\n      this.count++;\n      return true;\n    } else {\n      return this.contendForLock(thread, 1, enums.ThreadStatus.BLOCKED, cb);\n    }\n  }\n\n  /**\n   * Generic version of Monitor.enter for contending for the lock.\n   *\n   * Thread transitions:\n   * * RUNNABLE => UNINTERRUPTIBLY_BLOCKED [If fails to acquire lock]\n   * * RUNNABLE => BLOCKED [If fails to acquire lock]\n   *\n   * @param thread The thread contending for the lock.\n   * @param count The lock count to use once the thread owns the lock.\n   * @param blockStatus The ThreadStatus to use should the thread need to\n   *   contend for the lock (either BLOCKED or UNINTERRUPTIBLY_BLOCKED).\n   * @param cb The callback to call once the thread becomes owner of the lock.\n   * @return True if the thread immediately acquired the lock, false if the\n   *   thread is now blocked on the lock.\n   */\n  private contendForLock(thread: threading.JVMThread, count: number, blockStatus: enums.ThreadStatus, cb: () => void): boolean {\n    var owner = this.owner;\n    assert(owner != thread, \"Thread attempting to contend for lock it already owns!\");\n    if (owner === null) {\n      assert(this.count === 0);\n      this.owner = thread;\n      this.count = count;\n      return true;\n    } else {\n      /**\n       * \"If another thread already owns the monitor associated with objectref,\n       *  the thread blocks until the monitor's entry count is zero, then tries\n       *  again to gain ownership.\"\n       * @from http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter\n       */\n      this.blocked[thread.getRef()] = { thread: thread, cb: cb, count: count };\n      thread.setStatus(blockStatus, this);\n      return false;\n    }\n  }\n\n  /**\n   * Exits the monitor. Handles notifying the waiting threads if the lock\n   * becomes available.\n   *\n   * Thread transitions:\n   * * *NONE* on the argument thread.\n   * * A *BLOCKED* thread may be scheduled if the owner gives up the monitor.\n   *\n   * @param thread The thread that is exiting the monitor.\n   * @return True if exit succeeded, false if an exception occurred.\n   */\n  public exit(thread: threading.JVMThread): boolean {\n    var owner = this.owner;\n    if (owner === thread) {\n      if (--this.count === 0) {\n        this.owner = null;\n        this.appointNewOwner();\n      }\n    } else {\n      /**\n       * \"If the thread that executes monitorexit is not the owner of the\n       *  monitor associated with the instance referenced by objectref,\n       *  monitorexit throws an IllegalMonitorStateException.\"\n       * @from http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorexit\n       */\n      thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', \"Cannot exit a monitor that you do not own.\");\n    }\n    return owner === thread;\n  }\n\n  /**\n   * Chooses one of the blocked threads to become the monitor's owner.\n   */\n  private appointNewOwner() {\n    var blockedThreadRefs = Object.keys(this.blocked);\n    if (blockedThreadRefs.length > 0) {\n      // Unblock a random thread.\n      var unblockedRef = blockedThreadRefs[Math.floor(Math.random() * blockedThreadRefs.length)],\n        // XXX: Typing hack. Key must be a number.\n        unblocked = this.blocked[<number><any>unblockedRef];\n      this.unblock(unblocked.thread, false);\n    }\n  }\n\n  /**\n   * \"Causes the current thread to wait until another thread invokes the\n   *  notify() method or the notifyAll() method for this object, or some other\n   *  thread interrupts the current thread, or a certain amount of real time\n   *  has elapsed.\n   *\n   *  This method causes the current thread (call it T) to place itself in the\n   *  wait set for this object and then to relinquish any and all\n   *  synchronization claims on this object.\"\n   *\n   * We coalesce all possible wait configurations into this one function.\n   * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait(long, int)\n   * @param thread The thread that wants to wait on this monitor.\n   * @param cb The callback triggered once the thread wakes up.\n   * @param timeoutMs? An optional timeout that specifies how long the thread\n   *   should wait, in milliseconds. If this value is 0, then we ignore it.\n   * @param timeoutNs? An optional timeout that specifies how long the thread\n   *   should wait, in nanosecond precision (currently ignored).\n   * @todo Use high-precision timers in browsers that support it.\n   * @return True if the wait succeeded, false if it triggered an exception.\n   */\n  public wait(thread: threading.JVMThread, cb: (fromTimer: boolean) => void, timeoutMs?: number, timeoutNs?: number): boolean {\n    if (this.getOwner() === thread) {\n      // INVARIANT: Thread shouldn't currently be blocked on a monitor.\n      assert(thread.getStatus() !== enums.ThreadStatus.BLOCKED);\n      this.waiting[thread.getRef()] = {\n        thread: thread,\n        cb: cb,\n        count: this.count,\n        isTimed: timeoutMs != null && timeoutMs !== 0\n      };\n\n      // Revoke ownership.\n      this.owner = null;\n      this.count = 0;\n\n      if (timeoutMs != null && timeoutMs !== 0) {\n        // Scheduler a timer that wakes up the thread.\n        // XXX: Casting to 'number', since NodeJS typings specify a Timer.\n        this.waiting[thread.getRef()].timer = <number><any> setTimeout(() => {\n          this.unwait(thread, true);\n        }, timeoutMs);\n        thread.setStatus(enums.ThreadStatus.TIMED_WAITING, this);\n      } else {\n        thread.setStatus(enums.ThreadStatus.WAITING, this);\n      }\n\n      // Select a new owner.\n      this.appointNewOwner();\n      return true;\n    } else {\n      /**\n       * \"The current thread must own this object's monitor\"\n       */\n      thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', \"Cannot wait on an object that you do not own.\");\n      return false;\n    }\n  }\n\n  /**\n   * Removes the specified thread from the waiting set, and makes it compete\n   * for the monitor lock. Once it acquires the lock, we restore its lock\n   * count prior to triggering the wait callback.\n   *\n   * If the thread is interrupted, the wait callback is *not* triggered.\n   *\n   * @param thread The thread to remove.\n   * @param fromTimer Indicates if this function call was triggered from a\n   *   timer event.\n   * @param [interrupting] If true, then we are *interrupting* the wait. Do not\n   *   trigger the wait callback.\n   * @param [unwaitCb] If interrupting is true, then this callback is triggered\n   *   once the thread reacquires the lock.\n   */\n  public unwait(thread: threading.JVMThread, fromTimer: boolean, interrupting: boolean = false, unwaitCb: () => void = null): void {\n    // Step 1: Remove the thread from the waiting set.\n    var waitEntry = this.waiting[thread.getRef()],\n      // Interrupting a previously-waiting thread before it acquires a lock\n      // makes no semantic sense, as the thread is currently suspended in a\n      // synchronized block that requires ownership of the monitor.\n      blockStatus = enums.ThreadStatus.UNINTERRUPTABLY_BLOCKED,\n      blockCb = () => {\n        // Thread is RUNNABLE before we trigger the callback.\n        thread.setStatus(enums.ThreadStatus.RUNNABLE);\n        if (interrupting) {\n          unwaitCb();\n        } else {\n          waitEntry.cb(fromTimer);\n        }\n      };\n    assert(waitEntry != null);\n    delete this.waiting[thread.getRef()];\n    // Step 2: Remove the timer if the timer did not trigger this event.\n    if (thread.getStatus() === enums.ThreadStatus.TIMED_WAITING && !fromTimer) {\n      var timerId = waitEntry.timer;\n      assert(timerId != null);\n      clearTimeout(timerId);\n    }\n\n    // Step 3: Acquire the monitor [ASYNC]\n    if (this.contendForLock(thread, waitEntry.count, blockStatus, blockCb)) {\n      // Success! Trigger the blockCb anyway. If 'contendForLock' returns false,\n      // it will trigger blockCb once the thread acquires the lock.\n      blockCb();\n    }\n  }\n\n  /**\n   * Removes the specified thread from being blocked on the monitor so it can\n   * re-compete for ownership.\n   * @param [interrupting] If true, we are interrupting the monitor block. The\n   *   thread should not acquire the lock, and the block callback should not\n   *   be triggered.\n   */\n  public unblock(thread: threading.JVMThread, interrupting: boolean = false): void {\n    var blockEntry = this.blocked[thread.getRef()];\n    // Cannot interrupt an uninterruptibly blocked thread.\n    assert(interrupting ? thread.getStatus() === enums.ThreadStatus.BLOCKED : true);\n    if (blockEntry != null) {\n      delete this.blocked[thread.getRef()];\n      thread.setStatus(enums.ThreadStatus.RUNNABLE);\n      if (!interrupting) {\n        // No one else can own the monitor.\n        assert(this.owner == null && this.count === 0, \"T\" + thread.getRef() + \": We're not interrupting a block, but someone else owns the monitor?! Owned by \" + (this.owner == null ? \"[no one]\" : \"\" + this.owner.getRef()) + \" Count: \" + this.count);\n        // Assign this thread as the monitor owner.\n        this.owner = thread;\n        this.count = blockEntry.count;\n        // Trigger the callback.\n        blockEntry.cb();\n      }\n    }\n  }\n\n  /**\n   * Notifies a single waiting thread.\n   * @param thread The notifying thread. *MUST* be the owner.\n   */\n  public notify(thread: threading.JVMThread): void {\n    if (this.owner === thread) {\n      var waitingRefs = Object.keys(this.waiting);\n      if (waitingRefs.length > 0) {\n        // Notify a random thread.\n        this.unwait(this.waiting[<number><any>waitingRefs[Math.floor(Math.random() * waitingRefs.length)]].thread, false);\n      }\n    } else {\n      /**\n       * \"Throws IllegalMonitorStateException if the current thread is not the\n       *  owner of this object's monitor.\"\n       * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notify()\n       */\n      thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', \"Cannot notify on a monitor that you do not own.\");\n    }\n  }\n\n  /**\n   * Notifies all waiting threads.\n   * @param thread The notifying thread. *MUST* be the owner.\n   */\n  public notifyAll(thread: threading.JVMThread): void {\n    if (this.owner === thread) {\n      var waitingRefs = Object.keys(this.waiting), i: number;\n      // Notify each thread.\n      for (i = 0; i < waitingRefs.length; i++) {\n        this.unwait(this.waiting[<number><any>waitingRefs[i]].thread, false);\n      }\n    } else {\n      /**\n       * \"Throws IllegalMonitorStateException if the current thread is not the\n       *  owner of this object's monitor.\"\n       * @from http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#notifyAll()\n       */\n      thread.throwNewException('Ljava/lang/IllegalMonitorStateException;', \"Cannot notifyAll on a monitor that you do not own.\");\n    }\n  }\n\n  /**\n   * @return The owner of the monitor.\n   */\n  public getOwner(): threading.JVMThread {\n    return this.owner;\n  }\n\n  public isWaiting(thread: threading.JVMThread): boolean {\n    // Waiting, but *not* timed waiting.\n    return this.waiting[thread.getRef()] != null && !this.waiting[thread.getRef()].isTimed;\n  }\n\n  public isTimedWaiting(thread: threading.JVMThread): boolean {\n    // Timed waiting, *not* waiting.\n    return this.waiting[thread.getRef()] != null && this.waiting[thread.getRef()].isTimed;\n  }\n\n  public isBlocked(thread: threading.JVMThread): boolean {\n    // Blocked.\n    return this.blocked[thread.getRef()] != null;\n  }\n}\n\nexport = Monitor;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/Monitor.ts\n **/","import {TriState} from './enums';\nimport assert = require('./assert');\nimport fs = require('fs');\nimport BrowserFS = require('browserfs');\nconst bfsPath = BrowserFS.BFSRequire('path');\nimport nodePath = require('path');\nimport util = require('./util');\n// Type information only.\nimport TBFSFS from 'browserfs/dist/node/core/FS';\n// Export so it can be returned from ClasspathJar.\nexport type TZipFS = BrowserFS.FileSystem.ZipFS;\nlet BFSFS = BrowserFS.BFSRequire('fs');\nlet ZipFS = BrowserFS.FileSystem.ZipFS;\nexport type MetaIndex = {[pkgName: string]: boolean | MetaIndex};\n\n/**\n * Represents an item on the classpath. Used by the bootstrap classloader.\n */\nexport interface IClasspathItem {\n  /**\n   * Initializes this item on the classpath. Asynchronous, as the classpath\n   * item needs to populate its classlist.\n   */\n  initialize(cb: () => void): void;\n  /**\n   * Returns true if this classpath item has the given class.\n   * Reference types only.\n   * NOTE: Loading of said class is not guaranteed to succeed.\n   * @param type Class name in pkg/path/Name format.\n   * @returns True if it has the class, false if not, indeterminate if it\n   *   cannot be determined synchronously.\n   */\n  hasClass(type: string): TriState;\n  /**\n   * Attempt to load the given class synchronously. Returns a buffer,\n   * or returns NULL if unsuccessful.\n   * @param type Class name in pkg/path/Name format.\n   */\n  tryLoadClassSync(type: string): Buffer;\n  /**\n   * Load a class with the given type (e.g. Ljava/lang/String;).\n   * @param type Class name in pkg/path/Name format.\n   */\n  loadClass(type: string, cb: (err: Error, data?: Buffer) => void): void;\n  /**\n   * Get the path to this classpath item.\n   */\n  getPath(): string;\n  /**\n   * Stat a particular resource in the classpath.\n   */\n  statResource(p: string, cb: (e: Error, stat?: fs.Stats) => void): void\n  /**\n   * Read the given directory within the classpath item.\n   */\n  readdir(p: string, cb: (e: Error, list?: string[]) => void): void;\n  /**\n   * Tries to perform a readdir synchronously. Returns null if unsuccessful.\n   */\n  tryReaddirSync(p: string): string[];\n  /**\n   * Tries to perform a stat operation synchronously. Returns null if unsuccessful.\n   */\n  tryStatSync(p: string): fs.Stats;\n}\n\nfunction win2nix(p: string): string {\n  return p.replace(/\\\\/g, '/');\n}\n\n/**\n * Represents a JAR file on the classpath.\n */\nexport abstract class AbstractClasspathJar {\n  protected _fs = new BFSFS.FS();\n  /**\n   * Was the JAR file successfully read?\n   * - TRUE: JAR file is read and mounted in this._fs.\n   * - FALSE: JAR file could not be read.\n   * - INDETERMINATE: We have yet to try reading this JAR file.\n   */\n  protected _jarRead = TriState.INDETERMINATE;\n  protected _path: string;\n  constructor(path: string) {\n    this._path = path;\n  }\n\n  public getPath(): string { return this._path; }\n\n  public loadJar(cb: (e?: Error) => void): void {\n    if (this._jarRead !== TriState.TRUE) {\n      fs.readFile(this._path, (e, data) => {\n        if (e) {\n          this._jarRead = TriState.FALSE;\n          cb(e);\n        } else {\n          try {\n            ZipFS.computeIndex(data, (index) => {\n              try {\n                this._fs.initialize(new ZipFS(index, bfsPath.basename(this._path)));\n                this._jarRead = TriState.TRUE;\n                cb();\n              } catch (e) {\n                this._jarRead = TriState.FALSE;\n                cb(e);\n              }\n            });\n          } catch (e) {\n            this._jarRead = TriState.FALSE;\n            cb(e);\n          }\n        }\n      });\n    } else {\n      setImmediate(() => cb(this._jarRead === TriState.TRUE ? null : new Error(\"Failed to load JAR file.\")));\n    }\n  }\n\n  public abstract hasClass(type: string): TriState;\n\n  public tryLoadClassSync(type: string): Buffer {\n    if (this._jarRead === TriState.TRUE) {\n      if (this.hasClass(type) !== TriState.FALSE) {\n        try {\n          // NOTE: Path must be absolute, otherwise BrowserFS\n          // will try to use process.cwd().\n          return this._fs.readFileSync(`/${type}.class`);\n        } catch (e) {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else {\n      // Must go the async route.\n      return null;\n    }\n  }\n\n  /**\n   * Wrap an operation that depends on the jar being loaded.\n   */\n  private _wrapOp(op: () => void, failCb: (e: Error) => void): void {\n    switch (this._jarRead) {\n      case TriState.TRUE:\n        op();\n        break;\n      case TriState.FALSE:\n        setImmediate(() => failCb(new Error(\"Unable to load JAR file.\")));\n        break;\n      default:\n        this.loadJar(() => {\n          this._wrapOp(op, failCb);\n        });\n        break;\n    }\n  }\n\n  /**\n   * Wrap a synchronous operation that depends on the jar being loaded.\n   * Returns null if the jar isn't loaded, or if the operation fails.\n   */\n  private _wrapSyncOp<T>(op: () => T): T {\n    if (this._jarRead === TriState.TRUE) {\n      try {\n        return op();\n      } catch (e) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  public loadClass(type: string, cb: (err: Error, data?: Buffer) => void): void {\n    this._wrapOp(() => {\n      // Path must be absolute to avoid relative path issues.\n      this._fs.readFile(`/${type}.class`, cb);\n    }, cb);\n  }\n\n  public statResource(p: string, cb: (err: Error, stats?: fs.Stats) => void): void {\n    this._wrapOp(() => {\n      this._fs.stat(p, cb);\n    }, cb);\n  }\n\n  public readdir(p: string, cb: (e: Error, list?: string[]) => void): void {\n    this._wrapOp(() => {\n      this._fs.readdir(win2nix(p), cb);\n    }, cb);\n  }\n\n  public tryReaddirSync(p: string): string[] {\n    return this._wrapSyncOp<string[]>(() => {\n      return this._fs.readdirSync(win2nix(p));\n    });\n  }\n\n  public tryStatSync(p: string): fs.Stats {\n    return this._wrapSyncOp<fs.Stats>(() => {\n      return this._fs.statSync(win2nix(p));\n    });\n  }\n\n  public getFS(): TZipFS {\n    return <TZipFS> this._fs.getRootFS();\n  }\n}\n\n/**\n * A JAR item on the classpath that is not in the meta index.\n */\nexport class UnindexedClasspathJar extends AbstractClasspathJar implements IClasspathItem {\n  // Contains the list of classes accessible from this classpath item.\n  private _classList: {[className: string]: boolean} = null;\n\n  constructor(p: string) {\n    super(p);\n  }\n\n  public hasClass(type: string): TriState {\n    if (this._jarRead === TriState.FALSE) {\n      return TriState.FALSE;\n    } else {\n      return this._hasClass(type);\n    }\n  }\n\n  public _hasClass(type: string): TriState {\n    if (this._classList) {\n      return this._classList[type] ? TriState.TRUE : TriState.FALSE;\n    }\n    return TriState.INDETERMINATE;\n  }\n\n  /**\n   * Initialize this item on the classpath with the given classlist.\n   * @param classes List of classes in pkg/path/Name format.\n   */\n  public initializeWithClasslist(classes: string[]): void {\n    assert(this._classList === null, `Initializing a classpath item twice!`);\n    this._classList = {};\n    let len = classes.length;\n    for (let i = 0; i < len; i++) {\n      this._classList[classes[i]] = true;\n    }\n  }\n\n  public initialize(cb: (e?: Error) => void): void {\n    this.loadJar((err) => {\n      if (err) {\n        cb();\n      } else {\n        let pathStack: string[] = ['/'];\n        let classlist: string[] = [];\n        let fs = this._fs;\n        while (pathStack.length > 0) {\n          let p = pathStack.pop();\n          try {\n            let stat = fs.statSync(p);\n            if (stat.isDirectory()) {\n              let listing = fs.readdirSync(p);\n              for (let i = 0; i < listing.length; i++) {\n                pathStack.push(bfsPath.join(p, listing[i]));\n              }\n            } else if (bfsPath.extname(p) === '.class') {\n              // Cut off initial / from absolute path.\n              classlist.push(p.slice(1, p.length - 6));\n            }\n          } catch (e) {\n            // Ignore filesystem error and proceed.\n          }\n        }\n        this.initializeWithClasslist(classlist);\n        cb();\n      }\n    });\n  }\n}\n\n/**\n * A JAR file on the classpath that is in the meta-index.\n */\nexport class IndexedClasspathJar extends AbstractClasspathJar implements IClasspathItem {\n  private _metaIndex: MetaIndex;\n  private _metaName: string;\n\n  constructor(metaIndex: MetaIndex, p: string) {\n    super(p);\n    this._metaIndex = metaIndex;\n    this._metaName = bfsPath.basename(p);\n  }\n\n  public initialize(cb: (e?: Error) => void): void {\n    setImmediate(() => cb());\n  }\n\n  public hasClass(type: string): TriState {\n    if (this._jarRead === TriState.FALSE) {\n      return TriState.FALSE;\n    } else {\n      let pkgComponents = type.split('/');\n      let search: MetaIndex = this._metaIndex;\n      // Pop off class name.\n      pkgComponents.pop();\n      for (let i = 0; i < pkgComponents.length; i++) {\n        let item = search[pkgComponents[i]];\n        if (!item) {\n          // item === undefined or false.\n          return TriState.FALSE;\n        } else if (item === true) {\n          return TriState.INDETERMINATE;\n        } else {\n          // Must be an object.\n          search = <any> item;\n        }\n      }\n      // Assume meta-index is complete.\n      return TriState.FALSE;\n    }\n  }\n}\n\n/**\n * Represents a folder on the classpath.\n */\nexport class ClasspathFolder implements IClasspathItem {\n  private _path: string;\n  constructor(path: string) {\n    this._path = path;\n  }\n\n  public getPath(): string { return this._path; }\n\n  public hasClass(type: string): TriState {\n    return TriState.INDETERMINATE;\n  }\n\n  public initialize(cb: (e?: Error) => void): void {\n    // NOP.\n    setImmediate(cb);\n  }\n\n  public tryLoadClassSync(type: string): Buffer {\n    try {\n      return fs.readFileSync(nodePath.resolve(this._path, `${type}.class`));\n    } catch (e) {\n      return null;\n    }\n  }\n\n  public loadClass(type: string, cb: (err: Error, data?: Buffer) => void): void {\n    fs.readFile(nodePath.resolve(this._path, `${type}.class`), cb);\n  }\n\n  public statResource(p: string, cb: (err: Error, stats?: fs.Stats) => void): void {\n    fs.stat(nodePath.resolve(this._path, p), cb);\n  }\n\n  public readdir(p: string, cb: (e: Error, list?: string[]) => void): void {\n    fs.readdir(nodePath.resolve(this._path, p), cb);\n  }\n\n  public tryReaddirSync(p: string): string[] {\n    try {\n      return fs.readdirSync(nodePath.resolve(this._path, p));\n    } catch (e) {\n      return null;\n    }\n  }\n\n  public tryStatSync(p: string): fs.Stats {\n    try {\n      return fs.statSync(nodePath.resolve(this._path, p));\n    } catch (e) {\n      return null;\n    }\n  }\n}\n\n/**\n * Represents a classpath item that cannot be found.\n */\nexport class ClasspathNotFound implements IClasspathItem {\n  private _path: string;\n  constructor(path: string) {\n    this._path = path;\n  }\n\n  public getPath(): string { return this._path; }\n\n  public hasClass(type: string): TriState { return TriState.FALSE; }\n\n  public initialize(cb: (e?: Error) => void): void { setImmediate(cb); }\n\n  public initializeWithClasslist(classlist: string[]): void {}\n\n  public tryLoadClassSync(type: string): Buffer { return null; }\n\n  private _notFoundError(cb: (err: Error) => void): void { setImmediate(() => cb(new Error(\"Class cannot be found.\"))); }\n\n  public loadClass(type: string, cb: (err: Error, data?: Buffer) => void): void { this._notFoundError(cb); }\n\n  public statResource(p: string, cb: (err: Error, stats?: fs.Stats) => void): void { this._notFoundError(cb); }\n\n  public readdir(p: string, cb: (e: Error, list?: string[]) => void): void { this._notFoundError(cb); }\n\n  public tryReaddirSync(p: string): string[] { return null; }\n\n  public tryStatSync(p: string): fs.Stats { return null; }\n}\n\n/**\n * Parse the meta index into a lookup table from package name (with slashes) to JAR file.\n * Returns a tuple of JAR files in the meta index and the meta index.\n */\nfunction parseMetaIndex(metaIndex: string): {[jarFile: string]: MetaIndex} {\n  let lines = metaIndex.split(\"\\n\");\n  let rv: {[jarFile: string]: MetaIndex} = {};\n  let currentJar: MetaIndex = null;\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i];\n    if (line.length > 0) {\n      switch (line[0]) {\n        case '%':\n        case '@':\n          // Comment or resource-only JAR file.\n          continue;\n        case '!':\n        case '#':\n          // JAR file w/ classes.\n          // Skip symbol and space.\n          let jarName = line.slice(2);\n          rv[jarName] = currentJar = {};\n          break;\n        default:\n          // Package name. If it ends with /, then it's shared\n          // amongst multiple JAR files.\n          // We don't treat those separately, though, so standardize it.\n          if (line[line.length - 1] === '/') {\n            line = line.slice(0, line.length - 1);\n          }\n          let pkgComponents = line.split('/');\n          let current = currentJar;\n          let i: number;\n          for (i = 0; i < pkgComponents.length - 1; i++) {\n            let cmp = pkgComponents[i],\n              next = current[cmp];\n            if (!next) {\n              current = current[cmp] = {};\n            } else {\n              // Invariant: You can't list a package and its subpackages\n              // for same jar file. Thus, current[cmp] cannot be a boolean.\n              current = <any> current[cmp];\n            }\n          }\n          current[pkgComponents[i]] = true;\n          break;\n      }\n    }\n  }\n  return rv;\n}\n\n/**\n * Given a list of paths (which may or may not exist), produces a list of\n * classpath objects.\n */\nexport function ClasspathFactory(javaHomePath: string, paths: string[], cb: (items: IClasspathItem[]) => void): void {\n  let classpathItems: IClasspathItem[] = new Array<IClasspathItem>(paths.length),\n    i: number = 0;\n\n  fs.readFile(nodePath.join(javaHomePath, 'lib', 'meta-index'), (err, data) => {\n    let metaIndex: {[jarName: string]: MetaIndex} = {};\n    if (!err) {\n      metaIndex = parseMetaIndex(data.toString());\n    }\n    util.asyncForEach(paths, (p, nextItem) => {\n      let pRelToHome = nodePath.relative(`${javaHomePath}/lib`, p);\n      fs.stat(p, (err, stats) => {\n        let cpItem: IClasspathItem;\n        if (err) {\n          cpItem = new ClasspathNotFound(p);\n        } else if (stats.isDirectory()) {\n          cpItem = new ClasspathFolder(p);\n        } else {\n          if (metaIndex[pRelToHome]) {\n            cpItem = new IndexedClasspathJar(metaIndex[pRelToHome], p);\n          } else {\n            cpItem = new UnindexedClasspathJar(p);\n          }\n        }\n        classpathItems[i++] = cpItem;\n        cpItem.initialize(nextItem);\n      });\n    }, (e?) => {\n      cb(classpathItems);\n    });\n  })\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/classpath.ts\n **/","var BrowserFS = require('browserfs');module.exports=BrowserFS.BFSRequire('fs');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./shims/fs.js\n ** module id = 27\n ** module chunks = 0\n **/","var BrowserFS = require('browserfs');module.exports=BrowserFS.BFSRequire('path');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./shims/path.js\n ** module id = 28\n ** module chunks = 0\n **/","var BrowserFS = require('browserfs');module.exports=BrowserFS.BFSRequire('buffer');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./shims/buffer.js\n ** module id = 29\n ** module chunks = 0\n **/","// A power-of-two segregated freelist \"heap\",\n// for explicit memory management into a buffer.\n// by Emery Berger, www.cs.umass.edu/~emery\n\n\"use strict\";\n\ninterface HashTable<T> {\n  [key : number]: T;\n}\n\nclass Heap {\n\n  // size = total amount of memory for the heap.\n  constructor(private size: number) {\n    this._buffer    = new Buffer(size);\n    this._remaining = size;  // the whole thing is available.\n    this._offset    = 0;     // start of the buffer.\n    // Initialize the freelists.\n    this._freeLists = new Array<Array<number>>(Heap._numSizeClasses);\n    for (var i = 0; i < Heap._numSizeClasses; i++) {\n      this._freeLists[i] = [];\n    }\n  }\n\n  // Allocate size bytes, returning the \"address\".\n  malloc(size: number): number {\n    // if size is less than a word, round it up to a word (4 bytes).\n    if (size <= 4) {\n      size = 4;\n    }\n    // if we are out of memory, throw an exception.\n    if (this._remaining < size) {\n      // TODO: could actually scan larger freelists to see if there's\n      // free memory there.\n      throw \"out of memory\";\n    }\n    // compute the size class.\n    var addr : number;\n    var cl   : number;\n    cl   = Heap.size_to_class(size);\n    addr = this._freeLists[cl].pop();\n    // if there's no more memory, get some.\n    if (addr === undefined) {\n      addr = this.refill(cl);\n    }\n    return addr;\n  }\n\n  // Deallocate memory.\n  free(addr: number): void {\n    // push this address onto the appropriate freelist.\n    // first, mask the address.\n    var masked = addr & ~(Heap._chunkSize - 1);\n    // next, look up the class using the masked address.\n    var cl = this._sizeMap[masked];\n    // finally, push onto the appropriate free list.\n    // TODO: for sanity, we could check to see if this was *really* freed\n    // and drop it if not.\n    this._freeLists[cl].push(addr);\n  }\n\n  // Store a word (32-bits) at this address.\n  store_word(addr: number, value: number): void {\n    // TODO: add sanity checks?\n    this._buffer.writeInt32LE (value, addr);\n  }\n\n  // Access a byte at this location.\n  get_byte(addr: number): number {\n    // TODO: add sanity checks?\n    return this._buffer.readUInt8(addr);\n  }\n\n  get_word(addr: number): number {\n    return this._buffer.readInt32LE(addr);\n  }\n\n  get_buffer(addr: number, len: number): Buffer {\n    return this._buffer.slice(addr, addr + len);\n  }\n\n  get_signed_byte(addr: number): number {\n    return this._buffer.readInt8(addr);\n  }\n\n  set_byte(addr: number, value: number): void {\n    this._buffer.writeUInt8(value, addr);\n  }\n\n  set_signed_byte(addr: number, value: number): void {\n    this._buffer.writeInt8(value, addr);\n  }\n\n  /**\n   * Copy len bytes from srcAddr to dstAddr.\n   */\n  memcpy(srcAddr: number, dstAddr: number, len: number) {\n    this._buffer.copy(this._buffer, dstAddr, srcAddr, srcAddr + len);\n  }\n\n  // Get more memory for a particular size class.\n  private refill(cl: number): number {\n    // Get the largest size for this class.\n    var sz = this.cl_to_size(cl);\n    // Figure out how many objects we are going to \"allocate\".\n    var count : number = Math.floor(Heap._chunkSize / sz);\n    if (count < 1) {\n      count = 1;\n    }\n    // Now store the size class *for the first object* only.\n    // We will later look up this object via \"pointer arithmetic\".\n    var addr = this._offset;\n    this._sizeMap[addr] = cl;\n    // Add each one to the freelist.\n    for (var i = 0; i < count; i++) {\n      this._remaining -= sz;\n      addr = this._offset;\n      this._freeLists[cl].push (addr);\n      this._offset += sz;\n    }\n    return addr;\n  }\n\n  // Computes ceil(log2(num)).\n  private static ilog2(num: number): number {\n    var log2  = 0;\n    var value = 1;\n    while (value < num) {\n      value <<= (1);\n      log2++;\n    }\n    return (log2);\n  }\n\n  // power-of-two size classes (just a ref to ilog2).\n  private static size_to_class(size: number): number {\n    return Heap.ilog2(size);\n  }\n\n  // see above: classes are just powers of two.\n  private cl_to_size(cl: number): number {\n    return (1 << cl);\n  }\n\n  // Holds all memory, which we will allocate from via pointer bumping.\n  private _buffer : NodeBuffer;\n\n  // How much is left in the buffer, in bytes.\n  private _remaining : number;\n\n  // The current offset in the buffer.\n  private _offset : number;\n\n  // The total number of size classes.\n  private static _numSizeClasses : number = 64; // way more than we'll ever need.\n\n  // How much to grab at one time.\n  private static _chunkSize : number = 4096;    // should be a power of two.\n\n  // The size class array of stuff.\n  private _freeLists : Array<Array<number>>;\n\n  // A map of size classes per chunk (see above).\n  private _sizeMap : HashTable<number> = {};\n\n}\n\nexport = Heap;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/heap.ts\n **/","import {ThreadStatus} from './enums';\nimport {JVMThread} from './threading';\nimport assert = require('./assert');\n\n/**\n * Manages parked threads and their callbacks.\n */\nclass Parker {\n  private _parkCounts: { [threadRef: number]: number } = {};\n  private _parkCallbacks: { [threadRef: number]: () => void } = {};\n\n  public park(thread: JVMThread, cb: () => void) {\n    var ref = thread.getRef();\n    assert(!this._parkCallbacks[ref] && thread.getStatus() !== ThreadStatus.PARKED, `Thread ${ref} is doubly parked? Should be impossible.`);\n    this._parkCallbacks[ref] = cb;\n    this._mutateParkCount(thread, 1);\n    // It's possible the thread was instantly unparked due to a previously\n    // unbalancing park.\n    if (this.isParked(thread)) {\n      thread.setStatus(ThreadStatus.PARKED);\n    }\n  }\n\n  public unpark(thread: JVMThread): void {\n    this._mutateParkCount(thread, -1);\n  }\n\n  public completelyUnpark(thread: JVMThread): void {\n    var ref = thread.getRef(), count = this._parkCounts[ref];\n    if (count) {\n      this._mutateParkCount(thread, -count);\n    }\n  }\n\n  private _mutateParkCount(thread: JVMThread, delta: number): void {\n    var ref = thread.getRef(), cb: () => void;\n    // Initialize park count.\n    if (!this._parkCounts[ref]) {\n      this._parkCounts[ref] = 0;\n    }\n    if (0 === (this._parkCounts[ref] += delta)) {\n      assert(!!this._parkCallbacks[ref], `Balancing unpark for thread ${ref} with no callback? Should be impossible.`);\n      cb = this._parkCallbacks[ref];\n\n      // Cleanup.\n      delete this._parkCounts[ref];\n      delete this._parkCallbacks[ref];\n\n      // Avoid situations where a terminated thread's timeout wakes up\n      // and tries to revive its thread.\n      if (thread.getStatus() === ThreadStatus.PARKED) {\n        thread.setStatus(ThreadStatus.ASYNC_WAITING);\n        cb();\n      }\n    }\n  }\n\n  public isParked(thread: JVMThread): boolean {\n    return !!this._parkCounts[thread.getRef()];\n  }\n}\n\nexport = Parker;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/parker.ts\n **/","import {ThreadStatus} from './enums';\nimport assert = require('./assert');\n\n/**\n * Generic interface for a thread.\n */\nexport interface Thread {\n  getStatus(): ThreadStatus;\n  isDaemon(): boolean;\n  getPriority(): number;\n  setStatus(status: ThreadStatus): void;\n  run(): void;\n}\n\n/**\n * Checks if the given thread status indicates that the thread is scheduleable.\n */\nfunction isRunnable(status: ThreadStatus): boolean {\n  return status === ThreadStatus.RUNNABLE;\n}\n\n/**\n * Implements a thread scheduling algorithm\n */\nexport interface Scheduler<T extends Thread> {\n  /**\n   * Schedule the given thread to run.\n   */\n  scheduleThread(thread: T): void;\n  /**\n   * Signal that the given thread's priority has changed.\n   */\n  priorityChange(thread: T): void;\n  /**\n   * Unschedule the given thread to run. It is removed from\n   * the scheduler's queue.\n   */\n  unscheduleThread(thread: T): void;\n  /**\n   * Retrieve the currently running thread. Returns NULL if\n   * no threads are running.\n   */\n  getRunningThread(): T;\n  /**\n   * Called when a thread's quantum is over.\n   */\n  quantumOver(thread: T): void;\n}\n\n/**\n * A Weighted Round Robin thread scheduler.\n */\nclass WeightedRoundRobinScheduler<T extends Thread> implements Scheduler<T> {\n  // Number of quanta given to the current thread.\n  private _count: number = 0;\n  // The queue of threads.\n  private _queue: T[] = [];\n  // Read by runThread. Used as a lock.\n  private _threadScheduled: boolean = false;\n\n  public scheduleThread(thread: T): void {\n    this._queue.push(thread);\n    if (this._queue.length === 1) {\n      // There aren't any threads running. Run this thread.\n      this.runThread();\n    }\n  }\n\n  /**\n   * Run the thread at the head of the queue.\n   */\n  private runThread(): void {\n    if (this._threadScheduled) {\n      return;\n    }\n    this._threadScheduled = true;\n    setImmediate(() => {\n      let queue = this._queue;\n      this._threadScheduled = false;\n      if (queue.length > 0) {\n        let thread = this._queue[0];\n        assert(thread.getStatus() === ThreadStatus.RUNNABLE, `Attempted to run non-runnable thread.`);\n        thread.run();\n      }\n    });\n  }\n\n  public unscheduleThread(thread: T): void {\n    let queue = this._queue;\n    let isRunningThread = queue[0] === thread;\n    assert(queue.indexOf(thread) > -1, `Tried to unschedule thread that was not scheduled.`);\n    // Remove thread from queue.\n    if (isRunningThread) {\n      queue.shift();\n      this._count = 0;\n      // Schedule the next thread.\n      this.runThread();\n    } else {\n      queue.splice(queue.indexOf(thread), 1);\n    }\n  }\n\n  public getRunningThread(): T {\n    let queue = this._queue;\n    if (queue.length > 0) {\n      return queue[0];\n    } else {\n      return null;\n    }\n  }\n\n  public priorityChange(thread: T): void {\n    // Not important for the algorithm. We'll pick up the change\n    // next time we schedule.\n  }\n\n  public quantumOver(thread: T): void {\n    assert(this._queue[0] === thread, `A non-running thread has an expired quantum?`);\n    this._count++;\n    if (this._count >= thread.getPriority() || thread.getStatus() !== ThreadStatus.RUNNABLE) {\n      // Move to back of queue, reset count.\n      this._count = 0;\n      this._queue.push(this._queue.shift());\n    }\n    // Schedule the next thread.\n    this.runThread();\n  }\n}\n\n/**\n * Represents a thread pool. Handles scheduling duties.\n */\nexport default class ThreadPool<T extends Thread> {\n  private threads: T[] = [];\n  private runningThread: T;\n  private scheduler: Scheduler<T> = new WeightedRoundRobinScheduler<T>();\n  /**\n   * Called when the ThreadPool becomes empty. This is usually a sign that\n   * execution has finished.\n   *\n   * If the callback returns true it signals that this threadpool can free its resources.\n   */\n  private emptyCallback: () => boolean;\n\n  constructor(emptyCallback: () => boolean) {\n    this.emptyCallback = emptyCallback;\n  }\n\n  /**\n   * Retrieve all of the threads in the thread pool.\n   */\n  public getThreads(): T[] {\n    // Return a copy of our internal array.\n    return this.threads.slice(0);\n  }\n\n  /**\n   * Checks if any remaining threads are non-daemonic and could be runnable.\n   * If not, we can terminate execution.\n   *\n   * This check is invoked each time a thread terminates.\n   */\n  private anyNonDaemonicThreads(): boolean {\n    for (let i = 0; i < this.threads.length; i++) {\n      let t = this.threads[i];\n      if (t.isDaemon()) {\n        continue;\n      }\n      let status = t.getStatus();\n      if (status !== ThreadStatus.NEW &&\n          status !== ThreadStatus.TERMINATED) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private threadTerminated(thread: T): void {\n    var idx: number = this.threads.indexOf(thread);\n    assert(idx >= 0);\n    // Remove the specified thread from the threadpool.\n    this.threads.splice(idx, 1);\n\n    if (!this.anyNonDaemonicThreads()) {\n      const close = this.emptyCallback();\n      if (close) {\n        this.emptyCallback = null;\n      }\n    }\n  }\n\n  /**\n   * Called when a thread's status changes.\n   */\n  public statusChange(thread: T, oldStatus: ThreadStatus, newStatus: ThreadStatus): void {\n    var wasRunnable  = isRunnable(oldStatus),\n      nowRunnable = isRunnable(newStatus);\n\n    if (oldStatus === ThreadStatus.NEW || oldStatus === ThreadStatus.TERMINATED) {\n      if (this.threads.indexOf(thread) === -1) {\n        this.threads.push(thread);\n      }\n    }\n\n    // Inform scheduling algorithm if thread changes from runnable => unrunnable, or unrunnable => runnable.\n    if (wasRunnable !== nowRunnable) {\n      if (wasRunnable) {\n        this.scheduler.unscheduleThread(thread);\n      } else {\n        this.scheduler.scheduleThread(thread);\n      }\n    }\n\n    if (newStatus === ThreadStatus.TERMINATED) {\n      this.threadTerminated(thread);\n    }\n  }\n\n  /**\n   * Called when a thread's priority changes.\n   */\n  public priorityChange(thread: T): void {\n    this.scheduler.priorityChange(thread);\n  }\n\n  /**\n   * Called when a thread's quantum is over.\n   */\n  public quantumOver(thread: T): void {\n    this.scheduler.quantumOver(thread);\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/threadpool.ts\n **/","module.exports = {\n\t\"url\": \"https://github.com/plasma-umass/doppio_jcl/releases/download/v3.2/java_home.tar.gz\",\n\t\"classpath\": [\n\t\t\"lib/rt.jar\",\n\t\t\"lib/charsets.jar\",\n\t\t\"lib/doppio.jar\",\n\t\t\"lib/dt.jar\",\n\t\t\"lib/jce.jar\",\n\t\t\"lib/jconsole.jar\",\n\t\t\"lib/jsse.jar\",\n\t\t\"lib/management-agent.jar\",\n\t\t\"lib/resources.jar\",\n\t\t\"lib/sa-jdi.jar\",\n\t\t\"lib/tools.jar\"\n\t]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./vendor/java_home/jdk.json\n ** module id = 33\n ** module chunks = 0\n **/","/**\n * The only way I could figure out how to get a handle on Node's 'require'\n * function without confusing webpack. Using a Function constructor doesn't work,\n * as require() isn't in its scope!\n *\n * Isolating in its own module so it doesn't mess up mangling in other modules.\n */\nexport default function getGlobalRequire(): Function {\n  const reqVar = eval('typeof(require)!==\"undefined\"?require:null');\n  return reqVar ? reqVar : function(moduleName: string): any {\n    throw new Error(`Cannot find module ${moduleName}`);\n  };\n}\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/global_require.ts\n **/","'use strict';\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/deflate.js\n ** module id = 35\n ** module chunks = 0\n **/","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/utils/common.js\n ** module id = 36\n ** module chunks = 0\n **/","'use strict';\n\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/trees.js\n ** module id = 37\n ** module chunks = 0\n **/","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/adler32.js\n ** module id = 38\n ** module chunks = 0\n **/","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/crc32.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/messages.js\n ** module id = 40\n ** module chunks = 0\n **/","'use strict';\n\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = zswap32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = { bits: state.distbits };\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/inflate.js\n ** module id = 41\n ** module chunks = 0\n **/","'use strict';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/inffast.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  var i = 0;\n  /* process all codes and make table entries */\n  for (;;) {\n    i++;\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/inftrees.js\n ** module id = 43\n ** module chunks = 0\n **/","'use strict';\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pako/lib/zlib/zstream.js\n ** module id = 44\n ** module chunks = 0\n **/","module.exports = {\n\t\"name\": \"doppiojvm\",\n\t\"version\": \"0.4.2\",\n\t\"engine\": \"node >= 4.0.0\",\n\t\"license\": \"MIT\",\n\t\"main\": \"dist/release/doppio.js\",\n\t\"typings\": \"dist/typings/src/doppiojvm\",\n\t\"dependencies\": {\n\t\t\"async\": \"^2.0.0\",\n\t\t\"browserfs\": \"^0.5.12\",\n\t\t\"glob\": \"^7.0.3\",\n\t\t\"gunzip-maybe\": \"^1.3.1\",\n\t\t\"optimist\": \"~0.6\",\n\t\t\"pako\": \"^1.0.1\",\n\t\t\"rimraf\": \"^2.5.2\",\n\t\t\"source-map-support\": \"^0.4.0\",\n\t\t\"tar-fs\": \"^1.12.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"bfs-buffer\": \"^0.1.7\",\n\t\t\"bfs-path\": \"^0.1.2\",\n\t\t\"bfs-process\": \"^0.1.6\",\n\t\t\"body-parser\": \"^1.15.1\",\n\t\t\"cpr\": \"^2.0.0\",\n\t\t\"detect-browser\": \"^1.3.1\",\n\t\t\"escodegen\": \"^1.8.0\",\n\t\t\"esprima\": \"^2.7.2\",\n\t\t\"estraverse\": \"^4.2.0\",\n\t\t\"express\": \"^4.13.4\",\n\t\t\"grunt\": \"^1.0\",\n\t\t\"grunt-cli\": \"^1.2\",\n\t\t\"grunt-contrib-compress\": \"^1.2.0\",\n\t\t\"grunt-contrib-connect\": \"^1.0\",\n\t\t\"grunt-contrib-copy\": \"^1.0\",\n\t\t\"grunt-contrib-uglify\": \"^2.0\",\n\t\t\"grunt-karma\": \"^2.0\",\n\t\t\"grunt-lineending\": \"^1.0.0\",\n\t\t\"grunt-merge-source-maps\": \"^0.1.0\",\n\t\t\"grunt-newer\": \"^1.2.0\",\n\t\t\"grunt-ts\": \"^5.5\",\n\t\t\"grunt-webpack\": \"^1.0.11\",\n\t\t\"imports-loader\": \"^0.6.5\",\n\t\t\"jasmine-core\": \"^2.3.4\",\n\t\t\"json-loader\": \"^0.5.4\",\n\t\t\"karma\": \"^1.2.0\",\n\t\t\"karma-chrome-launcher\": \"^2.0\",\n\t\t\"karma-firefox-launcher\": \"^1.0\",\n\t\t\"karma-ie-launcher\": \"^1.0\",\n\t\t\"karma-jasmine\": \"^1.0\",\n\t\t\"karma-opera-launcher\": \"^1.0\",\n\t\t\"karma-safari-launcher\": \"^1.0\",\n\t\t\"locate-java-home\": \"^0.1.6\",\n\t\t\"semver\": \"^5.1.0\",\n\t\t\"source-map-loader\": \"^0.1.5\",\n\t\t\"typescript\": \"^1.8.10\",\n\t\t\"uglify-js\": \"^2.7.3\",\n\t\t\"underscore\": \"^1.8.3\",\n\t\t\"webpack\": \"^1.13.1\",\n\t\t\"webpack-dev-server\": \"^1.14.1\"\n\t},\n\t\"scripts\": {\n\t\t\"test\": \"grunt test\",\n\t\t\"prepublish\": \"node ./prepublish.js\",\n\t\t\"install\": \"node ./install.js\",\n\t\t\"appveyor-test\": \"grunt --stack test-browser-appveyor\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"http://github.com/plasma-umass/doppio.git\"\n\t},\n\t\"bin\": {\n\t\t\"doppio\": \"./bin/doppio\",\n\t\t\"doppioh\": \"./bin/doppioh\",\n\t\t\"doppio-dev\": \"./bin/doppio-dev\",\n\t\t\"doppio-fast-dev\": \"./bin/doppio-fast-dev\"\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./package.json\n ** module id = 45\n ** module chunks = 0\n **/","/***\nThis is modified from part of jsdifflib v1.0. <http://snowtide.com/jsdifflib>\n\nCopyright (c) 2007, Snowtide Informatics Systems, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n\t* Redistributions of source code must retain the above copyright notice, this\n\t\tlist of conditions and the following disclaimer.\n\t* Redistributions in binary form must reproduce the above copyright notice,\n\t\tthis list of conditions and the following disclaimer in the documentation\n\t\tand/or other materials provided with the distribution.\n\t* Neither the name of the Snowtide Informatics Systems nor the names of its\n\t\tcontributors may be used to endorse or promote products derived from this\n\t\tsoftware without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\nOF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\nBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n***/\n/* Original author: Chas Emerick <cemerick@snowtide.com> */\nexport function text_diff(a_lines: string[], b_lines: string[], context: number): string[] {\n\treturn (new SequenceMatcher(a_lines, b_lines)).text_diff(context);\n}\n\n// comparison function for sorting lists of numeric tuples\nfunction __ntuplecomp(a: number[], b: number[]) {\n\tvar mlen = Math.max(a.length, b.length);\n\tfor (var i = 0; i < mlen; i++) {\n\t\tif (a[i] < b[i]) return -1;\n\t\tif (a[i] > b[i]) return 1;\n\t}\n\n\treturn a.length == b.length ? 0 : (a.length < b.length ? -1 : 1);\n}\n\n// replacement for python's dict.get function -- need easy default values\nfunction __dictget(dict: any, key: any, defaultValue: any): any {\n\treturn dict.hasOwnProperty(key) ? dict[key] : defaultValue;\n}\n\nexport class SequenceMatcher {\n\tprivate a : string[];\n\tprivate b : string[];\n\tprivate matching_blocks: number[][];\n\tprivate opcodes: any[];\n\tprivate b2j: {[elt: string]: number[]};\n\n\tconstructor(a: string[], b: string[]) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.b2j = {};\n\t\tfor (var i = 0; i < b.length; i++) {\n\t\t\tvar elt = b[i];\n\t\t\tif (this.b2j.hasOwnProperty(elt)) {\n\t\t\t\tthis.b2j[elt].push(i);\n\t\t\t} else {\n\t\t\t\tthis.b2j[elt] = [i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate find_longest_match(alo: number, ahi: number,\n\t\t                       blo: number, bhi: number): [number,number,number] {\n\t\tvar a = this.a;\n\t\tvar b = this.b;\n\t\tvar b2j = this.b2j;\n\t\tvar besti = alo;\n\t\tvar bestj = blo;\n\t\tvar bestsize = 0;\n\n\t\tvar j2len = {};\n\t\tfor (var i = alo; i < ahi; i++) {\n\t\t\tvar newj2len: any = {};\n\t\t\tvar jdict = __dictget(b2j, a[i], []);\n\t\t\tfor (var jkey in jdict) {\n\t\t\t\tif (jdict.hasOwnProperty(jkey)) {\n\t\t\t\t\tvar j = jdict[jkey];\n\t\t\t\t\tif (j < blo) continue;\n\t\t\t\t\tif (j >= bhi) break;\n\t\t\t\t\tvar k = __dictget(j2len, j - 1, 0) + 1\n\t\t\t\t\tnewj2len[j] = k;\n\t\t\t\t\tif (k > bestsize) {\n\t\t\t\t\t\tbesti = i - k + 1;\n\t\t\t\t\t\tbestj = j - k + 1;\n\t\t\t\t\t\tbestsize = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tj2len = newj2len;\n\t\t}\n\n\t\twhile (besti > alo && bestj > blo && a[besti - 1] == b[bestj - 1]) {\n\t\t\tbesti--;\n\t\t\tbestj--;\n\t\t\tbestsize++;\n\t\t}\n\n\t\twhile (besti + bestsize < ahi && bestj + bestsize < bhi &&\n\t\t\t\ta[besti + bestsize] == b[bestj + bestsize]) {\n\t\t\tbestsize++;\n\t\t}\n\n\t\treturn [besti, bestj, bestsize];\n\t}\n\n\tprivate get_matching_blocks(): number[][] {\n\t\tif (this.matching_blocks != null) return this.matching_blocks;\n\t\tvar la = this.a.length;\n\t\tvar lb = this.b.length;\n\n\t\tvar queue = [[0, la, 0, lb]];\n\t\tvar matching_blocks: Array<[number,number,number]> = [];\n\t\twhile (queue.length) {\n\t\t\tvar qi = queue.pop();\n\t\t\tvar alo = qi[0];\n\t\t\tvar ahi = qi[1];\n\t\t\tvar blo = qi[2];\n\t\t\tvar bhi = qi[3];\n\t\t\tvar x = this.find_longest_match(alo, ahi, blo, bhi);\n\t\t\tvar i = x[0];\n\t\t\tvar j = x[1];\n\t\t\tvar k = x[2];\n\n\t\t\tif (k) {\n\t\t\t\tmatching_blocks.push(x);\n\t\t\t\tif (alo < i && blo < j)\n\t\t\t\t\tqueue.push([alo, i, blo, j]);\n\t\t\t\tif (i+k < ahi && j+k < bhi)\n\t\t\t\t\tqueue.push([i + k, ahi, j + k, bhi]);\n\t\t\t}\n\t\t}\n\n\t\tmatching_blocks.sort(__ntuplecomp);\n\n\t\tvar i1 = 0,\n\t\t    j1 = 0,\n\t\t    k1 = 0;\n\t\tvar non_adjacent: Array<[number,number,number]> = [];\n\t\tfor (var idx=0; idx < matching_blocks.length; idx++) {\n\t\t\tvar block = matching_blocks[idx];\n\t\t\tvar i2 = block[0];\n\t\t\tvar j2 = block[1];\n\t\t\tvar k2 = block[2];\n\t\t\tif (i1 + k1 == i2 && j1 + k1 == j2) {\n\t\t\t\tk1 += k2;\n\t\t\t} else {\n\t\t\t\tif (k1) non_adjacent.push([i1, j1, k1]);\n\t\t\t\ti1 = i2;\n\t\t\t\tj1 = j2;\n\t\t\t\tk1 = k2;\n\t\t\t}\n\t\t}\n\n\t\tif (k1) non_adjacent.push([i1, j1, k1]);\n\n\t\tnon_adjacent.push([la, lb, 0]);\n\t\tthis.matching_blocks = non_adjacent;\n\t\treturn this.matching_blocks;\n\t}\n\n\tprivate get_opcodes(): any[] {\n\t\tif (this.opcodes != null) return this.opcodes;\n\t\tvar i = 0;\n\t\tvar j = 0;\n\t\tvar answer: any[] = [];\n\t\tthis.opcodes = answer;\n\t\tvar blocks = this.get_matching_blocks();\n\t\tfor (var idx=0; idx < blocks.length; idx++) {\n\t\t\tvar block = blocks[idx];\n\t\t\tvar ai = block[0];\n\t\t\tvar bj = block[1];\n\t\t\tvar size = block[2];\n\t\t\tvar tag = '';\n\t\t\tif (i < ai && j < bj) {\n\t\t\t\ttag = 'replace';\n\t\t\t} else if (i < ai) {\n\t\t\t\ttag = 'delete';\n\t\t\t} else if (j < bj) {\n\t\t\t\ttag = 'insert';\n\t\t\t}\n\t\t\tif (tag) answer.push([tag, i, ai, j, bj]);\n\t\t\ti = ai + size;\n\t\t\tj = bj + size;\n\n\t\t\tif (size) answer.push(['equal', ai, i, bj, j]);\n\t\t}\n\t\treturn answer;\n\t}\n\n\tpublic text_diff(context: number): string[] {\n\t\tvar opcodes = this.get_opcodes();\n\t\tvar diff: string[] = [];\n\t\tvar a_side: string[] = [];\n\t\tvar b_side: string[] = [];\n\t\tvar a_max_len = 0;\n\t\tvar last_seen = -1;\n\t\tfor (var op_idx=0; op_idx<opcodes.length; op_idx++) {\n\t\t\tvar op = opcodes[op_idx];\n\t\t\tif (op[0] === 'equal') continue;\n\t\t\tvar ai = op[1];\n\t\t\tvar bi = op[3];\n\t\t\tvar aj = op[2]-1;\n\t\t\tvar bj = op[4]-1;\n\t\t\tvar start = Math.min(ai,bi);\n\t\t\tvar end = Math.max(aj,bj);\n\t\t\tvar c = '';\n\t\t\tswitch (op[0]) {\n\t\t\tcase 'delete': c = ' < '; break;\n\t\t\tcase 'insert': c = ' > '; break;\n\t\t\tcase 'replace': c = ' | '; break;\n\t\t\t}\n\t\t\tfor (var i=Math.max(last_seen+1,start-context); i<start; i++) {\n\t\t\t\tvar prefix = i + ': ';\n\t\t\t\tif (i < this.a.length) {\n\t\t\t\t\ta_side.push(prefix + this.a[i]);\n\t\t\t\t\ta_max_len = Math.max(a_max_len, this.a[i].length + prefix.length);\n\t\t\t\t} else {\n\t\t\t\t\ta_side.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (i < this.b.length) {\n\t\t\t\t\tb_side.push(this.b[i]);\n\t\t\t\t} else {\n\t\t\t\t\tb_side.push('');\n\t\t\t\t}\n\t\t\t\tdiff.push('   ');\n\t\t\t}\n\t\t\tfor (var i=start; i<=end; i++) {\n\t\t\t\tvar prefix = i + ': ';\n\t\t\t\tif (i >= ai && i <= aj) {\n\t\t\t\t\ta_side.push(prefix + this.a[i]);\n\t\t\t\t\ta_max_len = Math.max(a_max_len, this.a[i].length + prefix.length);\n\t\t\t\t} else {\n\t\t\t\t\ta_side.push(prefix);\n\t\t\t\t}\n\t\t\t\tif (i >= bi && i <= bj) {\n\t\t\t\t\tb_side.push(this.b[i]);\n\t\t\t\t} else {\n\t\t\t\t\tb_side.push('');\n\t\t\t\t}\n\t\t\t\tdiff.push(c);\n\t\t\t}\n\t\t\tlast_seen = end;\n\t\t}\n\t\tfor (var i=0; i<diff.length; i++) {\n\t\t\tvar a = a_side[i];\n\t\t\tvar b = b_side[i];\n\t\t\tif (a.length < a_max_len)\n\t\t\t\ta += (new Array(a_max_len - a.length + 1)).join(' ');\n\t\t\tdiff[i] = a + diff[i] + b;\n\t\t}\n\t\treturn diff;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/difflib.ts\n **/","/**\n * Top-level Doppio.VM API.\n */\nimport JVM = require('./jvm');\nimport CLI = require('./java_cli');\nimport * as ClassFile from './ClassFile';\nimport * as Threading from './threading';\nimport Long = require('./gLong');\nimport * as Util from './util';\nimport * as Enums from './enums';\nimport * as Interfaces from './interfaces';\nimport Monitor = require('./Monitor');\nimport FDState from './fd_state';\n\nexport {JVM, CLI, ClassFile, Threading, Long, Util, Enums, Interfaces, Monitor, FDState};\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/VM.ts\n **/","import {OptionParser, ParseType, PrefixParseResult} from './option_parser';\nimport JVM = require('./jvm');\nimport util = require('./util');\nimport logging = require('./logging');\nimport {JVMCLIOptions} from './interfaces';\n\ndeclare const RELEASE: boolean;\nlet parser = new OptionParser({\n  default: {\n    classpath: {\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      alias: 'cp',\n      optDesc: ' <class search path of directories and zip/jar files>',\n      desc: 'A : separated list of directories, JAR archives, and ZIP archives to search for class files.',\n    },\n    D: {\n      type: ParseType.MAP_SYNTAX,\n      optDesc: '<name>=<value>',\n      desc: 'set a system property'\n    },\n    jar: {\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      stopParsing: true\n    },\n    help: { alias: '?', desc: 'print this help message' },\n    X: { desc: 'print help on non-standard options' },\n    enableassertions: {\n      type: ParseType.COLON_VALUE_OR_FLAG_SYNTAX,\n      optDesc: '[:<packagename>...|:<classname>]',\n      alias: 'ea',\n      desc: 'enable assertions with specified granularity'\n    },\n    disableassertions: {\n      type: ParseType.COLON_VALUE_OR_FLAG_SYNTAX,\n      optDesc: '[:<packagename>...|:<classname>]',\n      alias: 'da',\n      desc: 'disable assertions with specified granularity'\n    },\n    enablesystemassertions: { alias: 'esa', desc: 'enable system assertions' },\n    disablesystemassertions: { alias: 'dsa', desc: 'disable system assertions '}\n  },\n  X: {\n    'int': {\n      desc: 'interpreted mode execution only'\n    },\n    'dump-JIT-stats': {\n      desc: 'dump JIT statistics',\n      enabled: !RELEASE\n    },\n    log: {\n      desc: 'log level, [0-10]|vtrace|trace|debug|error',\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      enabled: !RELEASE\n    },\n    'vtrace-methods': {\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      optDesc: ' <java/lang/Object/getHashCode()I:...>',\n      desc: 'specify particular methods to vtrace separated by colons',\n      enabled: !RELEASE\n    },\n    'list-class-cache': {\n      desc: 'list all of the bootstrap loaded classes after execution'\n    },\n    'dump-compiled-code': {\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      optDesc: ' <directory>',\n      desc: 'location to dump compiled object definitions',\n      enabled: !RELEASE\n    },\n    // TODO: Use -Djava.library.path\n    'native-classpath': {\n      type: ParseType.NORMAL_VALUE_SYNTAX,\n      optDesc: ' <class search path of directories>',\n      desc: 'A : separated list of directories to search for native mathods in JS files.'\n    },\n    'bootclasspath/a': {\n      type: ParseType.COLON_VALUE_SYNTAX,\n      optDesc: ':<directories and zip/jar files separated by :>',\n      desc: 'append to end of bootstrap class path'\n    },\n    'bootclasspath/p': {\n      type: ParseType.COLON_VALUE_SYNTAX,\n      optDesc: ':<directories and zip/jar files separated by :>',\n      desc: 'prepend in front of bootstrap class path'\n    },\n    'bootclasspath': {\n      type: ParseType.COLON_VALUE_SYNTAX,\n      optDesc: ':<directories and zip/jar files separated by :>',\n      desc: 'set search path for bootstrap classes and resources'\n    },\n    'X:+PrintCompilation': {\n      desc: 'Print JIT compilation details',\n      enabled: !RELEASE\n    }\n  }\n});\n\n/**\n * Consumes a `java` command line string. Constructs a JVM, launches the command, and\n * returns the JVM object. Throws an exception if parsing fails.\n *\n * Returns `null` if no JVM needed to be constructed (e.g. -h flag).\n *\n * @param args Arguments to the 'java' command.\n * @param opts Default options.\n * @param doneCb Called when JVM execution finishes. Passes a\n *   number to the callback indicating the exit value.\n * @param [jvmStarted] Called with the JVM object once we have invoked it.\n */\nfunction java(args: string[], opts: JVMCLIOptions,\n                     doneCb: (status: number) => void,\n                     jvmStarted: (jvm: JVM) => void = function(jvm: JVM): void {}): void {\n  let parsedArgs = parser.parse(args),\n    standard = parsedArgs['default'],\n    nonStandard = parsedArgs['X'],\n    jvmState: JVM;\n\n  // System properties.\n  opts.properties = standard.mapOption('D');\n\n  if (standard.flag('help', false)) {\n    return printHelp(opts.launcherName, parser.help('default'), doneCb, 0);\n  } else if (standard.flag('X', false)) {\n    return printNonStandardHelp(opts.launcherName, parser.help('X'), doneCb, 0);\n  }\n\n  // GLOBAL CONFIGURATION\n  let logOption = nonStandard.stringOption('log', 'ERROR');\n\n  opts.intMode = nonStandard.flag('int', false);\n  opts.dumpJITStats = nonStandard.flag('dump-JIT-stats', false);\n\n  if (/^[0-9]+$/.test(logOption)) {\n    logging.log_level = parseInt(logOption, 10);\n  } else {\n    let level = (<any> logging)[logOption.toUpperCase()];\n    if (level == null) {\n      process.stderr.write(`Unrecognized log level: ${logOption}.`);\n      return printHelp(opts.launcherName, parser.help('default'), doneCb, 1);\n    }\n    logging.log_level = level;\n  }\n\n  if (nonStandard.flag('list-class-cache', false)) {\n    // Redefine done_cb so we print the loaded class files on JVM exit.\n    doneCb = ((old_done_cb: (arg: number) => void): (arg: number) => void => {\n      return (result: number): void => {\n        let fpaths = jvmState.getBootstrapClassLoader().getLoadedClassFiles();\n        process.stdout.write(fpaths.join('\\n') + '\\n');\n        old_done_cb(result);\n      };\n    })(doneCb);\n  }\n\n  if (standard.flag('enablesystemassertions', false)) {\n    opts.enableSystemAssertions = true;\n  }\n\n  if (standard.flag('disablesystemassertions', false)) {\n    opts.enableSystemAssertions = false;\n  }\n\n  if (standard.flag('enableassertions', false)) {\n    opts.enableAssertions = true;\n  } else if (standard.stringOption('enableassertions', null)) {\n    opts.enableAssertions = standard.stringOption('enableassertions', null).split(':');\n  }\n\n  if (standard.stringOption('disableassertions', null)) {\n    opts.disableAssertions = standard.stringOption('disableassertions', null).split(':');\n  }\n  // NOTE: Boolean form of -disableassertions is a NOP.\n\n  // Bootstrap classpath items.\n  let bscl = nonStandard.stringOption('bootclasspath', null);\n  if (bscl !== null) {\n    opts.bootstrapClasspath = bscl.split(':');\n  }\n  let bsClAppend = nonStandard.stringOption('bootclasspath/a', null);\n  if (bsClAppend) {\n    opts.bootstrapClasspath = opts.bootstrapClasspath.concat(bsClAppend.split(':'));\n  }\n  let bsClPrepend = nonStandard.stringOption('bootclasspath/p', null);\n  if (bsClPrepend) {\n    opts.bootstrapClasspath = bsClPrepend.split(':').concat(opts.bootstrapClasspath);\n  }\n\n  // User-supplied classpath items.\n  if (!opts.classpath) {\n    opts.classpath = [];\n  }\n\n  if (standard.stringOption('jar', null)) {\n    opts.classpath.push(standard.stringOption('jar', null));\n  } else if (standard.stringOption('classpath', null)) {\n    opts.classpath = opts.classpath.concat(standard.stringOption('classpath', null).split(':'));\n  } else {\n    // DEFAULT: If no user-supplied classpath, add the current directory to\n    // the class path.\n    opts.classpath.push(process.cwd());\n  }\n\n  // User-supplied native classpath.\n  let nativeClasspath = standard.stringOption('native-classpath', null);\n  if (nativeClasspath) {\n    opts.nativeClasspath = opts.nativeClasspath.concat(nativeClasspath.split(':'));\n  }\n\n  // Construct the JVM.\n  jvmState = new JVM(opts, (err?: any): void => {\n    if (err) {\n      process.stderr.write(\"Error constructing JVM:\\n\");\n      process.stderr.write(err.toString() + \"\\n\");\n      doneCb(1);\n    } else {\n      launchJvm(standard, opts, jvmState, doneCb, jvmStarted);\n    }\n  });\n\n  jvmState.setPrintJITCompilation(nonStandard.flag('X:+PrintCompilation', false));\n\n  let vtraceMethods = nonStandard.stringOption('vtrace-methods', null);\n  if (vtraceMethods) {\n    vtraceMethods.split(':').forEach((m: string) => jvmState.vtraceMethod(m));\n  }\n\n  let dumpCompiledCode = nonStandard.stringOption('dump-compiled-code', null);\n  if (dumpCompiledCode) {\n    jvmState.dumpCompiledCode(dumpCompiledCode);\n  }\n}\n\n/**\n * Consumes a fully-configured JVM, parsed arguments, and a callback.\n * Figures out from this how to launch the JVM (e.g. using a JAR file or a\n * particular class).\n */\nfunction launchJvm(standardOptions: PrefixParseResult, opts: JVMCLIOptions, jvmState: JVM, doneCb: (status: number) => void,\n                    jvmStarted: (jvmState: JVM) => void): void {\n  let mainArgs = standardOptions.unparsedArgs();\n  if (standardOptions.stringOption('jar', null)) {\n    jvmState.runJar(mainArgs, doneCb);\n    jvmStarted(jvmState);\n  } else if (mainArgs.length > 0) {\n    let cname = mainArgs[0];\n    if (cname.slice(-6) === '.class') {\n      cname = cname.slice(0, -6);\n    }\n    if (cname.indexOf('.') !== -1) {\n      // hack: convert java.foo.Bar to java/foo/Bar\n      cname = util.descriptor2typestr(util.int_classname(cname));\n    }\n    jvmState.runClass(cname, mainArgs.slice(1), doneCb);\n    jvmStarted(jvmState);\n  } else {\n    // No class specified, no jar specified!\n    printHelp(opts.launcherName, parser.help('default'), doneCb, 0);\n  }\n}\n\nfunction printHelp(launcherName: string, str: string, doneCb: (arg: number) => void, rv: number): void {\n  process.stdout.write(\n`Usage: ${launcherName} [-options] class [args...]\n        (to execute a class)\nor  ${launcherName} [-options] -jar jarfile [args...]\n        (to execute a jar file)\nwhere options include:\\n${str}`);\n  doneCb(rv);\n}\n\nfunction printNonStandardHelp(launcherName: string, str: string, doneCb: (arg: number) => void, rv: number): void {\n  process.stdout.write(`${str}\\n\\nThe -X options are non-standard and subject to change without notice.\\n`);\n  doneCb(rv);\n}\n\nexport = java;\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/java_cli.ts\n **/","export const enum ParseType {\n  // A simple flag, e.g. -help\n  FLAG,\n  // An option that contains a value specified with colon syntax, e.g.\n  // -ea:myPkg....\n  COLON_VALUE_SYNTAX,\n  // An option that can specified as a flag, or with a value.\n  COLON_VALUE_OR_FLAG_SYNTAX,\n  // An option that contains a value specified in a normal fashion, e.g.\n  // -cp .\n  // These require that a value be set.\n  NORMAL_VALUE_SYNTAX,\n  // An option specified as a map, e.g. the option 'D': -Dkey=value\n  // These can be specified multiple times.\n  MAP_SYNTAX\n}\n\nexport interface Description {\n  [prefix: string]: DescriptionCategory\n}\n\nexport interface DescriptionCategory {\n  [optionName: string]: Option;\n}\n\nexport interface Option {\n  // Describes the option. Used for help text.\n  desc?: string;\n  // Describes how the option should be parsed. Defaults to 'FLAG'.\n  type?: ParseType\n  // For options that take an optional value, an example of the option.\n  // Used for help text.\n  optDesc?: string;\n  // Describes a short alias for the option.\n  alias?: string;\n  // After parsing this option, stop parsing. The remaining arguments\n  // should be passed in raw.\n  stopParsing?: boolean;\n  // If set, determines if the option should be processed and displayed in help text.\n  enabled?: boolean;\n  // [INTERNAL ONLY]\n  prefix?: string;\n  // [INTERNAL ONLY]\n  name?: string;\n}\n\nexport interface RawPrefixParseResult {\n  [optionName: string]: boolean | string | {[name: string]: string}\n}\n\n// Usage.\n\nexport class PrefixParseResult {\n  private _result: RawPrefixParseResult;\n  private _unparsedArgs: string[];\n  constructor(result: RawPrefixParseResult, unparsedArgs: string[] = []) {\n    this._result = result;\n    this._unparsedArgs = unparsedArgs;\n  }\n\n  public unparsedArgs(): string[] {\n    return this._unparsedArgs;\n  }\n\n  public flag(name: string, defaultVal: boolean): boolean {\n    let val = this._result[name];\n    if (typeof(val) === 'boolean') {\n      return <boolean> val;\n    }\n    return defaultVal;\n  }\n\n  public stringOption(name: string, defaultVal: string): string {\n    let val = this._result[name];\n    if (typeof(val) === 'string') {\n      return <string> val;\n    }\n    return defaultVal;\n  }\n\n  public mapOption(name: string): {[name: string]: string} {\n    let val = this._result[name];\n    if (typeof(val) === 'object') {\n      return <{[name: string]: string}> val;\n    }\n    return {};\n  }\n}\n\nexport interface ParseResult {\n  [prefix: string]: PrefixParseResult;\n}\n\nfunction getOptName(prefix: string, name: string): string {\n  return prefix !== 'default' ? `${prefix}${name}` : name\n}\n\n/**\n * Handles parsing for a specific options configuration.\n * Parses Java-style options.\n */\nexport class OptionParser {\n  private _parseMap: {[optName: string]: Option} = {};\n  private _prefixes: string[] = [];\n  private _mapArgs: string[] = [];\n  private _rawDesc: Description;\n\n  constructor(desc: Description) {\n    this._rawDesc = desc;\n    this._prefixes = Object.keys(desc);\n    this._prefixes.forEach((prefix) => {\n      let opts = desc[prefix];\n      let optNames = Object.keys(opts);\n      optNames.slice(0).forEach((optName) => {\n        let option = opts[optName];\n        if (option.enabled === false) {\n          // Ignore disabled options.\n          delete desc[prefix][optName];\n          return;\n        }\n        if (!option.type) {\n          option.type = ParseType.FLAG;\n        }\n        if (option.type === ParseType.MAP_SYNTAX) {\n          // ASSUMPTION: These do not have aliases.\n          this._mapArgs.push(optName);\n        }\n        option.prefix = prefix;\n        option.name = optName;\n        this._parseMap[getOptName(prefix, optName)] = option;\n        if (option.alias) {\n          optNames.push(option.alias);\n          this._parseMap[getOptName(prefix, option.alias)] = option;\n        }\n      });\n    });\n  }\n\n  /**\n   * Parses the given arguments. Throws an exception on parsing failure.\n   */\n  public parse(argv: string[]): ParseResult {\n    let result: {[name: string]: RawPrefixParseResult} = {},\n      ptr: number = 0,\n      len: number;\n\n    this._prefixes.forEach((prefix) => result[prefix] = {});\n\n    argv = argv.map((arg) => arg.trim()).filter((arg) => arg !== '');\n    len = argv.length;\n\n    while (ptr < len) {\n      var arg = argv[ptr];\n      if (arg[0] === '-') {\n        arg = arg.slice(1);\n        var opt: Option;\n        if (opt = this._parseMap[arg]) {\n          switch (opt.type) {\n            case ParseType.FLAG:\n            case ParseType.COLON_VALUE_OR_FLAG_SYNTAX:\n              result[opt.prefix][opt.name] = true;\n              break;\n            case ParseType.NORMAL_VALUE_SYNTAX:\n            case ParseType.COLON_VALUE_SYNTAX:\n              ptr++;\n              if (ptr < len) {\n                result[opt.prefix][opt.name] = argv[ptr];\n              } else {\n                throw new Error(`-${arg} requires an argument.`);\n              }\n              break;\n            case ParseType.MAP_SYNTAX:\n              // NOP.\n              break;\n            default:\n              // Invalid.\n              throw new Error(`INTERNAL ERROR: Invalid parse type for -${arg}.`);\n          }\n        } else if (this._mapArgs.filter((mapArg) => {\n          if (arg.slice(0, mapArg.length) === mapArg) {\n            opt = this._parseMap[mapArg];\n            return true;\n          }\n          return false;\n        }).length > 0) {\n          // ASSUMPTION: Map args are mutually exclusive.\n          // Argument is -{mapArg}key=value\n          // If no value, set to ''.\n          let mapping = arg.slice(opt.name.length),\n            map = <{[name: string]: string}> result[opt.prefix][opt.name];\n          if (!map) {\n            map = result[opt.prefix][opt.name] = {};\n          }\n          let eqIdx = mapping.indexOf('=');\n          if (eqIdx !== -1) {\n            map[mapping.slice(0, eqIdx)] = mapping.slice(eqIdx + 1);\n          } else {\n            map[mapping] = \"\";\n          }\n        } else if (arg.indexOf(':') !== -1 && (opt = this._parseMap[arg.slice(0, arg.indexOf(':'))])) {\n          // Colon option.\n          if (opt.type === ParseType.COLON_VALUE_SYNTAX || opt.type === ParseType.COLON_VALUE_OR_FLAG_SYNTAX) {\n            result[opt.prefix][opt.name] = arg.slice(arg.indexOf(':') + 1);\n          } else {\n            // Unrecognized option.\n            throw new Error(`Unrecognized option: -${arg}`);\n          }\n        } else {\n          throw new Error(`Unrecognized option: -${arg}`);\n        }\n\n        if (opt.stopParsing) {\n          ptr++;\n          break;\n        }\n\n      } else {\n        break;\n      }\n\n      // Advance to next value.\n      ptr++;\n    }\n    // ptr is at raw args to program / JVM.\n    let unparsedArgs = argv.slice(ptr),\n      rv: ParseResult = {};\n    Object.keys(result).forEach((prefix) => {\n      rv[prefix] = new PrefixParseResult(result[prefix], unparsedArgs);\n    });\n    return rv;\n  }\n\n  /**\n   * Generates help text for the given prefixed options.\n   */\n  public help(prefix: string): string {\n    return _showHelp(this._rawDesc[prefix], prefix === 'default' ? '' : prefix);\n  }\n}\n\nfunction printCol(value: string, width: number): string {\n  var rv = value;\n  var padding = width - value.length;\n  while (padding-- > 0) {\n    rv += ' ';\n  }\n  return rv;\n}\n\nfunction _showHelp(category: DescriptionCategory, prefix: string): string {\n  var combinedKeys : {[k:string]:Option} = {};\n  var keyColWidth = 13;\n  Object.keys(category).forEach((key) => {\n    var opt = category[key];\n    // Ignored in help text.\n    if (opt.stopParsing) {\n      return;\n    }\n    var keys = [key];\n    if (opt.alias != null) {\n      keys.push(opt.alias);\n    }\n\n    let ckey: string;\n    if (opt.optDesc) {\n      ckey = keys.map((key: string) => `-${prefix}${key}${opt.optDesc}`).join(\"\\n\");\n    } else {\n      ckey = keys.map((key: string) => `-${prefix}${key}`).join(' | ');\n    }\n    combinedKeys[ckey] = opt;\n  });\n  return Object.keys(combinedKeys).map((key) => {\n    let option = combinedKeys[key];\n    if (option.optDesc) {\n      let cols = key.split('\\n');\n      let rv = cols.map((row) =>  `    ${row}`);\n      // Multiline.\n      return `${rv.join('\\n')}\\n                  ${option.desc}`;\n    } else {\n      let colText = printCol(key, keyColWidth);\n      if (colText.length === keyColWidth) {\n        return `    ${colText} ${option.desc}`;\n      } else {\n        return `    ${colText}\\n                  ${option.desc}`;\n      }\n    }\n  }).join('\\n') + '\\n';\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/option_parser.ts\n **/","/**\n * Aggregates .class file-related APIs under a single interface (Doppio.VM.ClassFile)\n */\n\nimport * as ConstantPool from './ConstantPool';\nimport * as Attributes from './attributes';\n\nexport * from './ClassData';\nexport * from './methods';\nexport * from './ClassLoader';\nexport * from './classpath';\nexport {ConstantPool, Attributes};\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/ClassFile.ts\n **/","/**\n * Stores the file position of every open file descriptor in the JVM.\n * Shared globally amongst JVM instances since this state is global.\n * We need to track this data since Node.js does not expose this OS state.\n */\nexport default class FDState {\n  private static _positions: {[fd: number]: number} = {};\n\n  public static open(fd: number, initialPosition: number) {\n    this._positions[fd] = initialPosition;\n  }\n\n  public static getPos(fd: number): number {\n    return this._positions[fd];\n  }\n\n  public static incrementPos(fd: number, incr: number): void {\n    this._positions[fd] += incr;\n  }\n\n  public static setPos(fd: number, newPos: number): void {\n    this._positions[fd] = newPos;\n  }\n\n  public static close(fd: number) {\n    delete this._positions[fd];\n  }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/fd_state.ts\n **/","/**\n * Top-level Doppio.Debug namespace.\n */\n\nimport Assert = require('./assert');\nimport * as Logging from './logging';\nimport * as Difflib from './difflib';\n\nexport {Assert, Logging, Difflib};\n\n\n\n/** WEBPACK FOOTER **\n ** ../../../src/Debug.ts\n **/"],"sourceRoot":""}